{"version":3,"file":"core_chat.min.js","sources":["../src/core_chat.js"],"sourcesContent":["// This file is part of Moodle - https://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <https://www.gnu.org/licenses/>.\n\n/**\n * AMD module for AI conversation chat interface.\n *\n * @module     mod_harpiasurvey/ai_conversation\n * @copyright  2025 Your Name\n * @license    https://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport Config from 'core/config';\nimport {get_string as getString} from 'core/str';\nimport $ from 'jquery';\n\nlet initializedTurns = false;\nlet initializedContinuous = false;\nlet commonHandlersRegistered = false;\nlet turnHandlersRegistered = false;\nlet treeHandlersRegistered = false;\n\n// Track current turn for each page (for turns mode).\nconst currentTurns = {};\n\n// Store conversation tree for each page (for filtering messages by branch history).\nconst conversationTrees = {};\n\n/**\n * Update the turn query parameter in the URL without reloading the page.\n *\n * @param {number} turn Turn number\n */\nconst updateTurnInUrl = (turn) => {\n    // eslint-disable-next-line no-console\n    console.log('updateTurnInUrl called with turn:', turn, 'type:', typeof turn);\n\n    if (typeof turn === 'undefined' || turn === null) {\n        // eslint-disable-next-line no-console\n        console.warn('updateTurnInUrl: turn is undefined or null, skipping');\n        return;\n    }\n\n    const turnNum = parseInt(turn, 10);\n    if (isNaN(turnNum) || turnNum < 1) {\n        // eslint-disable-next-line no-console\n        console.warn('updateTurnInUrl: invalid turn number:', turn, 'parsed as:', turnNum);\n        return;\n    }\n\n    try {\n        const url = new URL(window.location.href);\n        const currentTurn = url.searchParams.get('turn');\n\n        // Only update if the turn has changed.\n        if (currentTurn !== turnNum.toString()) {\n            url.searchParams.set('turn', turnNum.toString());\n            // Update URL without reloading the page.\n            window.history.replaceState({}, '', url.toString());\n            // eslint-disable-next-line no-console\n            console.log('updateTurnInUrl: Updated URL with turn', turnNum, 'New URL:', url.toString());\n        } else {\n            // eslint-disable-next-line no-console\n            console.log('updateTurnInUrl: Turn', turnNum, 'already in URL, skipping update');\n        }\n    } catch (e) {\n        // eslint-disable-next-line no-console\n        console.error('Error updating turn in URL:', e, 'turn value:', turn);\n    }\n};\n\n/**\n * Initialize the AI conversation functionality.\n */\n/**\n * Shared initializer for continuous and turns behaviors.\n *\n * @param {Object} [options] Options to control which behaviors initialize\n * @param {boolean} [options.enableTurns=true] Enable turns-mode wiring\n * @param {boolean} [options.enableContinuous=true] Enable continuous-mode wiring\n */\nconst initialize = (options = {}) => {\n    const enableTurns = options.enableTurns !== false;\n    const enableContinuous = options.enableContinuous !== false;\n    const needsTurns = enableTurns && !initializedTurns;\n    const needsContinuous = enableContinuous && !initializedContinuous;\n\n    if (!needsTurns && !needsContinuous) {\n        return;\n    }\n\n    // Check for containers\n    const containers = $('.ai-conversation-container');\n    if (containers.length === 0) {\n        return;\n    }\n\n    // Initialize multi-model chat containers (continuous mode only).\n    if (enableContinuous) {\n        const multiModelContainers = $('.multi-model-chat-container');\n        multiModelContainers.each(function() {\n            const pageid = parseInt($(this).data('pageid'), 10);\n            const cmid = parseInt($(this).data('cmid'), 10);\n            if (pageid && cmid) {\n                initMultiModelChat(pageid, cmid);\n            }\n        });\n    }\n\n    // Initialize turn tracking for turns mode.\n    if (enableTurns) {\n        $('.ai-conversation-container[data-behavior=\"turns\"]').each(function() {\n            const pageid = parseInt($(this).data('pageid'), 10);\n\n            if (!pageid) {\n                return;\n            }\n\n            // Always initialize, even if currentTurns[pageid] exists (for page refreshes).\n            // Get the highest turn number from existing messages.\n            const messagesContainer = $(`#chat-messages-page-${pageid}`);\n            let maxTurn = 0;\n            messagesContainer.find('[data-turn-id]').each(function() {\n                const turnId = parseInt($(this).data('turn-id'), 10);\n                if (turnId && turnId > maxTurn) {\n                    maxTurn = turnId;\n                }\n            });\n            // Current turn is the highest turn, or 1 if no turns exist.\n            const calculatedCurrentTurn = maxTurn > 0 ? maxTurn : 1;\n            if (!currentTurns[pageid]) {\n                currentTurns[pageid] = calculatedCurrentTurn;\n            }\n\n            // Check if turn is specified in URL query parameter.\n            const urlParams = new URLSearchParams(window.location.search);\n            const urlTurn = urlParams.get('turn');\n\n            let initialViewingTurn = currentTurns[pageid];\n            if (urlTurn !== null && urlTurn !== '') {\n                const parsedTurn = parseInt(urlTurn, 10);\n                if (!isNaN(parsedTurn) && parsedTurn > 0) {\n                    // Use turn from URL if it's valid.\n                    initialViewingTurn = parsedTurn;\n                }\n            }\n\n            // Set viewing turn (this will also update the URL if needed).\n            setViewingTurn(pageid, initialViewingTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            // Filter messages to show current turn and branch path if it's a branch.\n        filterMessagesByTurn(pageid, initialViewingTurn);\n            // Update subpage visibility.\n            updateSubpageVisibility(pageid);\n            // Render turn evaluation questions for the initial turn.\n            // Use setTimeout to ensure this doesn't block the tree loading.\n            setTimeout(() => {\n                ensureTurnEvaluationQuestionsRendered(pageid, initialViewingTurn).then(() => {\n                    loadTurnEvaluationResponses(pageid, initialViewingTurn);\n                }).catch((error) => {\n                    // eslint-disable-next-line no-console\n                    console.error('Error loading turn evaluation questions on init:', error);\n                });\n            }, 100);\n\n            // Initialize sidebar - show it by default and load tree.\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n            if (sidebar.length > 0) {\n                sidebar.show();\n                $(`.toggle-tree-btn[data-pageid=\"${pageid}\"]`).addClass('active');\n                // Always load tree on initialization - it will replace the spinner.\n                loadConversationTree(pageid);\n            }\n        });\n    }\n\n    // Initialize sidebar for continuous mode.\n    if (enableContinuous) {\n        $('.ai-conversation-container[data-behavior=\"continuous\"]').each(function() {\n            const pageid = parseInt($(this).data('pageid'), 10);\n            const container = $(this);\n\n            if (!pageid) {\n                return;\n            }\n\n            // Determine which conversation we're viewing (most recent by default).\n            // Get the most recent message and find its root conversation.\n            const messagesContainer = $(`#chat-messages-page-${pageid}`);\n            const allMessages = messagesContainer.find('.message');\n            if (allMessages.length > 0) {\n                // Get the last message (most recent).\n                const lastMessage = allMessages.last();\n                const lastMessageId = parseInt(lastMessage.data('messageid'), 10);\n                if (lastMessageId && !isNaN(lastMessageId)) {\n                    // Find the root conversation by finding the message with no parentid.\n                    // We'll traverse up the parent chain by checking all messages.\n                    let rootId = lastMessageId;\n                    let currentId = lastMessageId;\n                    let found = false;\n\n                    // Build a map of message ID to parent ID.\n                    const parentMap = new Map();\n                    allMessages.each(function() {\n                        const msgId = parseInt($(this).data('messageid'), 10);\n                        const parentId = parseInt($(this).data('parentid'), 10);\n                        if (msgId && !isNaN(msgId)) {\n                            parentMap.set(msgId, parentId && !isNaN(parentId) ? parentId : null);\n                        }\n                    });\n\n                    // Traverse up to find root (message with no parent).\n                    while (currentId && !found) {\n                        const parentId = parentMap.get(currentId);\n                        if (!parentId) {\n                            rootId = currentId;\n                            found = true;\n                        } else {\n                            currentId = parentId;\n                        }\n                    }\n\n                    if (found) {\n                        container.data('viewing-conversation', rootId);\n                        container.attr('data-viewing-conversation', rootId);\n                        // Filter messages to show only this conversation.\n                        filterMessagesByConversation(pageid, rootId);\n                    }\n                }\n            }\n\n            // Initialize sidebar - show it by default and load tree.\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n            if (sidebar.length > 0) {\n                sidebar.show();\n                // Always load tree on initialization - it will replace the spinner.\n                loadConversationTree(pageid);\n            }\n        });\n    }\n\n    // Register handlers based on mode.\n    registerCommonHandlers();\n    registerTreeHandlers();\n    if (enableTurns) {\n        registerTurnHandlers();\n    }\n\n    initializedTurns = initializedTurns || enableTurns;\n    initializedContinuous = initializedContinuous || enableContinuous;\n};\n\nexport const init = () => initialize({enableTurns: true, enableContinuous: true});\nexport const initTurns = () => initialize({enableTurns: true, enableContinuous: false});\nexport const initContinuous = () => initialize({enableTurns: false, enableContinuous: true});\n\n/**\n * Register common chat handlers (send/enter).\n */\nfunction registerCommonHandlers() {\n    if (commonHandlersRegistered) {\n        return;\n    }\n\n    // Handle send button clicks.\n    $(document).on('click', '.chat-send-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n\n        if (!cmid || !pageid) {\n            Notification.addNotification({\n                message: 'Missing cmid or pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const input = $(`#chat-input-page-${pageid}`);\n        if (input.length === 0) {\n            Notification.addNotification({\n                message: 'Chat input not found',\n                type: 'error'\n            });\n            return;\n        }\n\n        const inputValue = input.val();\n        if (!inputValue) {\n            return;\n        }\n\n        const message = inputValue.trim();\n\n        if (!message) {\n            return;\n        }\n\n        // Check if chat is locked (viewing a past turn).\n        const container = button.closest('.ai-conversation-container');\n        const behavior = container.data('behavior');\n        if (behavior === 'turns') {\n            const viewingTurn = getViewingTurn(pageid);\n            const currentTurn = getCurrentTurn(pageid);\n            // Ensure both are numbers for comparison.\n            const viewingTurnNum = parseInt(viewingTurn, 10);\n            const currentTurnNum = parseInt(currentTurn, 10);\n\n            // Allow sending if viewing turn >= current turn.\n            // If viewing turn > current turn, backend will create the next turn.\n            // Only block if viewing a past turn (viewingTurn < currentTurn).\n            if (viewingTurnNum < currentTurnNum) {\n                // Viewing a past turn - block it.\n                Notification.addNotification({\n                    message: 'Cannot send messages in a locked turn. ' +\n                        'Navigate to the current turn first.',\n                    type: 'error'\n                });\n                return;\n            }\n            // If viewingTurn >= currentTurn, allow it - backend will handle creating the right turn.\n\n            // Check max turns limit.\n            const maxTurns = container.data('max-turns');\n            if (maxTurns !== undefined && maxTurns !== null) {\n                const maxTurnsNum = parseInt(maxTurns, 10);\n                const turnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n                // Only block when the active conversation already reached the limit and the turn is complete\n                // (sending would create a new turn).\n                if (turnCount !== null && turnCount >= maxTurnsNum &&\n                    isTurnComplete(pageid, viewingTurnNum)) {\n                    getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                        Notification.addNotification({\n                            message: str,\n                            type: 'error'\n                        });\n                    });\n                    return;\n                }\n            }\n        }\n\n        // Get model from container data attribute (first available model).\n        const modelsdata = container.data('models');\n        let modelid = null;\n\n        if (modelsdata) {\n            // modelsdata is a comma-separated string, get first one.\n            const modelids = modelsdata.split(',');\n            if (modelids.length > 0) {\n                modelid = parseInt(modelids[0], 10);\n            }\n        }\n\n        if (!modelid) {\n            Notification.addNotification({\n                message: 'No model available',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Disable input and button.\n        input.prop('disabled', true);\n        button.prop('disabled', true);\n\n        // Clear input.\n        input.val('');\n\n        // Display user message with temporary ID (will be updated with real ID from server).\n        const tempId = 'temp-user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n        displayUserMessage(pageid, message, tempId);\n\n        // Show loading indicator.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        loading.show();\n\n        // Send message to AI.\n        sendMessage(cmid, pageid, message, modelid, button, input, loading);\n    });\n\n    // Handle Enter key in textarea (Shift+Enter for new line, Enter to send).\n    $(document).on('keydown', '.chat-input', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            $(this).closest('.ai-conversation-container').find('.chat-send-btn').click();\n        }\n    });\n\n    commonHandlersRegistered = true;\n}\n\n/**\n * Register handlers shared by both modes for tree navigation.\n */\nfunction registerTreeHandlers() {\n    if (treeHandlersRegistered) {\n        return;\n    }\n\n    // Handle tree node navigation clicks.\n    $(document).on('click', '.tree-node-content[data-action=\"navigate\"]', function(e) {\n        e.preventDefault();\n        const node = $(this);\n        const turnId = parseInt(node.data('turn-id'), 10);\n        const conversationId = parseInt(node.data('conversation-id'), 10);\n        const pageid = node.closest('.conversation-tree-sidebar').attr('id').replace('conversation-tree-sidebar-', '');\n        const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n        const behavior = container.data('behavior');\n\n        if (!pageid) {\n            return;\n        }\n\n        // For continuous mode, use conversation ID; for turns mode, use turn ID.\n        if (behavior === 'continuous' && conversationId) {\n            navigateToConversation(parseInt(pageid, 10), conversationId);\n        } else if (behavior === 'turns' && turnId) {\n            navigateToTurn(parseInt(pageid, 10), turnId);\n        }\n    });\n\n    // Handle conversation item click (in list view).\n    $(document).on('click', '.conversation-item', function(e) {\n        e.preventDefault();\n        const item = $(this);\n        const rootTurnId = parseInt(item.data('root-turn-id'), 10);\n        const conversationId = parseInt(item.data('conversation-id'), 10);\n        const sidebar = item.closest('.conversation-tree-sidebar');\n        const pageid = parseInt(sidebar.attr('id').replace('conversation-tree-sidebar-', ''), 10);\n        const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n        const behavior = container.data('behavior');\n\n        if (!pageid) {\n            return;\n        }\n\n        // For continuous mode, just navigate to the conversation (stay in list view).\n        // For turns mode, switch to detail view and navigate to the root turn.\n        if (behavior === 'continuous' && conversationId) {\n            navigateToConversation(pageid, conversationId);\n        } else if (behavior === 'turns' && rootTurnId) {\n            // Switch to detail view for this conversation.\n            sidebar.data('sidebar-view', 'detail');\n            // Navigate to the root turn of this conversation.\n            navigateToTurn(pageid, rootTurnId);\n        }\n    });\n\n    // Handle back to list button click.\n    $(document).on('click', '.back-to-list-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n\n        // Render the list view.\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        sidebar.data('sidebar-view', 'list'); // Set to list view\n\n        const tree = conversationTrees[pageid];\n        if (tree) {\n            renderConversationList(pageid, tree.roots);\n        } else {\n            loadConversationTree(pageid);\n        }\n    });\n\n    // Handle toggle children in tree.\n    $(document).on('click', '.toggle-children', function(e) {\n        e.stopPropagation();\n        const icon = $(this);\n        const childrenContainer = icon.closest('.tree-node').find('.tree-children');\n        if (childrenContainer.is(':visible')) {\n            childrenContainer.hide();\n            icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');\n        } else {\n            childrenContainer.show();\n            icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');\n        }\n    });\n\n    treeHandlersRegistered = true;\n}\n\n/**\n * Register handlers specific to turns mode.\n */\nfunction registerTurnHandlers() {\n    if (turnHandlersRegistered) {\n        return;\n    }\n\n    // Handle save turn evaluation questions button clicks.\n    // Use event delegation on document to catch dynamically added buttons.\n    $(document).on('click', '.save-turn-evaluation-questions-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        // eslint-disable-next-line no-console\n        console.log('=== Save turn evaluation button clicked! ===');\n\n        const button = $(this);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n\n        // eslint-disable-next-line no-console\n        console.log('Button element:', button[0]);\n        // eslint-disable-next-line no-console\n        console.log('Button data attributes:', {\n            'data-turn-id': button.attr('data-turn-id'),\n            'data-pageid': button.attr('data-pageid'),\n            'data-cmid': button.attr('data-cmid')\n        });\n        // eslint-disable-next-line no-console\n        console.log('Parsed values:', {turnId, pageid, cmid});\n\n        // Validate turnId (must be >= 1), pageid and cmid (must be > 0).\n        if (!turnId || turnId < 1 || !pageid || pageid <= 0 || !cmid || cmid <= 0) {\n            // eslint-disable-next-line no-console\n            console.error('Validation failed:', {turnId, pageid, cmid});\n            Notification.addNotification({\n                message: 'Missing required data (turnId: ' + turnId + ', pageid: ' + pageid + ', cmid: ' + cmid + ')',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Get all question responses from the evaluation container.\n        const evaluationContainer = button.closest('.turn-evaluation-questions');\n        const responses = {};\n\n        evaluationContainer.find('[data-questionid]').each(function() {\n            const questionId = $(this).data('questionid');\n            const questionType = $(this).data('questiontype');\n            let responseValue = null;\n\n            if (questionType === 'multiplechoice') {\n                // Multiple choice: collect all checked values.\n                const checked = evaluationContainer.find(`input[name=\"question_${questionId}_turn[]\"]:checked`);\n                const values = [];\n                checked.each(function() {\n                    values.push($(this).val());\n                });\n                responseValue = values.length > 0 ? JSON.stringify(values) : null;\n            } else if (questionType === 'select' || questionType === 'singlechoice' || questionType === 'likert') {\n                // Single choice: get selected value.\n                const selectSelector = `select[name=\"question_${questionId}_turn\"]`;\n                const inputSelector = `input[name=\"question_${questionId}_turn\"]:checked`;\n                const selected = evaluationContainer.find(selectSelector + ', ' + inputSelector);\n                responseValue = selected.length > 0 ? selected.val() : null;\n            } else if (questionType === 'number' || questionType === 'shorttext') {\n                // Number or short text: get input value.\n                const input = evaluationContainer.find(`input[name=\"question_${questionId}_turn\"]`);\n                responseValue = input.length > 0 ? input.val() : null;\n            } else if (questionType === 'longtext') {\n                // Long text: get textarea value.\n                const textarea = evaluationContainer.find(`textarea[name=\"question_${questionId}_turn\"]`);\n                responseValue = textarea.length > 0 ? textarea.val() : null;\n            }\n\n            if (responseValue !== null && responseValue !== '') {\n                responses[questionId] = responseValue;\n            }\n        });\n\n        // Disable button.\n        button.prop('disabled', true);\n        const originalText = button.text();\n        button.text('Saving...');\n\n        // Save all responses for this turn.\n        saveTurnEvaluationQuestions(cmid, pageid, turnId, responses, button, originalText);\n    });\n\n    // Handle next turn button clicks.\n    $(document).on('click', '.next-turn-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing pageid or cmid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const viewingTurn = getViewingTurn(pageid);\n        const currentTurn = getCurrentTurn(pageid);\n\n        if (viewingTurn < currentTurn) {\n            // Navigate to current turn (if viewing a past turn).\n            setViewingTurn(pageid, currentTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            filterMessagesByTurn(pageid, currentTurn); // Show branch path if it's a branch.\n            updateSubpageVisibility(pageid);\n            // Render questions and load saved responses for current turn.\n            ensureTurnEvaluationQuestionsRendered(pageid, currentTurn).then(() => {\n                loadTurnEvaluationResponses(pageid, currentTurn);\n            });\n            // Reload tree to update active indicator.\n            setTimeout(() => {\n                loadConversationTree(pageid);\n            }, 100);\n        } else if (viewingTurn === currentTurn && isTurnComplete(pageid, viewingTurn)) {\n            // Create next turn if current turn is complete.\n            // Check max turns limit first.\n            const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n            const maxTurns = container.data('max-turns');\n            if (maxTurns !== undefined && maxTurns !== null) {\n                const maxTurnsNum = parseInt(maxTurns, 10);\n                const turnCount = getTurnCountForConversation(pageid, viewingTurn);\n                if (turnCount !== null && turnCount >= maxTurnsNum) {\n                    getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                        Notification.addNotification({\n                            message: str,\n                            type: 'error'\n                        });\n                    });\n                    return;\n                }\n            }\n            const nextTurn = currentTurn + 1;\n            setViewingTurn(pageid, nextTurn);\n            currentTurns[pageid] = nextTurn;\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            filterMessagesByTurn(pageid, nextTurn);\n            updateSubpageVisibility(pageid);\n            // Render questions for new turn and clear form (no saved responses yet).\n            ensureTurnEvaluationQuestionsRendered(pageid, nextTurn).then(() => {\n                clearTurnEvaluationForm(pageid, nextTurn);\n            });\n            // Clear input and focus on it for new turn.\n            const input = $(`#chat-input-page-${pageid}`);\n            input.val('');\n            input.focus();\n            // Reload tree to update active indicator.\n            setTimeout(() => {\n                loadConversationTree(pageid);\n            }, 100);\n        }\n    });\n\n    // Handle toggle tree sidebar button clicks.\n    $(document).on('click', '.toggle-tree-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        if (sidebar.is(':visible')) {\n            sidebar.hide();\n            button.removeClass('active');\n        } else {\n            sidebar.show();\n            button.addClass('active');\n            // Load tree if not already loaded.\n            if (sidebar.find('.conversation-tree').children().length === 0) {\n                loadConversationTree(pageid);\n            }\n        }\n    });\n\n    // Handle create direct branch button clicks.\n    $(document).on('click', '.create-direct-branch-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const rootTurnId = parseInt(button.data('root-turn-id'), 10);\n\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create direct branch',\n                type: 'error'\n            });\n            return;\n        }\n\n        // If root_turn_id is provided (from conversation detail), use it.\n        // Otherwise, use the current turn (from main chat area).\n        const parentTurnId = rootTurnId || getCurrentTurn(pageid);\n        if (!parentTurnId) {\n            Notification.addNotification({\n                message: 'No parent turn found',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Create a direct branch from the parent turn.\n        createBranchFromTurn(cmid, pageid, parentTurnId);\n    });\n\n    // Handle close tree sidebar button clicks.\n    $(document).on('click', '.close-tree-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        sidebar.hide();\n        $(`.toggle-tree-btn[data-pageid=\"${pageid}\"]`).removeClass('active');\n    });\n\n    // Branch creation is now only available from the sidebar tree.\n\n    // Handle create branch button clicks (from tree).\n    $(document).on('click', '.create-branch-from-tree-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const turnId = parseInt(button.data('turn-id'), 10);\n\n        if (!pageid || !cmid || !turnId) {\n            Notification.addNotification({\n                message: 'Missing required data to create turn',\n                type: 'error'\n            });\n            return;\n        }\n        createBranchFromTurn(cmid, pageid, turnId, button);\n    });\n\n    // Handle create new root button clicks.\n    $(document).on('click', '.create-root-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create root',\n                type: 'error'\n            });\n            return;\n        }\n        createNewRoot(cmid, pageid);\n    });\n\n    // Handle previous turn button clicks.\n    $(document).on('click', '.prev-turn-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n\n        if (!pageid) {\n            Notification.addNotification({\n                message: 'Missing pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const viewingTurn = getViewingTurn(pageid);\n        if (viewingTurn > 1) {\n            const prevTurn = viewingTurn - 1;\n            setViewingTurn(pageid, prevTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            filterMessagesByTurn(pageid, prevTurn); // Show branch path if it's a branch.\n            updateSubpageVisibility(pageid);\n            // Render questions and load saved responses for previous turn.\n            ensureTurnEvaluationQuestionsRendered(pageid, prevTurn).then(() => {\n                loadTurnEvaluationResponses(pageid, prevTurn);\n            });\n            // Reload tree to update active indicator.\n            setTimeout(() => {\n                loadConversationTree(pageid);\n            }, 100);\n        }\n    });\n\n    // Handle toggle button clicks on individual turn separators.\n    $(document).on('click', '.toggle-turn-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const messagesContainer = $(`#chat-messages-page-${pageid}`);\n        const separator = button.closest('.turn-separator');\n        const isCollapsed = separator.data('collapsed') === true;\n\n        // Toggle collapsed state.\n        separator.data('collapsed', !isCollapsed);\n\n        // Show/hide messages for this turn.\n        messagesContainer.find('.message').each(function() {\n            const messageTurnId = $(this).data('turn-id');\n            if (messageTurnId && parseInt(messageTurnId, 10) === turnId) {\n                if (isCollapsed) {\n                    $(this).show();\n                } else {\n                    $(this).hide();\n                }\n            }\n        });\n\n        // Update icon.\n        const toggleIcon = button.find('.toggle-turn-icon');\n        if (isCollapsed) {\n            toggleIcon.removeClass('fa-chevron-down').addClass('fa-chevron-up');\n        } else {\n            toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');\n        }\n    });\n\n    // Handle toggle previous messages button clicks.\n    $(document).on('click', '.toggle-previous-messages-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n        // Toggle visibility of previous turn messages.\n        const previousMessages = messagesContainer.find('.previous-turn-message');\n        if (previousMessages.length === 0) {\n            return; // No previous messages to toggle.\n        }\n\n        const viewingTurn = getViewingTurn(pageid);\n        const isCurrentlyVisible = previousMessages.length > 0 && previousMessages.first().is(':visible');\n\n        if (isCurrentlyVisible) {\n            // Hide previous messages.\n            previousMessages.hide();\n            // Also hide separators for previous turns.\n            messagesContainer.find('.turn-separator').each(function() {\n                const separatorTurnId = $(this).data('turn-separator');\n                if (separatorTurnId) {\n                    const sepTurn = parseInt(separatorTurnId, 10);\n                    if (sepTurn < viewingTurn) {\n                        $(this).hide();\n                    }\n                }\n            });\n            button.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Mostrar anteriores');\n            button.attr('title', 'Mostrar conversas anteriores');\n        } else {\n            // Show previous messages.\n            previousMessages.show();\n            // Also show separators for previous turns.\n            const relevantTurnIds = getRelevantTurnIds(pageid, viewingTurn);\n            messagesContainer.find('.turn-separator').each(function() {\n                const separatorTurnId = $(this).data('turn-separator');\n                if (separatorTurnId) {\n                    const sepTurn = parseInt(separatorTurnId, 10);\n                    if (relevantTurnIds.includes(sepTurn) && sepTurn < viewingTurn) {\n                        $(this).show();\n                    }\n                }\n            });\n            button.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Ocultar anteriores');\n            button.attr('title', 'Ocultar conversas anteriores');\n        }\n    });\n\n    turnHandlersRegistered = true;\n}\n\n/**\n * Display user message in chat.\n *\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} messageid Optional message ID to prevent duplicates\n */\nconst displayUserMessage = (pageid, message, messageid = null) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const placeholder = messagesContainer.find('.text-muted.text-center');\n\n    if (placeholder.length > 0) {\n        placeholder.remove();\n    }\n\n    // Check if message already exists (by ID).\n    if (messageid) {\n        const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existing.length > 0) {\n            return; // Message already displayed.\n        }\n    }\n\n    // Also check for duplicate content in the last few messages (prevent double-sending).\n    const recentMessages = messagesContainer.find('.message').slice(-3);\n    let isDuplicate = false;\n    recentMessages.each(function() {\n        const contentEl = $(this).find('.content');\n        if (contentEl.length === 0) {\n            return true; // Continue to next message.\n        }\n        const msgContent = contentEl.text();\n        if (msgContent && msgContent.trim() === message.trim()) {\n            isDuplicate = true;\n            return false; // Break loop.\n        }\n    });\n    if (isDuplicate && !messageid) {\n        // If it's a duplicate and no ID provided, don't add it.\n        return;\n    }\n\n    // Double-check for duplicate before rendering (race condition protection).\n    if (messageid) {\n        const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existing.length > 0) {\n            return; // Message already displayed.\n        }\n    }\n\n    // Ensure message is a string.\n    const safeMessage = (message && typeof message === 'string') ? message : '';\n\n    // Get current viewing turn for turns mode.\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const behavior = container.data('behavior');\n    const viewingTurn = behavior === 'turns' ? getViewingTurn(pageid) : null;\n\n    const templateData = {\n        content: safeMessage,\n        id: messageid || 'temp-' + Date.now()\n    };\n\n    if (viewingTurn) {\n        templateData.turn_id = viewingTurn;\n        // Get hierarchical turn number.\n        const turnNumber = getTurnNumberForId(pageid, viewingTurn) || viewingTurn;\n        templateData.turn_label = 'Turno ' + turnNumber;\n    }\n\n    Templates.render('mod_harpiasurvey/chat_user_message', templateData).then((html) => {\n        // Final check before appending (prevent race conditions).\n        if (messageid) {\n            const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n            if (existing.length > 0) {\n                return; // Message was added while we were rendering.\n            }\n        }\n                Templates.appendNodeContents(messagesContainer[0], html);\n                // Insert turn separators after adding message.\n                const container = messagesContainer.closest('.ai-conversation-container');\n                const behavior = container.data('behavior');\n                if (behavior === 'turns') {\n                    insertTurnSeparators(pageid);\n                }\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    }).catch(() => {\n        // Fallback if template fails.\n        // Final check before appending.\n        if (messageid) {\n            const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n            if (existing.length > 0) {\n                return;\n            }\n        }\n        let messageHtml = '<div class=\"message my-3\" data-messageid=\"' + (messageid || 'temp-' + Date.now()) + '\"';\n        if (viewingTurn) {\n            messageHtml += ' data-turn-id=\"' + viewingTurn + '\"';\n        }\n        messageHtml += '><div class=\"d-flex justify-content-end\">' +\n            '<div class=\"border rounded p-2 bg-primary text-white\" style=\"max-width: 80%;\">' +\n            '<div class=\"content\">' + message + '</div>' +\n            '</div></div></div>';\n        messagesContainer.append(messageHtml);\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n    });\n};\n\n/**\n * Display AI message in chat.\n *\n * @param {number} pageid Page ID\n * @param {string} content Message content\n * @param {number} messageid Message ID\n * @param {number|null} turnId Turn ID (for turns mode)\n */\nconst displayAIMessage = (pageid, content, messageid, turnId = null) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    if (!messageid) {\n        // eslint-disable-next-line no-console\n        console.error('displayAIMessage called without messageid');\n        return Promise.resolve();\n    }\n\n    if (!content) {\n        // eslint-disable-next-line no-console\n        console.error('displayAIMessage called without content');\n        return Promise.resolve();\n    }\n\n    // Check if message already exists.\n    const existing = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n    if (existing.length > 0) {\n        // eslint-disable-next-line no-console\n        console.log('AI message already displayed:', messageid);\n        return Promise.resolve(); // Message already displayed.\n    }\n\n    // Ensure content is a string and not empty.\n    const safeContent = (content && typeof content === 'string') ? content : '';\n\n    const templateData = {\n        id: messageid,\n        content: safeContent\n    };\n\n    if (turnId) {\n        templateData.turn_id = turnId;\n        templateData.pageid = pageid;\n        // Get cmid from container.\n        const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n        templateData.cmid = container.data('cmid');\n        // Get hierarchical turn number.\n        const turnNumber = getTurnNumberForId(pageid, turnId) || turnId;\n        templateData.turn_label = 'Turno ' + turnNumber;\n    }\n\n    return Templates.render('mod_harpiasurvey/chat_ai_message', templateData).then((html) => {\n        // Final check before appending (prevent race conditions).\n        const existingCheck = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existingCheck.length > 0) {\n            return Promise.resolve(); // Message was added while we were rendering.\n        }\n        // appendNodeContents returns an Array, not a Promise, so we need to wrap it.\n        Templates.appendNodeContents(messagesContainer[0], html);\n\n        // Use requestAnimationFrame to ensure DOM is updated before proceeding.\n        return new Promise((resolve) => {\n            requestAnimationFrame(() => {\n                // Insert turn separators after adding message.\n                const container = messagesContainer.closest('.ai-conversation-container');\n                const behavior = container.data('behavior');\n                if (behavior === 'turns') {\n                    insertTurnSeparators(pageid);\n                }\n\n                // If this is a turn-based message, load evaluation questions.\n                if (turnId) {\n                    setTimeout(() => {\n                        ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n                            // Load saved responses for this turn.\n                            loadTurnEvaluationResponses(pageid, turnId);\n                        });\n                    }, 100);\n\n                    // Update current turn if this is a new turn.\n                    const currentTurn = getCurrentTurn(pageid);\n                    if (turnId > currentTurn) {\n                        currentTurns[pageid] = turnId;\n                        updateTurnDisplay(pageid);\n                    }\n\n                    // After displaying AI message, filter to show only current turn (hide previous).\n                    const viewingTurn = getViewingTurn(pageid);\n                    if (viewingTurn === turnId) {\n                filterMessagesByTurn(pageid, turnId);\n                    }\n                }\n\n                // Scroll after a brief delay to ensure DOM is fully updated.\n                setTimeout(() => {\n                    scrollToBottom(pageid);\n                }, 50);\n\n                // Resolve after DOM is updated (use another requestAnimationFrame to be sure).\n                requestAnimationFrame(() => {\n                    resolve();\n                });\n            });\n        });\n    }).catch(() => {\n        // Fallback if template fails.\n        // Final check before appending.\n        const existingCheck = messagesContainer.find(`[data-messageid=\"${messageid}\"]`);\n        if (existingCheck.length > 0) {\n            return Promise.resolve();\n        }\n        const messageHtml = '<div class=\"message my-3\" data-messageid=\"' + messageid + '\">' +\n            '<div class=\"d-flex\">' +\n            '<div class=\"border rounded p-2 bg-light\" style=\"max-width: 80%;\">' +\n            '<div class=\"content\">' + content + '</div>' +\n            '</div></div></div>';\n        messagesContainer.append(messageHtml);\n        // Scroll after a brief delay to ensure DOM is fully updated.\n        setTimeout(() => {\n            scrollToBottom(pageid);\n        }, 50);\n        return Promise.resolve();\n    });\n};\n\n/**\n * Send message to AI via AJAX.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} modelid Model ID\n * @param {jQuery} button Send button element\n * @param {jQuery} input Input textarea element\n * @param {jQuery} loading Loading indicator element\n */\nconst sendMessage = (cmid, pageid, message, modelid, button, input, loading) => {\n    // Get current viewing turn (for turns mode) or conversation (for continuous mode).\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const behavior = container.data('behavior');\n    const viewingTurn = behavior === 'turns' ? getViewingTurn(pageid) : null;\n\n    // For continuous mode, determine the parent message (last message in current conversation).\n    let parentid = null;\n    if (behavior === 'continuous') {\n        const viewingConversation = container.data('viewing-conversation');\n        const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n        if (viewingConversation) {\n            // We're viewing a specific conversation - find the last message in that conversation.\n            // Get all visible messages (they should be filtered to the current conversation).\n            const visibleMessages = messagesContainer.find('.message:visible');\n            if (visibleMessages.length > 0) {\n                // Get the last visible message's ID.\n                const lastMessage = visibleMessages.last();\n                const lastMessageId = parseInt(lastMessage.data('messageid'), 10);\n                if (lastMessageId && !isNaN(lastMessageId)) {\n                    parentid = lastMessageId;\n                }\n            }\n        } else {\n            // Not viewing a specific conversation - use the most recent message from any conversation.\n            // This will continue the most recent conversation or create a new one if none exists.\n            const allMessages = messagesContainer.find('.message');\n            if (allMessages.length > 0) {\n                // Get the last message by time (should be the most recent).\n                const lastMessage = allMessages.last();\n                const lastMessageId = parseInt(lastMessage.data('messageid'), 10);\n                if (lastMessageId && !isNaN(lastMessageId)) {\n                    parentid = lastMessageId;\n                }\n            }\n        }\n    }\n\n    const params = new URLSearchParams({\n        action: 'send_ai_message',\n        cmid: cmid,\n        pageid: pageid,\n        message: message,\n        modelid: modelid,\n        sesskey: Config.sesskey\n    });\n\n    // For turns mode, send the viewing turn so backend can use it.\n    if (behavior === 'turns' && viewingTurn) {\n        params.append('turn_id', viewingTurn);\n    }\n\n    // For continuous mode, send the parentid (conversation context).\n    if (behavior === 'continuous' && parentid) {\n        params.append('parentid', parentid);\n    }\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        loading.hide();\n\n        if (data.success) {\n            // For continuous mode, update the viewing conversation if a root conversation ID is provided.\n            if (behavior === 'continuous' && data.root_conversation_id) {\n                const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n                container.data('viewing-conversation', data.root_conversation_id);\n                container.attr('data-viewing-conversation', data.root_conversation_id);\n            }\n\n            // Display AI response (check for duplicates first).\n            if (data.messageid && data.content) {\n                // displayAIMessage is async, so we need to wait for it to complete\n                // before checking if the turn is complete and updating lock state.\n                displayAIMessage(pageid, data.content, data.messageid, data.turn_id).then(() => {\n                    // Update current turn if a new turn was created (turns mode only).\n                    // The backend may have created a new turn if the requested turn was complete.\n                    if (behavior === 'turns' && data.turn_id) {\n                        const currentTurn = getCurrentTurn(pageid);\n                        if (data.turn_id > currentTurn) {\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        } else if (data.turn_id === currentTurn + 1) {\n                            // Backend created next turn - update current turn.\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        }\n                    }\n\n                    // For continuous mode, reload the conversation tree to show updated conversation.\n                    if (behavior === 'continuous') {\n                        loadConversationTree(pageid);\n                    }\n\n                    // Update chat lock state after message is fully rendered in DOM.\n                    // Use a small delay to ensure DOM is completely updated and isTurnComplete can detect the new message.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                }).catch(() => {\n                    // If displayAIMessage fails, still try to update lock state.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                });\n            } else {\n                Notification.addNotification({\n                    message: 'Received response but missing message ID or content',\n                    type: 'error'\n                });\n                // Re-enable input on error.\n                input.prop('disabled', false);\n                button.prop('disabled', false);\n                input.focus();\n            }\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Error sending message',\n                type: 'error'\n            });\n            // Re-enable input on error.\n            input.prop('disabled', false);\n            button.prop('disabled', false);\n            input.focus();\n        }\n    })\n    .catch(error => {\n        loading.hide();\n        // eslint-disable-next-line no-console\n        console.error('Error sending message:', error);\n        Notification.addNotification({\n            message: 'Error sending message: ' + error.message,\n            type: 'error'\n        });\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    });\n};\n\n/**\n * Scroll chat to bottom.\n *\n * @param {number} pageid Page ID\n */\nconst scrollToBottom = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n\n    // Use requestAnimationFrame to ensure DOM is updated before scrolling.\n    requestAnimationFrame(() => {\n        const container = messagesContainer[0];\n        if (container) {\n            container.scrollTop = container.scrollHeight;\n        }\n    });\n};\n\n/**\n * Ensure turn evaluation questions are rendered for a specific turn.\n * This will render them if they don't exist, or do nothing if they already exist.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst ensureTurnEvaluationQuestionsRendered = (pageid, turnId) => {\n    // Check if questions are already rendered for this turn.\n    // Look in the container below the chat, not inside messages.\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        // Container wrapper doesn't exist - not in turns mode or page not loaded yet.\n        return Promise.resolve();\n    }\n\n    const existingContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (existingContainer.length > 0 && existingContainer.find('.question-item').length > 0) {\n        // Questions already rendered, return resolved promise.\n        return Promise.resolve();\n    }\n\n    // Questions not rendered yet, render them.\n    return loadTurnEvaluationQuestions(pageid, turnId);\n};\n\n/**\n * Load and render turn evaluation questions for a specific turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst loadTurnEvaluationQuestions = (pageid, turnId) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const questionsDataEl = $(`#turn-evaluation-questions-data-${pageid}`);\n\n    if (questionsDataEl.length === 0) {\n        return Promise.resolve(); // No evaluation questions configured.\n    }\n\n    try {\n        const allQuestions = JSON.parse(questionsDataEl.text());\n\n        // Filter questions that should appear for this turn based on visibility rules.\n        const questionsForTurn = allQuestions.filter(q => {\n            // Check min_turn: question appears from this turn onwards.\n            const minturn = q.min_turn || 1;\n            if (turnId < minturn) {\n                return false;\n            }\n\n            // Check show_only_turn: if set, question only shows on that specific turn.\n            if (q.show_only_turn !== null && q.show_only_turn !== undefined && q.show_only_turn !== '') {\n                const showOnlyTurnNum = parseInt(q.show_only_turn, 10);\n                const turnIdNum = parseInt(turnId, 10);\n                // eslint-disable-next-line no-console\n                console.log('  Checking show_only_turn:', showOnlyTurnNum, 'vs turnId:', turnIdNum);\n                if (showOnlyTurnNum !== turnIdNum) {\n                    // eslint-disable-next-line no-console\n                    console.log('  Rejected: show_only_turn', showOnlyTurnNum, '!== turnId', turnIdNum);\n                    return false;\n                }\n            }\n\n            // Check hide_on_turn: if set, question is hidden on that specific turn.\n            if (q.hide_on_turn !== null && q.hide_on_turn !== undefined && q.hide_on_turn !== '') {\n                const hideOnTurnNum = parseInt(q.hide_on_turn, 10);\n                const turnIdNum = parseInt(turnId, 10);\n                // eslint-disable-next-line no-console\n                console.log('  Checking hide_on_turn:', hideOnTurnNum, 'vs turnId:', turnIdNum);\n                if (hideOnTurnNum === turnIdNum) {\n                    // eslint-disable-next-line no-console\n                    console.log('  Rejected: hide_on_turn', hideOnTurnNum, '=== turnId', turnIdNum);\n                    return false;\n                }\n            }\n\n            // eslint-disable-next-line no-console\n            console.log('  Accepted question:', q.id);\n            return true;\n        });\n\n        // eslint-disable-next-line no-console\n        console.log('loadTurnEvaluationQuestions: questionsForTurn =', questionsForTurn);\n\n        // Find or create the evaluation container below the chat (not inside messages).\n        const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n        if (containerWrapper.length === 0) {\n            // Container wrapper doesn't exist - this shouldn't happen in turns mode, but handle gracefully.\n            return Promise.resolve();\n        }\n\n        // Get cmid from the container (needed for creating the container and rendering).\n        const cmid = container.data('cmid');\n        if (!cmid) {\n            // eslint-disable-next-line no-console\n            console.error('cmid not found for pageid:', pageid);\n            return Promise.resolve();\n        }\n\n        // Hide all turn evaluation containers first, then show only the current one.\n        containerWrapper.find('.turn-evaluation-questions').hide();\n\n        // Find or create the container for this specific turn.\n        let evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n        if (evaluationContainer.length === 0) {\n            // Create container for this turn.\n            const containerHtml = `<div class=\"turn-evaluation-questions mt-3 pt-3 border-top\" ` +\n                `data-turn-id=\"${turnId}\" data-pageid=\"${pageid}\" data-cmid=\"${cmid}\"></div>`;\n            containerWrapper.append(containerHtml);\n            evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n        }\n\n        // If no questions for this turn, clear the container and keep it hidden.\n        if (questionsForTurn.length === 0) {\n            evaluationContainer.html('').hide();\n            // eslint-disable-next-line no-console\n            console.log('No questions for turn', turnId, '- cleared and hid container');\n            return Promise.resolve();\n        }\n\n        // Render questions using the same template as regular questions.\n        // eslint-disable-next-line no-console\n        console.log('Rendering turn evaluation questions:', {pageid, turnId, cmid, questionsCount: questionsForTurn.length});\n\n        return Templates.render('mod_harpiasurvey/turn_evaluation_questions', {\n            questions: questionsForTurn,\n            has_questions: questionsForTurn.length > 0,\n            turn_id: turnId,\n            pageid: pageid,\n            cmid: cmid\n        }).then((html) => {\n            // Clear container first to remove any previous questions.\n            evaluationContainer.html(html).show(); // Show the container when rendering questions.\n            // eslint-disable-next-line no-console\n            console.log('Turn evaluation questions rendered. HTML length:', html.length);\n            // Verify button exists after rendering.\n            const button = evaluationContainer.find('.save-turn-evaluation-questions-btn');\n            // eslint-disable-next-line no-console\n            console.log('Save button found after render:', button.length, 'Button data:', {\n                turnId: button.data('turn-id'),\n                pageid: button.data('pageid'),\n                cmid: button.data('cmid')\n            });\n            // Return promise that resolves after rendering is complete.\n            return Promise.resolve();\n        }).catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error('Error rendering turn evaluation questions:', error);\n            return Promise.reject(error);\n        });\n    } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error('Error parsing turn evaluation questions data:', error);\n    }\n};\n\n/**\n * Save turn evaluation questions responses.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @param {object} responses Object with questionId -> responseValue mappings\n * @param {jQuery} button Save button element\n * @param {string} originalText Original button text\n */\nconst saveTurnEvaluationQuestions = (cmid, pageid, turnId, responses, button, originalText) => {\n    // Validate turnId before proceeding.\n    if (!turnId || turnId < 1) {\n        Notification.addNotification({\n            message: 'Invalid turn ID',\n            type: 'error'\n        });\n        button.prop('disabled', false);\n        button.text(originalText);\n        return;\n    }\n\n    // Save each response individually.\n    const savePromises = Object.keys(responses).map(questionId => {\n        const params = new URLSearchParams({\n            action: 'save_response',\n            cmid: cmid,\n            pageid: pageid,\n            questionid: questionId,\n            response: responses[questionId],\n            turn_id: turnId.toString(), // Ensure it's a string for URLSearchParams.\n            sesskey: Config.sesskey\n        });\n\n        // Debug: Log the URL being called.\n        const url = Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString();\n        // eslint-disable-next-line no-console\n        console.log('Saving turn evaluation response:', {\n            questionId: questionId,\n            turnId: turnId,\n            url: url\n        });\n\n        return fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        }).then(response => response.json()).then(data => {\n            // eslint-disable-next-line no-console\n            console.log('Response from save:', data);\n            return data;\n        });\n    });\n\n    Promise.all(savePromises).then(results => {\n        const allSuccess = results.every(r => r.success);\n        if (allSuccess) {\n            // Don't show notification for turn evaluation questions - they save silently.\n            // Just update button state and show timestamps.\n            const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n            const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n            const now = Math.floor(Date.now() / 1000); // Current timestamp in seconds.\n\n            // Show timestamps for all saved questions.\n            Object.keys(responses).forEach(questionId => {\n                showTurnEvaluationTimestamp(evaluationContainer, questionId, now);\n            });\n        } else {\n            Notification.addNotification({\n                message: 'Some responses could not be saved',\n                type: 'error'\n            });\n        }\n        button.prop('disabled', false);\n        button.text(originalText);\n    }).catch(error => {\n        // eslint-disable-next-line no-console\n        console.error('Error saving turn evaluation questions:', error);\n        Notification.addNotification({\n            message: 'Error saving responses: ' + error.message,\n            type: 'error'\n        });\n        button.prop('disabled', false);\n        button.text(originalText);\n    });\n};\n\n/**\n * Load saved responses for a specific turn and populate the form.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst loadTurnEvaluationResponses = (pageid, turnId) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n\n    if (evaluationContainer.length === 0) {\n        return; // Container not found.\n    }\n\n    const params = new URLSearchParams({\n        action: 'get_turn_responses',\n        cmid: cmid,\n        pageid: pageid,\n        turn_id: turnId,\n        sesskey: Config.sesskey\n    });\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.success && data.responses && Object.keys(data.responses).length > 0) {\n            // Populate form fields with saved responses.\n            Object.keys(data.responses).forEach(questionId => {\n                const responseData = data.responses[questionId];\n                const responseValue = typeof responseData === 'object' ? responseData.response : responseData;\n                const timestamp = typeof responseData === 'object' ? responseData.timemodified : null;\n\n                const questionItem = evaluationContainer.find(`[data-questionid=\"${questionId}\"]`);\n                const questionType = questionItem.data('questiontype');\n\n                if (questionType === 'multiplechoice') {\n                    // Multiple choice: parse JSON and check boxes.\n                    try {\n                        const values = JSON.parse(responseValue);\n                        if (Array.isArray(values)) {\n                            values.forEach(val => {\n                                const selector = `input[name=\"question_${questionId}_turn[]\"][value=\"${val}\"]`;\n                                evaluationContainer.find(selector).prop('checked', true);\n                            });\n                        }\n                    } catch (e) {\n                        // Invalid JSON, ignore.\n                    }\n                } else if (questionType === 'select') {\n                    // Select: set selected option.\n                    evaluationContainer.find(`select[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                } else if (questionType === 'singlechoice' || questionType === 'likert') {\n                    // Single choice: check radio button.\n                    const selector = `input[name=\"question_${questionId}_turn\"][value=\"${responseValue}\"]`;\n                    evaluationContainer.find(selector).prop('checked', true);\n                } else if (questionType === 'number' || questionType === 'shorttext') {\n                    // Number or short text: set input value.\n                    evaluationContainer.find(`input[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                } else if (questionType === 'longtext') {\n                    // Long text: set textarea value.\n                    evaluationContainer.find(`textarea[name=\"question_${questionId}_turn\"]`).val(responseValue);\n                }\n\n                // Show timestamp if available.\n                if (timestamp) {\n                    showTurnEvaluationTimestamp(evaluationContainer, questionId, timestamp);\n                } else {\n                    hideTurnEvaluationTimestamp(evaluationContainer, questionId);\n                }\n            });\n        } else {\n            // No responses found - clear the form.\n            clearTurnEvaluationForm(pageid, turnId);\n            // Hide all timestamps.\n            evaluationContainer.find('.turn-evaluation-saved-message').remove();\n        }\n    })\n    .catch(error => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading turn evaluation responses:', error);\n    });\n};\n\n/**\n * Clear the form for a specific turn (used when creating a new turn).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst clearTurnEvaluationForm = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    const evaluationContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n\n    if (evaluationContainer.length === 0) {\n        return; // Container not found.\n    }\n\n    // Clear all form fields.\n    evaluationContainer.find('input[type=\"radio\"]').prop('checked', false);\n    evaluationContainer.find('input[type=\"checkbox\"]').prop('checked', false);\n    evaluationContainer.find('select').val('');\n    evaluationContainer.find('input[type=\"text\"], input[type=\"number\"]').val('');\n    evaluationContainer.find('textarea').val('');\n\n    // Hide all timestamps.\n    evaluationContainer.find('.turn-evaluation-saved-message').remove();\n};\n\n/**\n * Show timestamp for a turn evaluation question.\n *\n * @param {jQuery} evaluationContainer Container element\n * @param {number} questionId Question ID\n * @param {number} timestamp Unix timestamp\n */\nconst showTurnEvaluationTimestamp = (evaluationContainer, questionId, timestamp) => {\n    // Remove existing timestamp if any.\n    hideTurnEvaluationTimestamp(evaluationContainer, questionId);\n\n    const questionItem = evaluationContainer.find(`[data-questionid=\"${questionId}\"]`);\n    if (questionItem.length === 0) {\n        return;\n    }\n\n    // Format timestamp.\n    const date = new Date(timestamp * 1000);\n    const datetimeStr = date.toLocaleString();\n\n    // Create timestamp message.\n    const messageHtml = '<div class=\"mt-2 small text-muted turn-evaluation-saved-message\" ' +\n        `data-questionid=\"${questionId}\">` +\n        '<i class=\"fa fa-check-circle\" aria-hidden=\"true\"></i> ' +\n        `Saved on ${datetimeStr}</div>`;\n\n    questionItem.append(messageHtml);\n};\n\n/**\n * Hide timestamp for a turn evaluation question.\n *\n * @param {jQuery} evaluationContainer Container element\n * @param {number} questionId Question ID\n */\nconst hideTurnEvaluationTimestamp = (evaluationContainer, questionId) => {\n    evaluationContainer.find(`.turn-evaluation-saved-message[data-questionid=\"${questionId}\"]`).remove();\n};\n\n/**\n * Get the current turn for a page (highest turn with messages).\n *\n * @param {number} pageid Page ID\n * @return {number} Current turn number\n */\nconst getCurrentTurn = (pageid) => {\n    return currentTurns[pageid] || 1;\n};\n\n/**\n * Get the viewing turn for a page (which turn is being displayed).\n *\n * @param {number} pageid Page ID\n * @return {number} Viewing turn number\n */\nconst getViewingTurn = (pageid) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    return parseInt(container.data('viewing-turn') || getCurrentTurn(pageid), 10);\n};\n\n/**\n * Check if a turn has any messages.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn has at least one message\n */\nconst turnHasMessages = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    let messageCount = 0;\n\n    messagesContainer.find('.message').each(function() {\n        const messageTurnId = $(this).data('turn-id');\n        if (parseInt(messageTurnId, 10) === turnId) {\n            messageCount++;\n        }\n    });\n\n    return messageCount > 0;\n};\n\n/**\n * Check if a turn is complete (has 2 messages: 1 user + 1 AI).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn is complete\n */\nconst isTurnComplete = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    let userCount = 0;\n    let aiCount = 0;\n\n    messagesContainer.find('.message').each(function() {\n        const messageTurnId = $(this).data('turn-id');\n        if (parseInt(messageTurnId, 10) === turnId) {\n            const role = $(this).data('role');\n            if (role === 'user') {\n                userCount++;\n            } else if (role === 'assistant') {\n                aiCount++;\n            }\n        }\n    });\n\n    return userCount >= 1 && aiCount >= 1;\n};\n\n/**\n * Set the viewing turn for a page.\n *\n * @param {number} pageid Page ID\n * @param {number} turn Turn number\n */\nconst setViewingTurn = (pageid, turn) => {\n    // eslint-disable-next-line no-console\n    console.log('setViewingTurn called for pageid:', pageid, 'turn:', turn);\n\n    if (!pageid || !turn) {\n        // eslint-disable-next-line no-console\n        console.warn('setViewingTurn: Invalid pageid or turn', {pageid, turn});\n        return;\n    }\n\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    if (container.length === 0) {\n        // eslint-disable-next-line no-console\n        console.warn('setViewingTurn: Container not found for pageid:', pageid);\n        return;\n    }\n\n    const previousTurn = container.data('viewing-turn');\n    container.data('viewing-turn', turn);\n    // Also set as attribute to ensure it's in the DOM.\n    container.attr('data-viewing-turn', turn);\n\n    // Update URL query parameter with current turn.\n    updateTurnInUrl(turn);\n\n    // If turn changed and we're in turns mode, ensure questions are loaded for the new turn.\n    // This handles cases where setViewingTurn is called directly without navigateToTurn.\n    if (previousTurn !== turn && container.data('behavior') === 'turns') {\n        // Use setTimeout to avoid blocking, and ensure this doesn't interfere with navigateToTurn.\n        setTimeout(() => {\n            // Only load if navigateToTurn hasn't already handled it (check if messages are filtered).\n            // If no messages are visible, navigateToTurn probably hasn't run yet, so we should load questions.\n            // But actually, let's just always ensure questions are loaded when turn changes.\n            ensureTurnEvaluationQuestionsRendered(pageid, turn).then(() => {\n                loadTurnEvaluationResponses(pageid, turn);\n            });\n        }, 50);\n    }\n};\n\n/**\n * Update turn display (badge and navigation buttons).\n *\n * @param {number} pageid Page ID\n */\nconst updateTurnDisplay = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n\n    // Update turn badge with hierarchical number.\n    const turnNumber = getTurnNumberForId(pageid, viewingTurn) || viewingTurn;\n    const turnLabel = 'Turno ' + turnNumber;\n    $(`#current-turn-number-${pageid}`).text(turnLabel);\n\n    // Show/hide previous button.\n    const prevBtn = $(`.prev-turn-btn[data-pageid=\"${pageid}\"]`);\n    if (viewingTurn > 1) {\n        prevBtn.show();\n    } else {\n        prevBtn.hide();\n    }\n\n    // Show/hide next button based on turn completion.\n    const nextBtn = $(`.next-turn-btn[data-pageid=\"${pageid}\"]`);\n    if (viewingTurn < currentTurn) {\n        // Viewing a past turn - show button to go to current.\n        nextBtn.show().html('Go to current turn <i class=\"fa fa-chevron-right\"></i>');\n    } else if (viewingTurn === currentTurn) {\n        // Viewing current turn - show button only if turn is complete.\n        if (isTurnComplete(pageid, viewingTurn)) {\n            nextBtn.show().html('Next turn <i class=\"fa fa-chevron-right\"></i>');\n        } else {\n            nextBtn.hide();\n        }\n    } else {\n        // Viewing future turn (shouldn't happen, but hide button).\n        nextBtn.hide();\n    }\n\n    // Create branch button removed - branches can only be created from sidebar.\n\n    // Update subpage visibility based on current turn.\n    updateSubpageVisibility(pageid);\n};\n\n/**\n * Update subpage visibility based on current turn.\n *\n * @param {number} pageid Page ID\n */\nconst updateSubpageVisibility = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const subpagesContainer = $(`#subpages-container-${pageid}`);\n\n    if (subpagesContainer.length === 0) {\n        return; // No subpages container found.\n    }\n\n    // Update subpage visibility.\n    subpagesContainer.find('.subpage-item').each(function() {\n        const $subpage = $(this);\n        const visibilityType = $subpage.data('visibility-type');\n        const turnNumber = $subpage.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = false;\n        }\n\n        if (shouldShow) {\n            $subpage.slideDown(200);\n            // Update question visibility within this subpage.\n            updateSubpageQuestionVisibility($subpage, viewingTurn);\n        } else {\n            $subpage.slideUp(200);\n        }\n    });\n};\n\n/**\n * Update question visibility within a subpage based on current turn.\n *\n * @param {jQuery} $subpage Subpage jQuery element\n * @param {number} viewingTurn Current viewing turn\n */\nconst updateSubpageQuestionVisibility = ($subpage, viewingTurn) => {\n    $subpage.find('.question-item').each(function() {\n        const $question = $(this);\n        const visibilityType = $question.data('visibility-type') || 'all_turns';\n        const turnNumber = $question.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = true; // Default to showing if not set.\n        }\n\n        if (shouldShow) {\n            $question.slideDown(200);\n        } else {\n            $question.slideUp(200);\n        }\n    });\n};\n\n/**\n * Update chat lock state (disable input if viewing past turn).\n *\n * @param {number} pageid Page ID\n */\nconst updateChatLockState = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n    // Ensure both are numbers for comparison.\n    const viewingTurnNum = parseInt(viewingTurn, 10);\n    const currentTurnNum = parseInt(currentTurn, 10);\n    const input = $(`#chat-input-page-${pageid}`);\n    const sendBtn = $(`.chat-send-btn[data-pageid=\"${pageid}\"]`);\n    const lockMessage = $(`#turn-locked-message-${pageid}`);\n    const container = input.closest('.ai-conversation-container');\n    const maxTurns = container.data('max-turns');\n    const maxTurnsNum = (maxTurns !== undefined && maxTurns !== null) ? parseInt(maxTurns, 10) : null;\n    const conversationTurnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n    const hasReachedTurnLimit = maxTurnsNum !== null &&\n        conversationTurnCount !== null &&\n        conversationTurnCount >= maxTurnsNum;\n\n    if (viewingTurnNum < currentTurnNum) {\n        // Viewing a past turn - lock chat.\n        input.prop('disabled', true);\n        sendBtn.prop('disabled', true);\n        if (lockMessage.length > 0) {\n            lockMessage.show();\n        }\n        // Hide direct branch button when viewing past turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n    } else if (viewingTurnNum === currentTurnNum && isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's complete - check max turns limit.\n        // Only lock if turn has messages AND max turns is reached.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n        } else {\n            // Turn complete but not at max - lock chat (user must create next turn).\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input to focus on next turn.\n            if (lockMessage.length > 0) {\n                lockMessage.hide(); // Don't show \"locked\" message, just disable input.\n            }\n            // Show direct branch button.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.show();\n            }\n        }\n    } else if (viewingTurnNum === currentTurnNum && !isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's not complete - check max turns and if we're waiting for AI response.\n        // Check max turns limit first, but only if turn has messages.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n            return;\n        }\n        // If we just sent a message, input should stay disabled until AI responds.\n        // We'll check if there's a loading indicator to determine this.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        if (loading.is(':visible')) {\n            // Waiting for AI response - keep input disabled.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n        } else {\n            // Not waiting for response - unlock chat.\n            input.prop('disabled', false);\n            sendBtn.prop('disabled', false);\n        }\n        // Hide direct branch button when turn is not complete.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    } else {\n        // Viewing future turn (shouldn't happen, but unlock just in case).\n        input.prop('disabled', false);\n        sendBtn.prop('disabled', false);\n        // Hide direct branch button when viewing future turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    }\n};\n\n/**\n * Filter messages by turn (show only messages from specified turn, hide previous turns).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @param {boolean} showPrevious Whether to show previous turn messages\n */\n/**\n * Insert turn separators between different turns in the conversation.\n *\n * @param {number} pageid Page ID\n */\n/**\n * Get branch info for a turn from the conversation tree.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Object|null} Branch info with is_branch and branch_label, or null if not found\n */\nconst getBranchInfo = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return null;\n    }\n\n    // Find the node for this turn in the tree.\n    const findNode = (nodes, targetId) => {\n        for (const node of nodes) {\n            if (node.turn_id === targetId) {\n                return node;\n            }\n            if (node.children && node.children.length > 0) {\n                const found = findNode(node.children, targetId);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n        return null;\n    };\n\n    const node = findNode(tree.roots, turnId);\n    if (!node) {\n        return null;\n    }\n\n    return {\n        is_branch: !node.is_root,\n        branch_label: node.branch_label || null\n    };\n};\n\n/**\n * Update turn labels in existing messages (after tree is loaded).\n *\n * @param {number} pageid Page ID\n */\nconst updateMessageTurnLabels = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const turnId = parseInt($msg.data('turn-id'), 10);\n        if (turnId) {\n            // Use hierarchical turn number.\n            const turnNumber = getTurnNumberForId(pageid, turnId) || turnId;\n            const turnLabel = 'Turno ' + turnNumber;\n            // Update badge in message - find the badge that contains turn label.\n            const $badge = $msg.find('.badge').filter(function() {\n                // Find badge that's in the position-absolute div (turn label badge).\n                return $(this).closest('.position-absolute').length > 0;\n            });\n            if ($badge.length > 0) {\n                $badge.text(turnLabel);\n            } else {\n                // Fallback: update first badge if position-absolute not found.\n                const $firstBadge = $msg.find('.badge').first();\n                if ($firstBadge.length > 0) {\n                    $firstBadge.text(turnLabel);\n                }\n            }\n        }\n    });\n};\n\n/**\n * Load messages for a specific turn and render them.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise<string>} Promise that resolves to HTML string of messages\n */\nconst loadTurnMessages = (pageid, turnId) => {\n    return new Promise((resolve) => {\n        const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n        const cmid = container.data('cmid');\n\n        const params = new URLSearchParams();\n        params.append('action', 'get_conversation_history');\n        params.append('cmid', cmid);\n        params.append('pageid', pageid);\n        params.append('sesskey', Config.sesskey);\n\n        fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n            },\n            body: params.toString()\n        })\n        .then((response) => response.json())\n        .then((data) => {\n            if (data.success && data.messages) {\n                // eslint-disable-next-line no-console\n                console.log(`loadTurnMessages: turnId=${turnId}, total messages=${data.messages.length}`);\n                // eslint-disable-next-line no-console\n                // Filter messages for this turn (handle both string and number turn_id).\n                const turnMessages = data.messages.filter(msg => {\n                    const msgTurnId = msg.turn_id !== null && msg.turn_id !== undefined ?\n                        parseInt(msg.turn_id, 10) : null;\n                    return msgTurnId === turnId;\n                });\n\n                if (turnMessages.length === 0) {\n                    resolve('');\n                    return;\n                }\n\n    const renderPromises = turnMessages.map(msg => {\n        const templateData = {\n            id: msg.id,\n            content: msg.content,\n            turn_id: msg.turn_id\n        };\n\n                    // Always use \"Turno X\".\n                    templateData.turn_label = 'Turno ' + turnId;\n\n                    // Render message based on role.\n                    const templateName = msg.role === 'user' ?\n                        'mod_harpiasurvey/chat_user_message' :\n                        'mod_harpiasurvey/chat_ai_message';\n\n                    return Templates.render(templateName, templateData).then(html => {\n                        // Remove any inline display:none styles that might have been added by filterMessagesByTurn.\n                        // Create a temporary jQuery object to manipulate the HTML.\n                        const $temp = $('<div>').html(html);\n                        $temp.find('[style*=\"display: none\"]').removeAttr('style');\n                        $temp.find('[style*=\"display:none\"]').removeAttr('style');\n                        return $temp.html();\n                    });\n                });\n\n                // Wait for all messages to render.\n                Promise.all(renderPromises).then(htmls => {\n                    // eslint-disable-next-line no-console\n                    console.log(`loadTurnMessages: rendered ${htmls.length} HTML fragments for turn ${turnId}`);\n                    const combinedHTML = htmls.join('');\n                    // eslint-disable-next-line no-console\n                    console.log(`loadTurnMessages: combined HTML length=${combinedHTML.length}`);\n                    resolve(combinedHTML);\n                }).catch((error) => {\n                    // eslint-disable-next-line no-console\n                    console.error('Error rendering turn messages:', error);\n                    resolve('');\n                });\n            } else {\n                resolve('');\n            }\n        })\n        .catch(() => {\n            resolve('');\n        });\n    });\n};\n\n/**\n * Reorganize messages into accordion structure (roots with branches inside).\n *\n * @param {number} pageid Page ID\n */\n// eslint-disable-next-line no-unused-vars\nconst reorganizeMessagesIntoAccordion = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const tree = conversationTrees[pageid];\n    const viewingTurn = getViewingTurn(pageid);\n\n    if (!tree || !tree.roots) {\n        return; // No tree structure available yet.\n    }\n\n    // First, collect existing messages from DOM.\n    const messagesByTurn = {};\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const turnId = parseInt($msg.data('turn-id'), 10);\n        if (turnId) {\n            if (!messagesByTurn[turnId]) {\n                messagesByTurn[turnId] = [];\n            }\n            // Clone the message and remove any inline display styles.\n            const $clone = $msg.clone();\n            $clone.removeAttr('style');\n            $clone.find('[style*=\"display: none\"], [style*=\"display:none\"]').removeAttr('style');\n            messagesByTurn[turnId].push($clone[0].outerHTML);\n        }\n    });\n\n    // Build accordion structure from tree.\n    const allRootPromises = [];\n\n    tree.roots.forEach(root => {\n        const rootTurnId = root.turn_id;\n        const branches = root.children || [];\n\n        // Collect promises for loading messages for this root and its branches.\n        const branchPromises = [];\n\n        // Function to create promise for loading branch messages.\n        const createBranchPromise = (turnId, branchLabel, isRoot) => {\n            return new Promise((resolve) => {\n                // Check if we already have messages in DOM.\n                if (messagesByTurn[turnId] && messagesByTurn[turnId].length > 0) {\n                    resolve({\n                        branch_turn_id: turnId,\n                        branch_label: branchLabel,\n                        is_root_messages: isRoot,\n                        messages_html: messagesByTurn[turnId].join(''),\n                        is_expanded: viewingTurn === turnId,\n                        is_active: viewingTurn === turnId\n                    });\n                } else {\n                    // Load messages from server.\n                    loadTurnMessages(pageid, turnId).then(messagesHTML => {\n                        resolve({\n                            branch_turn_id: turnId,\n                            branch_label: branchLabel,\n                            is_root_messages: isRoot,\n                            messages_html: messagesHTML || '',\n                            is_expanded: viewingTurn === turnId,\n                            is_active: viewingTurn === turnId\n                        });\n                    }).catch(() => {\n                        resolve({\n                            branch_turn_id: turnId,\n                            branch_label: branchLabel,\n                            is_root_messages: isRoot,\n                            messages_html: '',\n                            is_expanded: viewingTurn === turnId,\n                            is_active: viewingTurn === turnId\n                        });\n                    });\n                }\n            });\n        };\n\n        // Add root messages promise.\n        branchPromises.push(createBranchPromise(rootTurnId, rootTurnId.toString(), true));\n\n        // Add branch messages promises.\n        branches.forEach(branch => {\n            const branchTurnId = branch.turn_id;\n            branchPromises.push(createBranchPromise(branchTurnId, branch.branch_label || `${rootTurnId}.1`, false));\n        });\n\n        // Create promise for this root that waits for all its branches.\n        const rootPromise = Promise.all(branchPromises).then(branchesWithMessages => {\n            // Filter out branches with no messages.\n            const validBranches = branchesWithMessages.filter(b => b.messages_html && b.messages_html.trim().length > 0);\n\n            // Only add root if it has messages or branches.\n            if (validBranches.length > 0 || branches.length > 0) {\n                const isRootExpanded = viewingTurn === rootTurnId ||\n                                      branches.some(b => viewingTurn === b.turn_id);\n\n                return {\n                    root_turn_id: rootTurnId,\n                    is_expanded: isRootExpanded,\n                    branches: validBranches\n                };\n            }\n            return null;\n        });\n\n        allRootPromises.push(rootPromise);\n    });\n\n    // Wait for all roots to load their messages, then render accordion.\n    Promise.all(allRootPromises).then(rootsData => {\n        const validRoots = rootsData.filter(r => r !== null);\n        if (validRoots.length > 0) {\n            renderAccordion(messagesContainer, validRoots);\n        }\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading messages for accordion:', error);\n    });\n};\n\n/**\n * Render accordion structure in the messages container.\n *\n * @param {jQuery} messagesContainer Messages container element\n * @param {Array} accordionHTML Array of root accordion data\n */\nconst renderAccordion = (messagesContainer, accordionHTML) => {\n    if (accordionHTML.length === 0) {\n        // eslint-disable-next-line no-console\n        console.log('renderAccordion: No accordion data to render');\n        return;\n    }\n\n    // Render each root accordion.\n    const renderPromises = accordionHTML.map((rootData) => {\n        return Templates.render('mod_harpiasurvey/root_accordion', rootData);\n    });\n\n    Promise.all(renderPromises).then(htmls => {\n        htmls.forEach((html, idx) => {\n            // Check if messages_html content is in the rendered HTML.\n            const hasBranchMessages = html.indexOf('branch-messages') !== -1;\n            const hasMessageClass = html.indexOf('class=\"message') !== -1;\n            // eslint-disable-next-line no-console\n            console.log(`Root ${idx}: has branch-messages div: ${hasBranchMessages}, has message class: ${hasMessageClass}`);\n\n            // Extract and check branch-messages content.\n            const branchMessagesRegex = /<div[^>]*branch-messages[^>]*>([\\s\\S]*?)<\\/div>/g;\n            let match;\n            let branchIdx = 0;\n            while ((match = branchMessagesRegex.exec(html)) !== null) {\n                const content = match[1];\n                // eslint-disable-next-line no-console\n                console.log(`Root ${idx}, Branch ${branchIdx} messages content length:`, content.length);\n                // eslint-disable-next-line no-console\n                console.log(`Root ${idx}, Branch ${branchIdx} messages content preview:`, content.substring(0, 200));\n                branchIdx++;\n            }\n        });\n        const combinedHTML = htmls.join('');\n        // eslint-disable-next-line no-console\n        console.log('renderAccordion: Combined HTML length:', combinedHTML.length);\n        messagesContainer.html(combinedHTML);\n\n        // Verify messages are in the DOM.\n        messagesContainer.find('.branch-messages').each(function() {\n            const $branch = $(this);\n            const turnId = $branch.data('branch-turn');\n            const content = $branch.html();\n            // eslint-disable-next-line no-console\n            console.log(`Branch ${turnId} content length in DOM:`, content ? content.length : 0);\n            if (!content || content.trim().length === 0) {\n                // eslint-disable-next-line no-console\n                console.warn(`Branch ${turnId} is EMPTY in DOM!`);\n            }\n        });\n\n        // Initialize Bootstrap collapse for all collapsible elements.\n        messagesContainer.find('.collapse').each(function() {\n            const $collapse = $(this);\n            // eslint-disable-next-line no-console\n            console.log('Initializing collapse:', {\n                id: $collapse.attr('id'),\n                hasShow: $collapse.hasClass('show'),\n                isVisible: $collapse.is(':visible'),\n                height: $collapse.height()\n            });\n\n            // Force show if it has the 'show' class.\n            if ($collapse.hasClass('show')) {\n                // Remove any inline styles that might hide it and ensure it's visible.\n                $collapse.css({\n                    'display': 'block',\n                    'visibility': 'visible',\n                    'opacity': '1'\n                });\n                // Initialize Bootstrap collapse component.\n                $collapse.collapse('show');\n                // Update chevron icon (right = expanded).\n                const $header = $collapse.siblings('.root-accordion-header, .branch-accordion-header').first();\n                if ($header.length > 0) {\n                    const $icon = $header.find('.fa-chevron-right, .fa-chevron-down');\n                    $icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');\n                }\n            } else {\n                // Initialize but keep collapsed.\n                $collapse.collapse();\n            }\n        });\n\n        // Initialize accordion toggle handlers.\n        messagesContainer.find('.root-accordion-header, .branch-accordion-header').on('click', function(e) {\n            e.preventDefault();\n            const $header = $(this);\n            const target = $header.data('target');\n            if (target) {\n                const $target = $(target);\n                // eslint-disable-next-line no-console\n                console.log('Toggling collapse:', {\n                    target: target,\n                    hasShow: $target.hasClass('show'),\n                    isVisible: $target.is(':visible')\n                });\n                $target.collapse('toggle');\n                // Update chevron icon (right = expanded, down = collapsed).\n                const $icon = $header.find('.fa-chevron-right, .fa-chevron-down');\n                // After toggle, check if it's now expanded or collapsed.\n                setTimeout(() => {\n                    if ($target.hasClass('show')) {\n                        $icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');\n                    } else {\n                        $icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');\n                    }\n                }, 100);\n            }\n        });\n\n        // Add event listeners to track collapse state changes and update chevron icons.\n        messagesContainer.find('.collapse').on('shown.bs.collapse', function() {\n            const $collapse = $(this);\n            const $header = $collapse.siblings('.root-accordion-header, .branch-accordion-header').first();\n            if ($header.length > 0) {\n                const $icon = $header.find('.fa-chevron-right, .fa-chevron-down');\n                $icon.removeClass('fa-chevron-down').addClass('fa-chevron-right');\n            }\n        }).on('hidden.bs.collapse', function() {\n            const $collapse = $(this);\n            const $header = $collapse.siblings('.root-accordion-header, .branch-accordion-header').first();\n            if ($header.length > 0) {\n                const $icon = $header.find('.fa-chevron-right, .fa-chevron-down');\n                $icon.removeClass('fa-chevron-right').addClass('fa-chevron-down');\n            }\n        });\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error rendering accordion:', error);\n        // Fallback: keep messages as they are.\n    });\n};\n\nconst insertTurnSeparators = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    let lastTurnId = null;\n\n    // Get the current viewing turn to scope separators to the current conversation.\n    const viewingTurn = getViewingTurn(pageid);\n    let relevantTurnIds = [];\n    let relevantTurnIdsSet = new Set();\n\n    if (viewingTurn) {\n        // Get all turn IDs that belong to the current conversation.\n        relevantTurnIds = getRelevantTurnIds(pageid, viewingTurn);\n        relevantTurnIdsSet = new Set(relevantTurnIds);\n    }\n\n    // Remove existing separators first.\n    messagesContainer.find('.turn-separator').remove();\n\n    // Iterate through messages and insert separators when turn changes.\n    // Only insert separators for messages that belong to the current conversation.\n    messagesContainer.find('.message').each(function() {\n        const messageTurnId = $(this).data('turn-id');\n        if (messageTurnId) {\n            const currentTurnId = parseInt(messageTurnId, 10);\n\n            // Only process messages that belong to the current conversation.\n            if (viewingTurn && !relevantTurnIdsSet.has(currentTurnId)) {\n                return; // Skip messages from other conversations.\n            }\n\n            // If this is a different turn and we haven't inserted a separator yet.\n            if (lastTurnId !== null && currentTurnId !== lastTurnId) {\n                // Insert separator before this message.\n                const container = messagesContainer.closest('.ai-conversation-container');\n                const cmid = container.data('cmid');\n\n                // Get branch info from conversation tree.\n                const branchInfo = getBranchInfo(pageid, currentTurnId);\n                const isBranch = branchInfo ? branchInfo.is_branch : false;\n                const branchLabel = branchInfo ? branchInfo.branch_label : null;\n\n                // Get hierarchical turn number.\n                const turnNumber = getTurnNumberForId(pageid, currentTurnId) || currentTurnId;\n                const viewingTurn = getViewingTurn(pageid);\n                const isPreviousTurn = (currentTurnId < viewingTurn);\n\n                Templates.render('mod_harpiasurvey/turn_separator', {\n                    turn_id: currentTurnId,\n                    turn_number: turnNumber,\n                    is_branch: isBranch,\n                    branch_label: branchLabel,\n                    pageid: pageid,\n                    cmid: cmid,\n                    is_previous_turn: isPreviousTurn,\n                    can_create_branch: false // Branch creation only from sidebar\n                }).then((html) => {\n                    $(this).before(html);\n                }).catch(() => {\n                    // Fallback if template fails.\n                    const separatorHtml = '<div class=\"turn-separator my-4\" data-turn-separator=\"' + currentTurnId + '\">' +\n                        '<div class=\"d-flex align-items-center justify-content-between\">' +\n                        '<hr class=\"flex-grow-1\" style=\"border-color: #6c757d; border-width: 2px;\">' +\n                        '<div class=\"px-3 d-flex align-items-center gap-2\">' +\n                        '<span class=\"badge badge-secondary\">Turn ' + currentTurnId + '</span>' +\n                        '</div>' +\n                        '<hr class=\"flex-grow-1\" style=\"border-color: #6c757d; border-width: 2px;\">' +\n                        '</div></div>';\n                    $(this).before(separatorHtml);\n                });\n            }\n            lastTurnId = currentTurnId;\n        } else if (messageTurnId === null && lastTurnId !== null) {\n            // Message without turn_id after messages with turn_id - insert separator.\n                    Templates.render('mod_harpiasurvey/turn_separator', {\n                        turn_id: '?'\n            }).then((html) => {\n                $(this).before(html);\n            }).catch(() => {\n                // Fallback.\n                const separatorHtml = '<div class=\"turn-separator my-4\">' +\n                    '<div class=\"d-flex align-items-center\">' +\n                    '<hr class=\"flex-grow-1\" style=\"border-color: #6c757d; border-width: 2px;\">' +\n                    '<div class=\"px-3\"><span class=\"badge badge-secondary\">New Messages</span></div>' +\n                    '<hr class=\"flex-grow-1\" style=\"border-color: #6c757d; border-width: 2px;\">' +\n                    '</div></div>';\n                $(this).before(separatorHtml);\n            });\n            lastTurnId = null;\n        }\n    });\n};\n\n/**\n * Get all turn IDs that are part of the history for a given turn (considering branch tree).\n * For a root turn: returns only that turn.\n * For a branch turn: returns all turns from root to parent (inclusive) + the branch turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Array<number>} Array of turn IDs that should be visible\n */\nconst getRelevantTurnIds = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        // Fallback: if no tree, just show this turn.\n        return [turnId];\n    }\n\n    // First, find which root conversation contains this turn.\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        // Turn not found in any conversation, just show this turn.\n        return [turnId];\n    }\n\n    // Now find the node within this specific conversation.\n    const findNodeInConversation = (node, targetId) => {\n        if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n            return node;\n        }\n        // Check direct branches.\n        if (node.direct_branches) {\n            for (const db of node.direct_branches) {\n                if (parseInt(db.turn_id, 10) === parseInt(targetId, 10)) {\n                    return db;\n                }\n                // Check children of direct branch.\n                if (db.children) {\n                    for (const child of db.children) {\n                        const found = findNodeInConversation(child, targetId);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n            }\n        }\n        // Check derived branches (children).\n        if (node.children) {\n            for (const child of node.children) {\n                const found = findNodeInConversation(child, targetId);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n        return null;\n    };\n\n    const node = findNodeInConversation(root, turnId);\n    if (!node) {\n        // Should not happen since we found the root, but fallback.\n        return [turnId];\n    }\n\n    // If it's the root turn, just return this turn.\n    if (node.is_root && parseInt(node.turn_id, 10) === parseInt(root.turn_id, 10)) {\n        return [turnId];\n    }\n\n    // If it's a direct branch, return root + this direct branch.\n    if (node.is_direct_branch) {\n        return [parseInt(root.turn_id, 10), turnId];\n    }\n\n    // If it's a derived branch, we need to get the path from root to parent (inclusive).\n    // Build the path by traversing up to the root within this conversation.\n    const pathToRoot = [];\n    let current = node;\n    const rootTurnId = parseInt(root.turn_id, 10);\n\n    // Traverse up to root within this conversation.\n    while (current && current.parent_turn_id) {\n        const parentTurnId = current.parent_turn_id;\n\n        // Stop if we've reached the root of this conversation.\n        if (parseInt(parentTurnId, 10) === rootTurnId) {\n            // Only include root if it's <= current turn.\n            if (rootTurnId <= turnId && !pathToRoot.includes(rootTurnId)) {\n                pathToRoot.unshift(rootTurnId);\n            }\n            break;\n        }\n\n        // Only include parent if it's <= current turn and belongs to this conversation.\n        // Verify parent belongs to this conversation by finding it in the tree.\n        const parentNode = findNodeInConversation(root, parentTurnId);\n        if (parentNode && parentTurnId <= turnId) {\n            pathToRoot.unshift(parentTurnId);\n        }\n\n        // Move to parent node for next iteration.\n        current = parentNode;\n        if (!current) {\n            // Parent not found in this conversation - stop traversal.\n            break;\n        }\n    }\n\n    // Add root turn if not already included (for direct branches or if traversal didn't reach it).\n    if (!pathToRoot.includes(rootTurnId) && rootTurnId <= turnId) {\n        pathToRoot.unshift(rootTurnId);\n    }\n\n    // Return path from root to parent (inclusive) + this branch turn.\n    // Filter out any turns that are greater than the branch turn.\n    const filteredPath = pathToRoot.filter(tid => tid <= turnId);\n    return [...filteredPath, turnId];\n};\n\n/**\n * Filter messages by turn (show only messages from relevant turns based on branch tree).\n * For branches, automatically shows the full path from root to current branch.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to show\n */\nconst filterMessagesByTurn = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    // First, ensure separators are inserted.\n    insertTurnSeparators(pageid);\n\n    // Get relevant turn IDs for this turn (considering branch tree).\n    // This includes the full path from root to current turn.\n    const relevantTurnIds = getRelevantTurnIds(pageid, turnId);\n    const relevantTurnIdsSet = new Set(relevantTurnIds);\n\n    // Show all messages from relevant turns (full branch path if it's a branch).\n    // Previous turns are collapsed by default.\n    messagesContainer.find('.message').each(function() {\n        const messageTurnId = $(this).data('turn-id');\n        if (messageTurnId) {\n            const msgTurn = parseInt(messageTurnId, 10);\n            // Show if message is from a relevant turn (part of the branch path).\n            if (relevantTurnIdsSet.has(msgTurn)) {\n                // Mark as previous if it's not the current turn.\n                if (msgTurn === turnId) {\n                // Current turn - always show.\n                $(this).show();\n                $(this).removeClass('previous-turn-message');\n            } else {\n                // Previous turn - collapse by default.\n                $(this).addClass('previous-turn-message');\n                $(this).hide();\n            }\n        } else {\n                // Turn not in the branch path - always hide.\n                $(this).hide();\n                $(this).removeClass('previous-turn-message');\n            }\n        } else {\n            // Messages without turn_id (shouldn't happen in turns mode, but show them anyway).\n            $(this).show();\n            $(this).removeClass('previous-turn-message');\n        }\n    });\n\n    // Show/hide turn separators based on visibility and update collapse state.\n    messagesContainer.find('.turn-separator').each(function() {\n        const separatorTurnId = $(this).data('turn-separator');\n        if (separatorTurnId) {\n            const sepTurn = parseInt(separatorTurnId, 10);\n            // Show separator if it's part of the relevant turns.\n            if (relevantTurnIdsSet.has(sepTurn)) {\n                // Set collapsed state for previous turns (default to collapsed).\n                if (sepTurn < turnId) {\n                    // Previous turn - set to collapsed by default if not already set.\n                    if ($(this).data('collapsed') === undefined) {\n                        $(this).data('collapsed', true);\n                    }\n                    // Hide previous turn separators until expanded.\n                    $(this).hide();\n                    // Update toggle button icon.\n                    const toggleBtn = $(this).find('.toggle-turn-btn');\n                    const toggleIcon = toggleBtn.find('.toggle-turn-icon');\n                    if ($(this).data('collapsed') === true) {\n                        toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');\n                    } else {\n                        toggleIcon.removeClass('fa-chevron-down').addClass('fa-chevron-up');\n                    }\n                } else {\n                    // Current turn - always expanded.\n                    $(this).data('collapsed', false);\n                    $(this).show();\n                }\n            } else {\n                $(this).hide();\n            }\n        } else {\n            // Separator without turn_id - hide it.\n            $(this).hide();\n        }\n    });\n\n    // Update toggle button state based on whether there are previous messages.\n    const toggleBtn = $(`.toggle-previous-messages-btn[data-pageid=\"${pageid}\"]`);\n    if (toggleBtn.length > 0) {\n        const hasPreviousMessages = messagesContainer.find('.previous-turn-message').length > 0;\n        if (hasPreviousMessages) {\n            // Show button and update state.\n            toggleBtn.show();\n            // Check if previous messages are currently visible.\n            const firstPrevious = messagesContainer.find('.previous-turn-message').first();\n            const isVisible = firstPrevious.is(':visible');\n            if (isVisible) {\n                toggleBtn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Ocultar anteriores');\n                toggleBtn.attr('title', 'Ocultar conversas anteriores');\n            } else {\n                toggleBtn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Mostrar anteriores');\n                toggleBtn.attr('title', 'Mostrar conversas anteriores');\n            }\n        } else {\n            // No previous messages, hide the button.\n            toggleBtn.hide();\n        }\n    }\n\n    // Scroll to bottom after filtering.\n    setTimeout(() => {\n        scrollToBottom(pageid);\n    }, 50);\n};\n\n/**\n * Filter messages by conversation ID (for continuous mode).\n * Shows only messages that belong to the specified conversation tree (root and all descendants).\n *\n * @param {number} pageid Page ID\n * @param {number} conversationId Root conversation ID\n */\nconst filterMessagesByConversation = (pageid, conversationId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    // Collect all message IDs that belong to this conversation tree.\n    // Start with the root conversation ID, then find all messages with that as parent or ancestor.\n    const conversationMessageIds = new Set();\n    conversationMessageIds.add(conversationId);\n\n    // Build a map of message ID to parent ID for efficient traversal.\n    const messageParentMap = new Map();\n    messagesContainer.find('.message').each(function() {\n        const messageId = parseInt($(this).data('messageid'), 10);\n        const parentId = parseInt($(this).data('parentid'), 10);\n        if (messageId && parentId) {\n            messageParentMap.set(messageId, parentId);\n        }\n    });\n\n    // Find all messages that are descendants of this conversation.\n    // We'll do multiple passes to ensure we catch all descendants.\n    let changed = true;\n    while (changed) {\n        changed = false;\n        for (const [messageId, parentId] of messageParentMap.entries()) {\n            if (!conversationMessageIds.has(messageId) && conversationMessageIds.has(parentId)) {\n                conversationMessageIds.add(messageId);\n                changed = true;\n            }\n        }\n    }\n\n    // Now show/hide messages based on whether they're in the conversation tree.\n    messagesContainer.find('.message').each(function() {\n        const messageId = parseInt($(this).data('messageid'), 10);\n        if (conversationMessageIds.has(messageId)) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    });\n\n    // Scroll to bottom after filtering.\n    setTimeout(() => {\n        scrollToBottom(pageid);\n    }, 50);\n};\n\n/**\n * Navigate to a specific conversation (for continuous mode).\n *\n * @param {number} pageid Page ID\n * @param {number} conversationId Conversation ID to navigate to\n */\nconst navigateToConversation = (pageid, conversationId) => {\n    // Store the current conversation ID.\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    container.data('viewing-conversation', conversationId);\n    container.attr('data-viewing-conversation', conversationId);\n\n    // Filter messages to show only this conversation.\n    filterMessagesByConversation(pageid, conversationId);\n\n    // For continuous mode, keep list view (simpler, no branches).\n    // Reload tree to show current state.\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    if (sidebar.length) {\n        sidebar.data('sidebar-view', 'list'); // Always use list view for continuous mode\n        loadConversationTree(pageid);\n    }\n};\n\n/**\n * Load conversation tree from server and render it.\n *\n * @param {number} pageid Page ID\n * @return {Promise} Promise that resolves when tree is loaded\n */\nconst loadConversationTree = (pageid) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n    if (treeContainer.length === 0) {\n        // eslint-disable-next-line no-console\n        console.warn('Tree container not found for pageid:', pageid);\n        return Promise.resolve(null);\n    }\n\n    // Get cmid from the container.\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    if (!cmid) {\n        // eslint-disable-next-line no-console\n        console.error('cmid not found for pageid:', pageid);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error: Course module ID not found. Please refresh the page.</div>');\n        return Promise.resolve(null);\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'get_conversation_tree');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n\n    return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        // eslint-disable-next-line no-console\n        console.log('Conversation tree response:', data);\n\n        if (data.success && data.tree) {\n            // Annotate roots with sequential conversation numbers for consistent labels.\n            data.tree.roots = (data.tree.roots || []).map((root, idx) => ({\n                ...root,\n                conversation_number: idx + 1\n            }));\n            // Store tree for message filtering.\n            conversationTrees[pageid] = data.tree;\n\n            // Get behavior from container.\n            const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n            const behavior = container.data('behavior') || (data.behavior || 'turns');\n\n            // Determine view mode (list or detail).\n            // For continuous mode, always use list view.\n            // For turns mode, default to 'list' if there are multiple roots or no roots, 'detail' if there's exactly one root.\n            let currentView = sidebar.data('sidebar-view');\n            if (!currentView) {\n                if (behavior === 'continuous') {\n                    // Always use list view for continuous mode.\n                    currentView = 'list';\n                } else {\n                    // Auto-determine: list if multiple roots or no roots, detail if single root.\n                    if (data.tree.roots.length === 1) {\n                        currentView = 'detail';\n                    } else {\n                        currentView = 'list';\n                    }\n                }\n                sidebar.data('sidebar-view', currentView);\n            }\n\n            // For continuous mode, always use list view (simpler, no branches).\n            // For turns mode, use detail view if there's a single root, list view otherwise.\n            if (behavior === 'continuous') {\n                // Always use list view for continuous mode - just switch between conversations.\n                renderConversationList(pageid, data.tree.roots);\n            } else if (currentView === 'list') {\n                renderConversationList(pageid, data.tree.roots);\n            } else {\n                // Detail view - find which root to show (turns mode only).\n                const viewingTurn = getViewingTurn(pageid);\n                const root = findRootForTurn(data.tree.roots, viewingTurn);\n\n                if (root) {\n                    renderConversationDetail(pageid, root);\n                } else if (data.tree.roots.length > 0) {\n                    // Fallback to first root if viewing turn not found (or new/unknown).\n                    renderConversationDetail(pageid, data.tree.roots[0]);\n                } else {\n                    // No roots at all - show empty list.\n                    renderConversationList(pageid, []);\n                }\n\n                // After rendering tree, ensure questions are loaded for the current viewing turn.\n                // This handles cases where setViewingTurn was called directly without navigateToTurn.\n                const currentViewingTurn = getViewingTurn(pageid);\n                if (currentViewingTurn) {\n                    ensureTurnEvaluationQuestionsRendered(pageid, currentViewingTurn).then(() => {\n                        loadTurnEvaluationResponses(pageid, currentViewingTurn);\n                    });\n                }\n            }\n\n            // Update turn labels in existing messages after tree is loaded.\n            updateMessageTurnLabels(pageid);\n\n            return data.tree;\n        } else {\n            // Show message in tree container instead of notification.\n            treeContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                (data.message || 'No conversation tree available yet.') + '</div>');\n            return null;\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading conversation tree:', error);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error loading conversation tree: ' + error.message + '<br>' +\n            'Please check the browser console for details and refresh the page.</div>');\n        return null;\n    });\n};\n\n/**\n * Find the root node that contains the given turn ID.\n *\n * @param {Array} roots Array of root nodes\n * @param {number} turnId Turn ID to find\n * @return {Object|null} Root node or null\n */\nconst findRootForTurn = (roots, turnId) => {\n    const findInNode = (node, targetId) => {\n        if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n            return true;\n        }\n        // Check direct branches (children of root).\n        if (node.direct_branches) {\n            for (const db of node.direct_branches) {\n                if (parseInt(db.turn_id, 10) === parseInt(targetId, 10)) {\n                    return true;\n                }\n                // Check children of direct branch (derived branches).\n                if (db.children) {\n                    for (const child of db.children) {\n                        if (findInNode(child, targetId)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        // Check derived branches (children of non-root turns).\n        if (node.children) {\n            for (const child of node.children) {\n                if (findInNode(child, targetId)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    for (const root of roots) {\n        if (findInNode(root, turnId)) {\n            return root;\n        }\n    }\n    return null;\n};\n\n/**\n * Count nodes in a tree/subtree.\n *\n * @param {Object} node Root node\n * @return {number} Count of nodes\n */\nconst countNodes = (node) => {\n    let count = 1;\n    if (node.direct_branches) {\n        node.direct_branches.forEach(branch => {\n            count += countNodes(branch);\n        });\n    }\n    if (node.children) {\n        node.children.forEach(child => {\n            count += countNodes(child);\n        });\n    }\n    return count;\n};\n\n/**\n * Render conversation list view (roots).\n *\n * @param {number} pageid Page ID\n * @param {Array} roots Array of root nodes\n */\nconst renderConversationList = (pageid, roots) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n\n    // Add node count and sequential label to roots for display, and ensure conversation_id is included.\n    const rootsWithCount = roots.map((root, idx) => ({\n        ...root,\n        conversation_id: root.conversation_id || root.turn_id, // Include conversation_id for continuous mode\n        turn_count: countNodes(root),\n        conversation_number: root.conversation_number || idx + 1\n    }));\n\n    Templates.render('mod_harpiasurvey/conversation_list', {\n        roots: rootsWithCount,\n        pageid: pageid\n    }).then((html) => {\n        treeContainer.html(html);\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error rendering conversation list:', error);\n    });\n};\n\n/**\n * Get the number of turns in the conversation that contains the given turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID (or conversation root ID)\n * @return {number|null} Count of turns or null if unknown\n */\nconst getTurnCountForConversation = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots || !turnId) {\n        return null;\n    }\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n    return countNodes(root);\n};\n\n/**\n * Calculate hierarchical turn number based on tree structure.\n *\n * @param {Object} node Node data\n * @param {number} turnIndex Index of this turn among siblings (0-based)\n * @param {string} parentNumber Parent's display number (null for root/direct branches)\n * @return {string} Display number (e.g., \"1\", \"2\", \"1.1\", \"2.3\")\n */\nconst calculateTurnNumber = (node, turnIndex, parentNumber) => {\n    if (node.is_root || node.is_direct_branch) {\n        // Root turns and direct branches: sequential numbering (1, 2, 3...)\n        return String(turnIndex + 1);\n    } else {\n        // Derived branches: parent.branch_index (1.1, 1.2, 2.1...)\n        const branchIndex = turnIndex + 1;\n        return parentNumber ? `${parentNumber}.${branchIndex}` : String(branchIndex);\n    }\n};\n\n/**\n * Get hierarchical turn number for a given turn ID by searching the tree.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to find\n * @return {string|null} Display number or null if not found\n */\nconst getTurnNumberForId = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return null;\n    }\n\n    // Find which root conversation this turn belongs to.\n    const findRootForTurn = (roots, targetId) => {\n        const findInNode = (node, target) => {\n            if (parseInt(node.turn_id, 10) === parseInt(target, 10)) {\n                return true;\n            }\n            if (node.direct_branches) {\n                for (const db of node.direct_branches) {\n                    if (parseInt(db.turn_id, 10) === parseInt(target, 10)) {\n                        return true;\n                    }\n                    if (db.children) {\n                        for (const child of db.children) {\n                            if (findInNode(child, target)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n            if (node.children) {\n                for (const child of node.children) {\n                    if (findInNode(child, target)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n\n        for (const root of roots) {\n            if (findInNode(root, targetId)) {\n                return root;\n            }\n        }\n        return null;\n    };\n\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n\n    // Now calculate the number within this conversation.\n    // Root is 1, direct branches are 2, 3, 4..., derived branches are parent.branch_index.\n    const findAndNumber = (node, targetId, parentNumber, turnIndex) => {\n        const nodeNumber = calculateTurnNumber(node, turnIndex, parentNumber);\n\n        if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n            return nodeNumber;\n        }\n\n        // Check direct branches if this is a root.\n        if (node.direct_branches && node.direct_branches.length > 0) {\n            // Sort direct branches by turn_id for consistent ordering.\n            const sortedDB = [...node.direct_branches].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            let dbCounter = turnIndex + 1; // Continue sequential numbering\n            for (const db of sortedDB) {\n                const dbNumber = calculateTurnNumber(db, dbCounter, null);\n                if (parseInt(db.turn_id, 10) === parseInt(targetId, 10)) {\n                    return dbNumber;\n                }\n                // Check children of direct branch (derived branches).\n                if (db.children && db.children.length > 0) {\n                    const sortedChildren = [...db.children].sort((a, b) =>\n                        parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n                    );\n                    for (let i = 0; i < sortedChildren.length; i++) {\n                        const found = findAndNumber(sortedChildren[i], targetId, dbNumber, i);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n                dbCounter++;\n            }\n        }\n\n        // Check children (derived branches).\n        if (node.children && node.children.length > 0) {\n            const sortedChildren = [...node.children].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            for (let i = 0; i < sortedChildren.length; i++) {\n                const found = findAndNumber(sortedChildren[i], targetId, nodeNumber, i);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    // Start from root (turnIndex 0 = turn number 1).\n    return findAndNumber(root, turnId, null, 0);\n};\n\n/**\n * Prepare node data for recursive rendering.\n *\n * @param {Object} node Node data\n * @param {number} level Current level\n * @param {number} currentTurnId Current viewing turn ID\n * @param {number} pageid Page ID\n * @param {number} cmid Course Module ID\n * @param {number} turnIndex Index among siblings (0-based)\n * @param {string} parentNumber Parent's display number (null for root/direct branches)\n * @param {string} behavior Behavior mode (turns or continuous)\n * @return {Object} Prepared node data\n */\nconst prepareNodeData = (node, level, currentTurnId, pageid, cmid, turnIndex = 0, parentNumber = null, behavior = 'turns') => {\n    const isCurrent = parseInt(node.turn_id, 10) === parseInt(currentTurnId, 10);\n    const hasChildren = node.children && node.children.length > 0;\n    const isDirectBranch = node.is_direct_branch || false;\n    const turnNumber = calculateTurnNumber(node, turnIndex, parentNumber);\n\n    return {\n        turn_id: node.turn_id,\n        conversation_id: node.conversation_id || node.turn_id, // Use conversation_id if available, fallback to turn_id\n        turn_number: turnNumber,\n        is_root: node.is_root || false,\n        is_direct_branch: isDirectBranch,\n        is_current: isCurrent,\n        has_children: hasChildren,\n        branch_label: node.branch_label || null,\n        level: level,\n        expanded: true,\n        pageid: pageid,\n        cmid: cmid,\n        can_create_branch: (behavior === 'turns'), // Only allow branch creation in turns mode\n        children: hasChildren ? node.children.map((child, index) =>\n            // Keep descendants at the same visual level as their branch root; only the bifurcation is indented.\n            prepareNodeData(child, isDirectBranch ? level : level + 1, currentTurnId, pageid, cmid, index, turnNumber, behavior)) : []\n    };\n};\n\n/**\n * Render conversation detail view (single root tree).\n *\n * @param {number} pageid Page ID\n * @param {Object} root Root node\n */\nconst renderConversationDetail = (pageid, root) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n\n    // Get cmid and behavior from container.\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    const behavior = container.data('behavior') || 'turns';\n\n    // For continuous mode, use a simpler view - just show the conversation without branches.\n    if (behavior === 'continuous') {\n        const viewingConv = container.data('viewing-conversation') || root.conversation_id || root.turn_id;\n        const isCurrent = parseInt(root.conversation_id || root.turn_id, 10) === parseInt(viewingConv, 10);\n\n        // Simple node data for continuous mode (no branches, no turn numbers).\n        const rootNodeData = {\n            turn_id: root.turn_id,\n            conversation_id: root.conversation_id || root.turn_id,\n            turn_number: null, // No turn numbers in continuous mode\n            is_root: true,\n            is_direct_branch: false,\n            is_current: isCurrent,\n            has_children: false, // No branches in continuous mode\n            branch_label: null,\n            level: 0,\n            expanded: true,\n            pageid: pageid,\n            cmid: cmid,\n            can_create_branch: false // No branches in continuous mode\n        };\n\n        Templates.render('mod_harpiasurvey/conversation_detail', {\n            root_node: rootNodeData,\n            root_turn_id: root.turn_id,\n            direct_branches: [], // No branches in continuous mode\n            pageid: pageid,\n            cmid: cmid,\n            conversation_number: root.conversation_number || 1\n        }).then((html) => {\n            treeContainer.html(html);\n        }).catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error('Error rendering conversation detail:', error);\n        });\n        return;\n    }\n\n    // For turns mode, use the full branch structure.\n    const viewingTurn = getViewingTurn(pageid);\n\n    // Calculate turn numbers: root is 1, then direct branches are 2, 3, 4...\n    // All turns at root level (root + direct branches) are numbered sequentially.\n    let turnCounter = 0; // Will be incremented to 1 for root, 2 for first direct branch, etc.\n    const rootNodeData = prepareNodeData(root, 0, viewingTurn, pageid, cmid, turnCounter, null, behavior);\n    turnCounter++;\n\n    // Find direct branches of this root (branches where parent is this root).\n    // Direct branches are stored in the root's direct_branches array.\n    const directBranches = [];\n    if (root.direct_branches && root.direct_branches.length > 0) {\n        // Sort direct branches by turn_id to ensure consistent ordering.\n        const sortedDirectBranches = [...root.direct_branches].sort((a, b) =>\n            parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n        );\n        sortedDirectBranches.forEach((node) => {\n            // Direct branches continue sequential numbering: 2, 3, 4...\n            // Level 1 so they render visually indented under the root they forked from.\n            directBranches.push(prepareNodeData(node, 1, viewingTurn, pageid, cmid, turnCounter, null, behavior));\n            turnCounter++;\n        });\n    }\n\n    Templates.render('mod_harpiasurvey/conversation_detail', {\n        root_node: rootNodeData,\n        root_turn_id: root.turn_id,\n        direct_branches: directBranches,\n        pageid: pageid,\n        cmid: cmid,\n        conversation_number: root.conversation_number || 1\n    }).then((html) => {\n        treeContainer.html(html);\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error rendering conversation detail:', error);\n    });\n};\n\n/**\n * Render conversation tree (legacy/wrapper for compatibility).\n *\n * @param {number} pageid Page ID\n * @param {Object} tree Tree structure\n * @param {number} currentTurnId Current turn ID\n */\n// eslint-disable-next-line no-unused-vars\nconst renderTree = (pageid, tree, currentTurnId) => {\n    // This function is kept for compatibility but delegates to renderConversationDetail or List.\n    // In the new flow, loadConversationTree handles the decision.\n    // If called directly, we assume detail view for the root containing currentTurnId.\n\n    const root = findRootForTurn(tree.roots, currentTurnId);\n    if (root) {\n        renderConversationDetail(pageid, root);\n    } else {\n        renderConversationList(pageid, tree.roots);\n    }\n};\n\n// Removed renderNodeHTML - all rendering now uses Mustache templates.\n\n/**\n * Create a branch from a specific turn.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {number} parentTurnId Parent turn ID\n */\nconst createBranchFromTurn = (cmid, pageid, parentTurnId, buttonEl = null) => {\n    const btn = buttonEl ? $(buttonEl) : null;\n    let originalHtml = null;\n    if (btn && btn.length) {\n        originalHtml = btn.html();\n        btn.prop('disabled', true).addClass('branch-btn-loading');\n        btn.html('<i class=\"fa fa-spinner fa-spin fa-xs\" aria-hidden=\"true\"></i>');\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_branch');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('parent_turn_id', parentTurnId);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        if (data.success) {\n            // Navigate to the new turn and set it as current (this will unlock the chat).\n            navigateToTurn(pageid, data.new_turn_id, true);\n\n            // Optimistically update local tree for immediate visual feedback.\n            addLocalBranchNode(pageid, parentTurnId, data.new_turn_id);\n\n            // Reload conversation tree to show the new branch.\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            sidebar.data('sidebar-view', 'detail'); // Ensure we're in detail view.\n            loadConversationTree(pageid);\n\n            getString('branchcreated', 'mod_harpiasurvey')\n                .then((msg) => {\n                    Notification.addNotification({\n                        message: msg,\n                        type: 'success'\n                    });\n                })\n                .catch(() => {\n                    Notification.addNotification({\n                        message: 'Branch created successfully',\n                        type: 'success'\n                    });\n                });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create turn',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error creating turn:', error);\n        Notification.addNotification({\n            message: 'Error creating turn: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\n/**\n * Add a branch node locally so the tree shows immediate indentation before reload.\n *\n * @param {number} pageid Page ID\n * @param {number} parentTurnId Parent turn ID\n * @param {number} newTurnId New turn ID\n */\nconst addLocalBranchNode = (pageid, parentTurnId, newTurnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return;\n    }\n    const root = findRootForTurn(tree.roots, parentTurnId);\n    if (!root) {\n        return;\n    }\n\n    const newNode = {\n        turn_id: newTurnId,\n        is_root: false,\n        is_direct_branch: false,\n        parent_turn_id: parentTurnId,\n        branch_label: String(newTurnId),\n        children: [],\n        timecreated: Math.floor(Date.now() / 1000),\n        timecreated_str: new Date().toLocaleString()\n    };\n\n    const attach = (node) => {\n        if (parseInt(node.turn_id, 10) === parseInt(parentTurnId, 10)) {\n            if (node.is_root || node.is_direct_branch) {\n                newNode.is_direct_branch = true;\n                if (!node.direct_branches) {\n                    node.direct_branches = [];\n                }\n                node.direct_branches.push(newNode);\n            } else {\n                if (!node.children) {\n                    node.children = [];\n                }\n                node.children.push(newNode);\n            }\n            return true;\n        }\n        if (node.direct_branches) {\n            for (const db of node.direct_branches) {\n                if (attach(db)) {\n                    return true;\n                }\n            }\n        }\n        if (node.children) {\n            for (const child of node.children) {\n                if (attach(child)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    attach(root);\n    renderConversationDetail(pageid, root);\n};\n\n/**\n * Create a new root conversation.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n */\nconst createNewRoot = (cmid, pageid) => {\n    const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n    const behavior = container.data('behavior') || 'turns';\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_root');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (data.success) {\n            // Turns mode: keep turn state and evaluation containers.\n            if (behavior === 'turns') {\n                currentTurns[pageid] = data.new_turn_id;\n                setViewingTurn(pageid, data.new_turn_id);\n                updateTurnDisplay(pageid);\n                updateChatLockState(pageid);\n                messagesContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                    'New conversation started. Send a message to begin.</div>');\n                $(`#turn-evaluation-questions-container-${pageid}`).empty();\n\n                const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n                sidebar.data('sidebar-view', 'detail');\n                setTimeout(() => {\n                    loadConversationTree(pageid).then((tree) => {\n                        if (tree && tree.roots) {\n                            const newRoot = tree.roots.find(r =>\n                                parseInt(r.turn_id, 10) === parseInt(data.new_turn_id, 10)\n                            );\n                            if (newRoot) {\n                                renderConversationDetail(pageid, newRoot);\n                            }\n                        }\n                    });\n                }, 100);\n            } else {\n                // Continuous mode: set the new conversation as the active one and show placeholder.\n                const newConversationId = parseInt(data.new_conversation_id || data.new_turn_id, 10);\n                container.data('viewing-conversation', newConversationId);\n                container.attr('data-viewing-conversation', newConversationId);\n                messagesContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                    'New conversation started. Send a message to begin.</div>');\n                const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n                sidebar.data('sidebar-view', 'list');\n                setTimeout(() => {\n                    loadConversationTree(pageid).then((tree) => {\n                        if (tree && tree.roots) {\n                            const root = tree.roots.find(r =>\n                                parseInt((r.conversation_id || r.turn_id), 10) === newConversationId\n                            );\n                            if (root) {\n                                navigateToConversation(pageid, root.conversation_id || root.turn_id);\n                                return;\n                            }\n                        }\n                        // Fallback: if not in tree yet, add a placeholder root locally and render list.\n                        const treeData = conversationTrees[pageid] || {roots: []};\n                        const nextNumber = (treeData.roots?.length || 0) + 1;\n                        const newRoot = {\n                            turn_id: newConversationId,\n                            conversation_id: newConversationId,\n                            is_root: true,\n                            children: [],\n                            parent_turn_id: null,\n                            branch_label: null,\n                            timecreated: Math.floor(Date.now() / 1000),\n                            timecreated_str: new Date().toLocaleString(),\n                            message_count: 1,\n                            conversation_number: nextNumber\n                        };\n                        treeData.roots = [...(treeData.roots || []), newRoot];\n                        conversationTrees[pageid] = treeData;\n                        renderConversationList(pageid, treeData.roots);\n                        navigateToConversation(pageid, newConversationId);\n                    });\n                }, 100);\n            }\n\n            Notification.addNotification({\n                message: data.message || 'New conversation created successfully',\n                type: 'success'\n            });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create new root',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error creating new root:', error);\n        Notification.addNotification({\n            message: 'Error creating new root: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\n/**\n * Navigate to a specific turn in the conversation.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to navigate to\n * @param {boolean} setAsCurrent Whether to set this turn as the current turn (for new branches)\n */\nconst navigateToTurn = (pageid, turnId, setAsCurrent = false) => {\n    // If this is a new turn (like a branch), set it as current FIRST so chat is unlocked.\n    if (setAsCurrent) {\n        currentTurns[pageid] = turnId;\n    }\n    // Then set viewing turn.\n    setViewingTurn(pageid, turnId);\n    // Update display and lock state.\n    updateTurnDisplay(pageid);\n    updateChatLockState(pageid);\n\n    // Collapse all previous turns before filtering.\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.turn-separator').each(function() {\n        const separatorTurnId = $(this).data('turn-separator');\n        if (separatorTurnId) {\n            const sepTurn = parseInt(separatorTurnId, 10);\n            if (sepTurn < turnId) {\n                // Previous turn - set to collapsed.\n                $(this).data('collapsed', true);\n                // Update toggle button icon.\n                const toggleBtn = $(this).find('.toggle-turn-btn');\n                const toggleIcon = toggleBtn.find('.toggle-turn-icon');\n                if (toggleIcon.length > 0) {\n                    toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');\n                }\n            }\n        }\n    });\n\n    filterMessagesByTurn(pageid, turnId);\n    // Update subpage visibility.\n    updateSubpageVisibility(pageid);\n\n    // Render questions and load saved responses for this turn.\n    ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n        loadTurnEvaluationResponses(pageid, turnId);\n    });\n\n    // Ensure sidebar is in detail view and reload tree to show current state.\n    // Find the correct root conversation for this turn and switch to its detail view.\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    if (sidebar.length) {\n        sidebar.data('sidebar-view', 'detail');\n        loadConversationTree(pageid).then((tree) => {\n            if (tree && tree.roots) {\n                // Find the root that contains this turn.\n                const root = findRootForTurn(tree.roots, turnId);\n                if (root) {\n                    // Explicitly render the detail view for the correct conversation.\n                    renderConversationDetail(pageid, root);\n                    // After rendering, ensure questions are loaded (in case navigateToTurn wasn't called).\n                    ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n                        loadTurnEvaluationResponses(pageid, turnId);\n                    });\n                }\n            }\n        });\n    }\n\n    // Reload tree to update current indicator - use a small delay to ensure state is updated.\n    setTimeout(() => {\n        loadConversationTree(pageid);\n    }, 100);\n};\n\n/**\n * Initialize multi-model chat interface.\n *\n * @param {number} pageid Page ID\n * @param {number} cmid Course module ID\n */\nconst initMultiModelChat = (pageid, cmid) => {\n    // eslint-disable-next-line no-console\n    console.log('Initializing multi-model chat for page ' + pageid);\n\n    const container = $(`.multi-model-chat-container[data-pageid=\"${pageid}\"]`);\n    if (container.length === 0) {\n        return;\n    }\n\n    const input = $(`#chat-input-${pageid}`);\n    const sendButton = $(`#send-message-btn-${pageid}`);\n\n    // Get all model IDs from tabs.\n    const modelIds = [];\n    container.find('[data-model-id]').each(function() {\n        const modelId = parseInt($(this).data('model-id'), 10);\n        if (modelId && !modelIds.includes(modelId)) {\n            modelIds.push(modelId);\n        }\n    });\n\n    // eslint-disable-next-line no-console\n    console.log('Found ' + modelIds.length + ' models for multi-model chat');\n\n    // Handle send button click.\n    sendButton.on('click', function(e) {\n        e.preventDefault();\n\n        const message = input.val().trim();\n        if (!message) {\n            return;\n        }\n\n        if (modelIds.length === 0) {\n            Notification.addNotification({\n                message: 'No models available',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Disable input and button.\n        input.prop('disabled', true);\n        sendButton.prop('disabled', true);\n\n        // Clear input.\n        input.val('');\n\n        // Display user message in all model tabs.\n        const tempId = 'temp-user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n        modelIds.forEach(modelId => {\n            displayUserMessageMultiModel(pageid, message, tempId, modelId);\n        });\n\n        // Send message to all models simultaneously.\n        sendMessageToAllModels(cmid, pageid, message, modelIds, sendButton, input);\n    });\n\n    // Handle Enter key in textarea.\n    input.on('keydown', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            sendButton.click();\n        }\n    });\n};\n\n/**\n * Display user message in multi-model chat.\n *\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {string} messageid Message ID\n * @param {number} modelId Model ID\n */\nconst displayUserMessageMultiModel = (pageid, message, messageid, modelId) => {\n    const messagesContainer = $(`#chat-messages-model-${modelId}-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n\n    // Remove \"no messages\" placeholder if present.\n    messagesContainer.find('.text-center.text-muted').remove();\n\n    Templates.render('mod_harpiasurvey/chat_user_message', {\n        id: messageid,\n        content: message,\n        timecreated: Math.floor(Date.now() / 1000)\n    }).then((html) => {\n        messagesContainer.append(html);\n        messagesContainer.scrollTop(messagesContainer[0].scrollHeight);\n        return html;\n    }).catch(Notification.exception);\n};\n\n/**\n * Display AI message in multi-model chat.\n *\n * @param {number} pageid Page ID\n * @param {string} content Message content\n * @param {string} messageid Message ID\n * @param {number} modelId Model ID\n */\nconst displayAIMessageMultiModel = (pageid, content, messageid, modelId) => {\n    const messagesContainer = $(`#chat-messages-model-${modelId}-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n\n    Templates.render('mod_harpiasurvey/chat_ai_message', {\n        id: messageid,\n        content: content,\n        timecreated: Math.floor(Date.now() / 1000)\n    }).then((html) => {\n        messagesContainer.append(html);\n        messagesContainer.scrollTop(messagesContainer[0].scrollHeight);\n        return html;\n    }).catch(Notification.exception);\n};\n\n/**\n * Send message to all models simultaneously.\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {Array<number>} modelIds Array of model IDs\n * @param {jQuery} button Send button element\n * @param {jQuery} input Input textarea element\n */\nconst sendMessageToAllModels = (cmid, pageid, message, modelIds, button, input) => {\n    const wwwroot = Config.wwwroot;\n    const sesskey = Config.sesskey || M.cfg.sesskey;\n    const ajaxUrl = wwwroot + '/mod/harpiasurvey/ajax.php';\n\n    // Show loading indicators for each model.\n    modelIds.forEach(modelId => {\n        const messagesContainer = $(`#chat-messages-model-${modelId}-${pageid}`);\n        const loading = $('<div class=\"text-center py-2\"><i class=\"fa fa-spinner fa-spin\"></i> Thinking...</div>');\n        loading.attr('id', `chat-loading-model-${modelId}-${pageid}`);\n        messagesContainer.append(loading);\n        messagesContainer.scrollTop(messagesContainer[0].scrollHeight);\n    });\n\n    // Send to all models in parallel.\n    const promises = modelIds.map(modelId => {\n        const params = new URLSearchParams({\n            action: 'send_ai_message',\n            cmid: cmid,\n            pageid: pageid,\n            message: message,\n            modelid: modelId,\n            sesskey: sesskey\n        });\n\n        return fetch(ajaxUrl + '?' + params.toString())\n            .then((response) => response.json())\n            .then((response) => {\n                // Remove loading indicator for this model.\n                $(`#chat-loading-model-${modelId}-${pageid}`).remove();\n\n                if (response.success) {\n                    // Display AI response in the correct model tab.\n                    displayAIMessageMultiModel(pageid, response.content, response.messageid, modelId);\n                } else {\n                    Notification.addNotification({\n                        message: `Error from ${getModelName(pageid, modelId)}: ${response.message || 'Unknown error'}`,\n                        type: 'error'\n                    });\n                }\n            })\n            .catch((error) => {\n                // Remove loading indicator for this model.\n                $(`#chat-loading-model-${modelId}-${pageid}`).remove();\n                Notification.exception(error);\n            });\n    });\n\n    // Re-enable input and button after all requests complete.\n    Promise.all(promises).finally(() => {\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    });\n};\n\n/**\n * Get model name for a given model ID.\n *\n * @param {number} pageid Page ID\n * @param {number} modelId Model ID\n * @returns {string} Model name\n */\nconst getModelName = (pageid, modelId) => {\n    const tab = $(`#model-tab-${modelId}-${pageid}`);\n    if (tab.length > 0) {\n        return tab.text().trim();\n    }\n    return `Model ${modelId}`;\n};\n"],"names":["initializedTurns","initializedContinuous","commonHandlersRegistered","turnHandlersRegistered","treeHandlersRegistered","currentTurns","conversationTrees","initialize","options","enableTurns","enableContinuous","needsTurns","needsContinuous","containers","length","each","pageid","parseInt","this","data","cmid","initMultiModelChat","messagesContainer","maxTurn","find","turnId","calculatedCurrentTurn","urlTurn","URLSearchParams","window","location","search","get","initialViewingTurn","parsedTurn","isNaN","setViewingTurn","updateTurnDisplay","updateChatLockState","filterMessagesByTurn","updateSubpageVisibility","setTimeout","ensureTurnEvaluationQuestionsRendered","then","loadTurnEvaluationResponses","catch","error","console","sidebar","show","addClass","loadConversationTree","container","allMessages","lastMessage","last","lastMessageId","rootId","currentId","found","parentMap","Map","msgId","parentId","set","attr","filterMessagesByConversation","registerCommonHandlers","registerTreeHandlers","registerTurnHandlers","document","on","e","preventDefault","button","addNotification","message","type","input","inputValue","val","trim","closest","viewingTurn","getViewingTurn","currentTurn","getCurrentTurn","viewingTurnNum","maxTurns","maxTurnsNum","turnCount","getTurnCountForConversation","isTurnComplete","str","modelsdata","modelid","modelids","split","prop","tempId","Date","now","Math","random","toString","substr","displayUserMessage","loading","sendMessage","key","shiftKey","click","node","conversationId","replace","behavior","navigateToConversation","navigateToTurn","item","rootTurnId","tree","renderConversationList","roots","stopPropagation","icon","childrenContainer","is","hide","removeClass","log","evaluationContainer","responses","questionId","questionType","responseValue","checked","values","push","JSON","stringify","selectSelector","inputSelector","selected","textarea","originalText","text","saveTurnEvaluationQuestions","nextTurn","clearTurnEvaluationForm","focus","children","parentTurnId","createBranchFromTurn","createNewRoot","prevTurn","separator","isCollapsed","messageTurnId","toggleIcon","previousMessages","first","separatorTurnId","html","relevantTurnIds","getRelevantTurnIds","sepTurn","includes","messageid","placeholder","remove","recentMessages","slice","isDuplicate","contentEl","msgContent","safeMessage","templateData","content","id","turn_id","turnNumber","getTurnNumberForId","turn_label","render","appendNodeContents","insertTurnSeparators","scrollToBottom","messageHtml","append","parentid","viewingConversation","visibleMessages","params","action","sesskey","Config","fetch","wwwroot","method","headers","response","ok","Error","status","json","success","root_conversation_id","Promise","resolve","Templates","requestAnimationFrame","displayAIMessage","scrollTop","scrollHeight","containerWrapper","existingContainer","loadTurnEvaluationQuestions","questionsDataEl","questionsForTurn","parse","filter","q","minturn","min_turn","show_only_turn","undefined","showOnlyTurnNum","turnIdNum","hide_on_turn","hideOnTurnNum","containerHtml","questionsCount","questions","has_questions","reject","savePromises","Object","keys","map","questionid","url","all","results","every","r","floor","forEach","showTurnEvaluationTimestamp","responseData","timestamp","timemodified","Array","isArray","selector","hideTurnEvaluationTimestamp","questionItem","toLocaleString","turnHasMessages","messageCount","userCount","aiCount","role","turn","warn","previousTurn","turnNum","URL","href","searchParams","history","replaceState","updateTurnInUrl","turnLabel","prevBtn","nextBtn","subpagesContainer","$subpage","visibilityType","shouldShow","slideDown","updateSubpageQuestionVisibility","slideUp","$question","currentTurnNum","sendBtn","lockMessage","conversationTurnCount","hasReachedTurnLimit","directBranchContainer","updateMessageTurnLabels","$msg","$badge","$firstBadge","lastTurnId","relevantTurnIdsSet","Set","currentTurnId","has","branchInfo","findNode","nodes","targetId","is_branch","is_root","branch_label","getBranchInfo","isBranch","branchLabel","isPreviousTurn","turn_number","is_previous_turn","can_create_branch","before","separatorHtml","root","findRootForTurn","findNodeInConversation","direct_branches","db","child","is_direct_branch","pathToRoot","current","parent_turn_id","unshift","parentNode","tid","msgTurn","toggleBtn","conversationMessageIds","add","messageParentMap","messageId","changed","entries","treeContainer","body","idx","conversation_number","currentView","renderConversationDetail","currentViewingTurn","findInNode","countNodes","count","branch","rootsWithCount","conversation_id","turn_count","calculateTurnNumber","turnIndex","parentNumber","String","branchIndex","target","findAndNumber","nodeNumber","sortedDB","sort","a","b","dbCounter","dbNumber","sortedChildren","i","prepareNodeData","level","isCurrent","hasChildren","isDirectBranch","is_current","has_children","expanded","index","viewingConv","rootNodeData","root_node","root_turn_id","turnCounter","directBranches","buttonEl","btn","originalHtml","new_turn_id","addLocalBranchNode","msg","newTurnId","newNode","timecreated","timecreated_str","attach","empty","newRoot","newConversationId","new_conversation_id","treeData","nextNumber","message_count","setAsCurrent","sendButton","modelIds","modelId","displayUserMessageMultiModel","sendMessageToAllModels","Notification","exception","M","cfg","ajaxUrl","promises","displayAIMessageMultiModel","getModelName","finally","tab"],"mappings":"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"}