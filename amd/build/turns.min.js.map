{"version":3,"file":"turns.min.js","sources":["../src/turns.js"],"sourcesContent":["// Turns-only logic for harpiasurvey chat interface.\n//\n// Extracted from the previous monolithic core_chat.js. Handles turn navigation,\n// branching, locking, tree rendering, and send pipeline for turns behavior.\n\nimport {\n    Templates,\n    Notification,\n    Config,\n    getString,\n    $,\n    currentTurns,\n    conversationTrees,\n    scrollToBottom,\n    addError,\n    getCmid,\n    findRootForTurn,\n    countNodes,\n    calculateTurnNumber,\n    renderConversationList\n} from './common_chat';\n\nlet initializedTurns = false;\nlet commonHandlersRegistered = false;\nlet turnHandlersRegistered = false;\nlet treeHandlersRegistered = false;\nlet editLabel = 'Edit';\n\nconst lockQuestionItem = (questionItem) => {\n    questionItem.attr('data-response-locked', '1');\n    questionItem.removeAttr('data-response-editing');\n    questionItem.find('input, select, textarea').prop('disabled', true);\n};\n\nconst ensureEditButton = (questionItem) => {\n    let controls = questionItem.find('.question-edit-controls');\n    if (controls.length === 0) {\n        controls = $('<div class=\"mt-2 question-edit-controls\"></div>');\n        questionItem.append(controls);\n    }\n    let button = controls.find('.question-edit-btn');\n    if (button.length === 0) {\n        button = $('<button type=\"button\" class=\"btn btn-sm btn-outline-secondary question-edit-btn\"></button>');\n        controls.append(button);\n    }\n    button.text(editLabel);\n    button.show();\n};\n\nconst resetQuestionItemToNeutral = (questionItem) => {\n    if (!questionItem || questionItem.length === 0) {\n        return;\n    }\n\n    questionItem.removeAttr('data-response-locked');\n    questionItem.removeAttr('data-response-editing');\n    questionItem.find('.saved-response-message').remove();\n    questionItem.find('.answer-history').remove();\n    questionItem.find('.question-edit-controls').remove();\n\n    questionItem.find('input, select, textarea').prop('disabled', false);\n\n    questionItem.find('input[type=\"radio\"], input[type=\"checkbox\"]').each(function() {\n        $(this).prop('checked', Boolean(this.defaultChecked));\n    });\n\n    questionItem.find('select').each(function() {\n        const select = $(this);\n        const defaultOption = select.find('option').filter(function() {\n            return this.defaultSelected;\n        }).first();\n        if (defaultOption.length > 0) {\n            select.val(defaultOption.val());\n        } else {\n            select.prop('selectedIndex', 0);\n        }\n    });\n\n    questionItem.find('input[type=\"number\"], input[type=\"text\"], textarea').each(function() {\n        $(this).val(this.defaultValue || '');\n    });\n};\n\n/**\n * Initialize turns-mode chat for all containers on the page.\n */\nconst initialize = () => {\n    if (initializedTurns) {\n        return;\n    }\n\n    getString('edit', 'moodle').then((str) => {\n        editLabel = str;\n    }).catch(() => {\n        editLabel = 'Edit';\n    });\n\n    const containers = $('.ai-conversation-container[data-behavior=\"turns\"]');\n    if (containers.length === 0) {\n        return;\n    }\n\n    containers.each(function() {\n        const pageid = parseInt($(this).data('pageid'), 10);\n\n        if (!pageid) {\n            return;\n        }\n\n        const messagesContainer = $(`#chat-messages-page-${pageid}`);\n        let maxTurn = 0;\n        messagesContainer.find('[data-turn-id]').each(function() {\n            const turnId = parseInt($(this).data('turn-id'), 10);\n            if (turnId && turnId > maxTurn) {\n                maxTurn = turnId;\n            }\n        });\n        const calculatedCurrentTurn = maxTurn > 0 ? maxTurn : 1;\n        if (!currentTurns[pageid]) {\n            currentTurns[pageid] = calculatedCurrentTurn;\n        }\n\n        const urlParams = new URLSearchParams(window.location.search);\n        const urlTurn = urlParams.get('turn');\n        const urlBranch = urlParams.get('branch');\n\n        let initialViewingTurn = currentTurns[pageid];\n        if (urlTurn !== null && urlTurn !== '') {\n            const parsedTurn = parseInt(urlTurn, 10);\n            if (!isNaN(parsedTurn) && parsedTurn > 0) {\n                initialViewingTurn = parsedTurn;\n            }\n        }\n\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        if (sidebar.length > 0 && urlBranch !== null && urlBranch !== '') {\n            const parsedBranchRoot = parseInt(urlBranch, 10);\n            if (!isNaN(parsedBranchRoot) && parsedBranchRoot > 0) {\n                sidebar.data('sidebar-view', 'detail');\n                sidebar.data('branch-root', parsedBranchRoot);\n            }\n        }\n\n        setViewingTurn(pageid, initialViewingTurn);\n        updateTurnDisplay(pageid);\n        updateChatLockState(pageid);\n        \n        // Load conversation tree first, then filter messages (tree is needed to determine pathway).\n        if (sidebar.length > 0) {\n            sidebar.show();\n            $(`.toggle-tree-btn[data-pageid=\"${pageid}\"]`).addClass('active');\n            // Load tree first, then filter messages once tree is loaded.\n            loadConversationTree(pageid).then(() => {\n                // Tree loaded - now filter messages based on the pathway.\n                filterMessagesByTurn(pageid, initialViewingTurn);\n            }).catch(() => {\n                // If tree loading fails, still filter with just the current turn.\n                filterMessagesByTurn(pageid, initialViewingTurn);\n            });\n        } else {\n            // No sidebar - filter immediately (will only show current turn if tree not available).\n            filterMessagesByTurn(pageid, initialViewingTurn);\n        }\n        \n        updateSubpageVisibility(pageid);\n        setTimeout(() => {\n            ensureTurnEvaluationQuestionsRendered(pageid, initialViewingTurn).then(() => {\n                loadTurnEvaluationResponses(pageid, initialViewingTurn);\n            }).catch((error) => {\n                // eslint-disable-next-line no-console\n                console.error('Error loading turn evaluation questions on init:', error);\n            });\n        }, 100);\n    });\n\n    registerCommonHandlers();\n    registerTreeHandlers();\n    registerTurnHandlers();\n    initializedTurns = true;\n};\n\nexport const init = () => initialize();\nexport const initTurns = () => initialize();\n\n/**\n * Register common chat handlers (send/enter).\n */\nfunction registerCommonHandlers() {\n    if (commonHandlersRegistered) {\n        return;\n    }\n\n    // Handle send button clicks.\n    $(document).on('click', '.chat-send-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const container = button.closest('.ai-conversation-container');\n        if (container.data('behavior') !== 'turns') {\n            return;\n        }\n\n        if (!cmid || !pageid) {\n            Notification.addNotification({\n                message: 'Missing cmid or pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const input = $(`#chat-input-page-${pageid}`);\n        if (input.length === 0) {\n            Notification.addNotification({\n                message: 'Chat input not found',\n                type: 'error'\n            });\n            return;\n        }\n\n        const inputValue = input.val();\n        if (!inputValue) {\n            return;\n        }\n\n        const message = inputValue.trim();\n\n        if (!message) {\n            return;\n        }\n\n        // Check if chat is locked (viewing a past turn).\n        const viewingTurn = getViewingTurn(pageid);\n        const currentTurn = getCurrentTurn(pageid);\n        // Ensure both are numbers for comparison.\n        const viewingTurnNum = parseInt(viewingTurn, 10);\n        const currentTurnNum = parseInt(currentTurn, 10);\n\n        // Allow sending if viewing turn >= current turn.\n        // If viewing turn > current turn, backend will create the next turn.\n        // Only block if viewing a past turn (viewingTurn < currentTurn).\n        if (viewingTurnNum < currentTurnNum) {\n            // Viewing a past turn - block it.\n            Notification.addNotification({\n                message: 'Cannot send messages in a locked turn. ' +\n                    'Navigate to the current turn first.',\n                type: 'error'\n            });\n            return;\n        }\n        // If viewingTurn >= currentTurn, allow it - backend will handle creating the right turn.\n\n        // Check max turns limit.\n        const maxTurns = container.data('max-turns');\n        if (maxTurns !== undefined && maxTurns !== null) {\n            const maxTurnsNum = parseInt(maxTurns, 10);\n            const turnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n            // Only block when the active conversation already reached the limit and the turn is complete\n            // (sending would create a new turn).\n            if (turnCount !== null && turnCount >= maxTurnsNum &&\n                isTurnComplete(pageid, viewingTurnNum)) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    Notification.addNotification({\n                        message: str,\n                        type: 'error'\n                    });\n                });\n                return;\n            }\n        }\n\n        // Get model from container data attribute (first available model).\n        const modelsdata = container.data('models');\n        let modelid = null;\n\n        if (modelsdata) {\n            // modelsdata is a comma-separated string, get first one.\n            const modelids = modelsdata.split(',');\n            if (modelids.length > 0) {\n                modelid = parseInt(modelids[0], 10);\n            }\n        }\n\n        if (!modelid) {\n            Notification.addNotification({\n                message: 'No model available',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Disable input and button.\n        input.prop('disabled', true);\n        button.prop('disabled', true);\n\n        // Clear input.\n        input.val('');\n\n        // Display user message with temporary ID (will be updated with real ID from server).\n        const tempId = 'temp-user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n        displayUserMessage(pageid, message, tempId);\n\n        // Show loading indicator.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        loading.show();\n\n        // Send message to AI.\n        sendMessage(cmid, pageid, message, modelid, button, input, loading);\n    });\n\n    // Handle Enter key in textarea (Shift+Enter for new line, Enter to send).\n    $(document).on('keydown', '.chat-input', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            $(this).closest('.ai-conversation-container').find('.chat-send-btn').click();\n        }\n    });\n\n    // Toggle visibility of previous turn messages in the current path.\n    $(document).on('click', '.toggle-previous-messages-btn', function(e) {\n        e.preventDefault();\n        const btn = $(this);\n        const pageid = parseInt(btn.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const container = $(`#chat-messages-page-${pageid}`);\n        const prevMessages = container.find('.previous-turn-message');\n        if (prevMessages.length === 0) {\n            return;\n        }\n        const currentlyVisible = container.data('show-previous') === true;\n        setPreviousMessagesVisibility(pageid, !currentlyVisible);\n    });\n\n    commonHandlersRegistered = true;\n}\n\n/**\n * Register handlers shared for turn tree/navigation.\n */\nfunction registerTreeHandlers() {\n    if (treeHandlersRegistered) {\n        return;\n    }\n\n    // Handle tree node navigation clicks.\n    $(document).on('click', '.tree-node-content[data-action=\"navigate\"]', function(e) {\n        e.preventDefault();\n        const node = $(this);\n        const turnId = parseInt(node.data('turn-id'), 10);\n        const pageid = node.closest('.conversation-tree-sidebar').attr('id').replace('conversation-tree-sidebar-', '');\n        if (!pageid) {\n            return;\n        }\n        if (turnId) {\n            navigateToTurn(parseInt(pageid, 10), turnId);\n        }\n    });\n\n    // Handle conversation item click (in list view).\n    $(document).on('click', '.conversation-item', function(e) {\n        e.preventDefault();\n        const item = $(this);\n        const rootTurnId = parseInt(item.data('root-turn-id'), 10);\n        const sidebar = item.closest('.conversation-tree-sidebar');\n        const pageid = parseInt(sidebar.attr('id').replace('conversation-tree-sidebar-', ''), 10);\n\n        if (!pageid) {\n            return;\n        }\n\n        if (rootTurnId) {\n            sidebar.data('sidebar-view', 'detail');\n            navigateToTurn(pageid, rootTurnId);\n        }\n    });\n\n    // Handle back to list button click.\n    $(document).on('click', '.back-to-list-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n\n        // Render the list view.\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        sidebar.data('sidebar-view', 'list'); // Set to list view\n        sidebar.data('branch-root', null);\n        sidebar.data('branch-stack', []);\n        syncTurnsUrlState(pageid);\n\n        const tree = conversationTrees[pageid];\n        if (tree) {\n            renderConversationList(pageid, tree.roots);\n        } else {\n            loadConversationTree(pageid);\n        }\n    });\n\n    // Handle back to parent branch button click.\n    $(document).on('click', '.back-to-parent-branch-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        let stack = sidebar.data('branch-stack');\n        if (!Array.isArray(stack) || stack.length === 0) {\n            sidebar.data('branch-root', null);\n            sidebar.data('branch-stack', []);\n            loadConversationTree(pageid);\n            return;\n        }\n        const previousRoot = stack.pop();\n        sidebar.data('branch-stack', stack);\n        sidebar.data('branch-root', previousRoot || null);\n        sidebar.data('sidebar-view', 'detail');\n        syncTurnsUrlState(pageid);\n        loadConversationTree(pageid);\n    });\n\n    // Handle enter branch (subtree) button click.\n    $(document).on('click', '.enter-branch-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        if (!pageid || !turnId) {\n            return;\n        }\n        const tree = conversationTrees[pageid];\n        if (!tree || !tree.roots) {\n            return;\n        }\n        const targetNode = findNodeByTurnId(tree.roots, turnId);\n        if (!targetNode || !targetNode.children || targetNode.children.length === 0) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        let stack = sidebar.data('branch-stack');\n        if (!Array.isArray(stack)) {\n            stack = [];\n        }\n        const currentRoot = sidebar.data('branch-root');\n        if (currentRoot) {\n            stack.push(currentRoot);\n        }\n        sidebar.data('branch-stack', stack);\n        sidebar.data('branch-root', turnId);\n        sidebar.data('sidebar-view', 'detail');\n        navigateToTurn(pageid, turnId);\n    });\n\n    // Handle create branch button clicks (from tree).\n    $(document).on('click', '.create-branch-from-tree-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        const branchMode = button.data('branch-mode');\n\n        if (!pageid || !turnId) {\n            Notification.addNotification({\n                message: 'Missing required data to create turn',\n                type: 'error'\n            });\n            return;\n        }\n        if (hasUnsavedTurnEvaluation(pageid, turnId)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n        if (branchMode === 'enter') {\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            let stack = sidebar.data('branch-stack');\n            if (!Array.isArray(stack)) {\n                stack = [];\n            }\n            const currentRoot = sidebar.data('branch-root');\n            if (currentRoot) {\n                stack.push(currentRoot);\n            }\n            sidebar.data('branch-stack', stack);\n            sidebar.data('branch-root', turnId);\n            sidebar.data('sidebar-view', 'detail');\n            navigateToTurn(pageid, turnId);\n            return;\n        }\n        if (!cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create turn',\n                type: 'error'\n            });\n            return;\n        }\n        createBranchFromTurn(cmid, pageid, turnId, button);\n    });\n\n    // Ensure clicks on the label/icon also trigger branch creation.\n    $(document).on('click', '.create-branch-from-tree-btn .branch-label, .create-branch-from-tree-btn i', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const btn = $(this).closest('.create-branch-from-tree-btn');\n        if (btn.length) {\n            btn.trigger('click');\n        }\n    });\n\n    // Handle \"create direct branch\" button clicks (from sidebar footer or inline).\n    $(document).on('click', '.create-direct-branch-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        // Prefer explicit root-turn-id on the button (sidebar detail footer).\n        let parentTurnId = parseInt(button.data('root-turn-id'), 10);\n        if (!parentTurnId || isNaN(parentTurnId)) {\n            // Fallback to current viewing turn.\n            parentTurnId = getViewingTurn(pageid);\n        }\n\n        if (!pageid || !cmid || !parentTurnId) {\n            Notification.addNotification({\n                message: 'Missing required data to create branch',\n                type: 'error'\n            });\n            return;\n        }\n        if (hasUnsavedTurnEvaluation(pageid, parentTurnId)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n\n        createBranchFromTurn(cmid, pageid, parentTurnId, button);\n    });\n\n    // Handle create new root button clicks.\n    $(document).on('click', '.create-root-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create root',\n                type: 'error'\n            });\n            return;\n        }\n        createNewRoot(cmid, pageid);\n    });\n    \n    // Handle export conversation button clicks.\n    $(document).on('click', '.export-conversation-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to export conversation',\n                type: 'error'\n            });\n            return;\n        }\n        \n        // Get current viewing turn (for turns mode)\n        const viewingTurn = getViewingTurn(pageid);\n        const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n        const behavior = container.data('behavior') || 'continuous';\n        \n        // Build export URL\n        const params = new URLSearchParams();\n        params.append('action', 'export_conversation');\n        params.append('cmid', cmid);\n        params.append('pageid', pageid);\n        params.append('sesskey', Config.sesskey);\n        \n        if (behavior === 'turns' && viewingTurn) {\n            params.append('turn_id', viewingTurn);\n        } else if (behavior === 'continuous') {\n            // For continuous mode, try to get conversation ID from container\n            const conversationId = container.data('viewing-conversation');\n            if (conversationId) {\n                params.append('conversation_id', conversationId);\n            }\n        }\n        \n        // Open export URL in new window/tab to trigger download\n        window.open(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), '_blank');\n    });\n\n    treeHandlersRegistered = true;\n}\n\n/**\n * Register any extra turns-specific handlers (placeholder).\n */\nfunction registerTurnHandlers() {\n    if (turnHandlersRegistered) {\n        return;\n    }\n\n    $(document).on(\n        'click',\n        '.ai-conversation-container[data-behavior=\"turns\"] .turn-evaluation-questions .save-turn-evaluation-questions-btn',\n        function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const button = $(this);\n            const turnId = parseInt(button.data('turn-id'), 10);\n            const pageid = parseInt(button.data('pageid'), 10);\n            const cmid = parseInt(button.data('cmid'), 10);\n\n            if (!turnId || !pageid || !cmid) {\n                Notification.addNotification({\n                    message: 'Missing required data to save responses.',\n                    type: 'error'\n                });\n                return;\n            }\n\n            const evaluationContainer = button.closest('.turn-evaluation-questions');\n            if (evaluationContainer.length === 0) {\n                return;\n            }\n\n            const responses = collectTurnEvaluationResponses(evaluationContainer);\n            if (Object.keys(responses).length === 0) {\n                Notification.addNotification({\n                    message: 'No editable questions to save. Click Edit on a question first.',\n                    type: 'info'\n                });\n                return;\n            }\n\n            const originalText = button.text();\n            button.prop('disabled', true);\n            button.text('Saving...');\n            saveTurnEvaluationResponses(cmid, pageid, turnId, responses, button, originalText);\n        }\n    );\n\n    turnHandlersRegistered = true;\n}\n\nconst collectTurnEvaluationResponses = (evaluationContainer) => {\n    const responses = {};\n\n    evaluationContainer.find('[data-questionid]').each(function() {\n        const item = $(this);\n        const isLocked = String(item.attr('data-response-locked')) === '1';\n        const isEditing = String(item.attr('data-response-editing')) === '1';\n        if (isLocked && !isEditing) {\n            return;\n        }\n\n        const questionId = item.data('questionid');\n        const questionType = item.data('questiontype');\n        let responseValue = null;\n\n        if (questionType === 'multiplechoice') {\n            const checked = item.find(`input[name=\"question_${questionId}_turn[]\"]:checked`);\n            const values = [];\n            checked.each(function() {\n                values.push($(this).val());\n            });\n            responseValue = values.length > 0 ? JSON.stringify(values) : null;\n        } else if (questionType === 'select') {\n            const selected = item.find(`select[name=\"question_${questionId}_turn\"]`);\n            responseValue = selected.length > 0 ? selected.val() : null;\n        } else if (questionType === 'singlechoice' || questionType === 'likert') {\n            const selected = item.find(`input[name=\"question_${questionId}_turn\"]:checked`);\n            responseValue = selected.length > 0 ? selected.val() : null;\n        } else if (questionType === 'number' || questionType === 'shorttext') {\n            const input = item.find(`input[name=\"question_${questionId}_turn\"]`);\n            responseValue = input.length > 0 ? input.val() : null;\n        } else if (questionType === 'longtext') {\n            const textarea = item.find(`textarea[name=\"question_${questionId}_turn\"]`);\n            responseValue = textarea.length > 0 ? textarea.val() : null;\n        }\n\n        if (responseValue !== null && responseValue !== '') {\n            responses[questionId] = responseValue;\n        }\n    });\n\n    return responses;\n};\n\nconst saveTurnEvaluationResponses = (cmid, pageid, turnId, responses, button, originalText) => {\n    const entries = Object.entries(responses);\n    let failedCount = 0;\n\n    let promiseChain = Promise.resolve();\n    entries.forEach(([questionId, response]) => {\n        promiseChain = promiseChain.then(() => {\n            const params = new URLSearchParams({\n                action: 'save_response',\n                cmid: cmid,\n                pageid: pageid,\n                questionid: questionId,\n                response: response,\n                turn_id: turnId,\n                sesskey: Config.sesskey\n            });\n\n            return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            .then((res) => res.json())\n            .then((data) => {\n                if (!data.success) {\n                    failedCount++;\n                }\n            })\n            .catch(() => {\n                failedCount++;\n            });\n        });\n    });\n\n    promiseChain.then(() => {\n        button.prop('disabled', false);\n        button.text(originalText);\n\n        if (failedCount === 0) {\n            Notification.addNotification({\n                message: 'Responses saved.',\n                type: 'success'\n            });\n        } else {\n            Notification.addNotification({\n                message: 'Some responses failed to save.',\n                type: 'warning'\n            });\n        }\n\n        loadTurnEvaluationResponses(pageid, turnId);\n    });\n};\n\n/**\n * Get the current turn for a page (highest turn with messages).\n *\n * @param {number} pageid Page ID\n * @return {number} Current turn number\n */\nconst getCurrentTurn = (pageid) => {\n    return currentTurns[pageid] || 1;\n};\n\n/**\n * Get the viewing turn for a page (which turn is being displayed).\n *\n * @param {number} pageid Page ID\n * @return {number} Viewing turn number\n */\nconst getViewingTurn = (pageid) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    return parseInt(container.data('viewing-turn') || getCurrentTurn(pageid), 10);\n};\n\n/**\n * Sync turns URL state (turn + branch root when applicable).\n *\n * @param {number} pageid Page ID\n * @param {number|null} turnOverride Turn to persist (defaults to current viewing turn)\n */\nconst syncTurnsUrlState = (pageid, turnOverride = null) => {\n    const turn = turnOverride !== null ? parseInt(turnOverride, 10) : getViewingTurn(pageid);\n    if (!turn || isNaN(turn)) {\n        return;\n    }\n\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    const branchRoot = parseInt(sidebar.data('branch-root'), 10);\n    const viewMode = sidebar.data('sidebar-view');\n\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('turn', turn);\n\n    if (viewMode && viewMode !== 'list' && branchRoot && !isNaN(branchRoot)) {\n        urlParams.set('branch', branchRoot);\n    } else {\n        urlParams.delete('branch');\n    }\n\n    const newUrl = window.location.pathname + '?' + urlParams.toString();\n    window.history.replaceState({}, '', newUrl);\n};\n\n/**\n * Set the viewing turn (and update URL param).\n *\n * @param {number} pageid Page ID\n * @param {number} turn Turn number\n */\nconst setViewingTurn = (pageid, turn) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    container.data('viewing-turn', turn);\n    container.attr('data-viewing-turn', turn);\n    syncTurnsUrlState(pageid, turn);\n};\n\n/**\n * Update current turn display in UI.\n *\n * @param {number} pageid Page ID\n */\nconst updateTurnDisplay = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const label = $(`#current-turn-label-${pageid}`);\n    if (label.length > 0) {\n        label.text(viewingTurn);\n    }\n};\n\n/**\n * Check if a turn has any messages.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn has at least one message\n */\nconst turnHasMessages = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    return messagesContainer.find(`.message[data-turn-id=\"${turnId}\"]`).length > 0;\n};\n\n/**\n * Check if the current turn is complete (last message from AI).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn is complete\n */\nconst isTurnComplete = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const turnMessages = messagesContainer.find(`.message[data-turn-id=\"${turnId}\"]`);\n    if (turnMessages.length === 0) {\n        return false;\n    }\n    const lastMessage = turnMessages.last();\n    const role = lastMessage.data('role');\n    return role === 'assistant' || role === 'ai';\n};\n\n/**\n * Get the number of turns in the conversation that contains the given turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID (or conversation root ID)\n * @return {number|null} Count of turns or null if unknown\n */\nconst getTurnCountForConversation = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots || !turnId) {\n        return null;\n    }\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n    return countNodes(root);\n};\n\n/**\n * Filter messages by turn - shows only messages from the current pathway.\n * All messages from the current pathway remain in the DOM, but only the current turn is visible by default.\n * Previous turns are hidden by default and can be shown via the \"Show previous\" button.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to show\n */\nconst filterMessagesByTurn = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    // Default collapsed unless user toggled to show.\n    const shouldShowPrevious = messagesContainer.data('show-previous') === true;\n    \n    // Build set of allowed turn IDs (current pathway from root to current turn).\n    const tree = conversationTrees[pageid];\n    const root = tree ? findRootForTurn(tree.roots || [], turnId) : null;\n    const allowedTurnIds = new Set();\n    allowedTurnIds.add(turnId);\n    \n    if (root) {\n        // Recursively find the path from root to the target turn.\n        const addPath = (node, targetId, path) => {\n            if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n                // Found the target - add all turns in the path.\n                path.forEach(id => allowedTurnIds.add(id));\n                allowedTurnIds.add(parseInt(node.turn_id, 10));\n                return true;\n            }\n            // Check direct branches (same level as root).\n            if (node.direct_branches) {\n                for (const db of node.direct_branches) {\n                    if (addPath(db, targetId, [...path, parseInt(node.turn_id, 10)])) {\n                        return true;\n                    }\n                }\n            }\n            // Check children (nested branches).\n            if (node.children) {\n                for (const child of node.children) {\n                    if (addPath(child, targetId, [...path, parseInt(node.turn_id, 10)])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        addPath(root, turnId, []);\n    } else {\n        // If tree not loaded yet, just allow the current turn.\n        // The tree will be loaded and filtering will be re-applied.\n        allowedTurnIds.add(turnId);\n    }\n\n    // Process all messages in the container.\n    // Messages from the current pathway remain in DOM but are shown/hidden based on turn.\n    // Messages from other pathways are hidden.\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const messageTurnId = parseInt($msg.data('turn-id'), 10);\n        \n        if (!messageTurnId || isNaN(messageTurnId)) {\n            // Message without turn_id - hide it (shouldn't happen in turns mode).\n            $msg.removeClass('previous-turn-message').hide();\n            return;\n        }\n        \n        const isCurrentTurn = messageTurnId === parseInt(turnId, 10);\n        const isInPathway = allowedTurnIds.has(messageTurnId);\n        \n        if (isInPathway) {\n            // Message is in the current pathway - keep in DOM.\n            if (isCurrentTurn) {\n                // Current turn - always visible.\n                $msg.removeClass('previous-turn-message').show();\n            } else {\n                // Previous turn in pathway - hide by default, show if toggle is on.\n                $msg.addClass('previous-turn-message');\n                if (shouldShowPrevious) {\n                    $msg.show();\n                } else {\n                    $msg.hide();\n                }\n            }\n        } else {\n            // Message is from a different pathway - hide it.\n            $msg.removeClass('previous-turn-message').hide();\n        }\n    });\n    \n    // Also handle turn separators - show/hide them based on pathway.\n    messagesContainer.find('.turn-separator').each(function() {\n        const $separator = $(this);\n        const separatorTurnId = parseInt($separator.data('turn-separator'), 10);\n        \n        if (!separatorTurnId || isNaN(separatorTurnId)) {\n            $separator.hide();\n            return;\n        }\n        \n        const isInPathway = allowedTurnIds.has(separatorTurnId);\n        if (isInPathway) {\n            $separator.show();\n        } else {\n            $separator.hide();\n        }\n    });\n\n    // Update toggle button state based on whether there are previous messages.\n    const toggleBtn = $(`.toggle-previous-messages-btn[data-pageid=\"${pageid}\"]`);\n    if (toggleBtn.length > 0) {\n        const hasPreviousMessages = messagesContainer.find('.previous-turn-message').length > 0;\n        if (hasPreviousMessages) {\n            toggleBtn.show();\n            toggleBtn.prop('disabled', false);\n            const firstPrevious = messagesContainer.find('.previous-turn-message').first();\n            const isVisible = firstPrevious.is(':visible');\n            updatePreviousToggleLabel(toggleBtn, isVisible);\n        } else {\n            // No previous messages - hide the button.\n            toggleBtn.hide();\n        }\n    }\n\n    // Scroll to bottom after filtering.\n    setTimeout(() => {\n        scrollToBottom(pageid);\n    }, 50);\n};\n\n/**\n * Update chat lock state (disable input if viewing past turn).\n *\n * @param {number} pageid Page ID\n */\nconst updateChatLockState = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n    // Ensure both are numbers for comparison.\n    const viewingTurnNum = parseInt(viewingTurn, 10);\n    const currentTurnNum = parseInt(currentTurn, 10);\n    const input = $(`#chat-input-page-${pageid}`);\n    const sendBtn = $(`.chat-send-btn[data-pageid=\"${pageid}\"]`);\n    const lockMessage = $(`#turn-locked-message-${pageid}`);\n    const container = input.closest('.ai-conversation-container');\n    const maxTurns = container.data('max-turns');\n    const maxTurnsNum = (maxTurns !== undefined && maxTurns !== null) ? parseInt(maxTurns, 10) : null;\n    const conversationTurnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n    const hasReachedTurnLimit = maxTurnsNum !== null &&\n        conversationTurnCount !== null &&\n        conversationTurnCount >= maxTurnsNum;\n\n    if (viewingTurnNum < currentTurnNum) {\n        // Viewing a past turn - lock chat.\n        input.prop('disabled', true);\n        sendBtn.prop('disabled', true);\n        if (lockMessage.length > 0) {\n            lockMessage.show();\n        }\n        // Hide direct branch button when viewing past turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n    } else if (viewingTurnNum === currentTurnNum && isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's complete - check max turns limit.\n        // Only lock if turn has messages AND max turns is reached.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n        } else {\n            // Turn complete but not at max - lock chat (user must create next turn).\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input to focus on next turn.\n            if (lockMessage.length > 0) {\n                lockMessage.hide(); // Don't show \"locked\" message, just disable input.\n            }\n            // Show direct branch button.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.show();\n            }\n        }\n    } else if (viewingTurnNum === currentTurnNum && !isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's not complete - check max turns and if we're waiting for AI response.\n        // Check max turns limit first, but only if turn has messages.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n            return;\n        }\n        // If we just sent a message, input should stay disabled until AI responds.\n        // We'll check if there's a loading indicator to determine this.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        if (loading.is(':visible')) {\n            // Waiting for AI response - keep input disabled.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n        } else {\n            // Not waiting for response - unlock chat.\n            input.prop('disabled', false);\n            sendBtn.prop('disabled', false);\n        }\n        // Hide direct branch button when turn is not complete.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    } else {\n        // Viewing future turn (shouldn't happen, but unlock just in case).\n        input.prop('disabled', false);\n        sendBtn.prop('disabled', false);\n        // Hide direct branch button when viewing future turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    }\n};\n\n/**\n * Send message to AI via AJAX (turns mode).\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} modelid Model ID\n * @param {jQuery} button Send button element\n * @param {jQuery} input Input textarea element\n * @param {jQuery} loading Loading indicator element\n */\nconst sendMessage = (cmid, pageid, message, modelid, button, input, loading) => {\n    // Get current viewing turn (for turns mode).\n    const viewingTurn = getViewingTurn(pageid);\n\n    const params = new URLSearchParams({\n        action: 'send_ai_message',\n        cmid: cmid,\n        pageid: pageid,\n        message: message,\n        modelid: modelid,\n        sesskey: Config.sesskey\n    });\n\n    // For turns mode, send the viewing turn so backend can use it.\n    if (viewingTurn) {\n        params.append('turn_id', viewingTurn);\n    }\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        loading.hide();\n\n        if (data.success) {\n            // Display AI response (check for duplicates first).\n            if (data.messageid && data.content) {\n                // displayAIMessage is async, so we need to wait for it to complete\n                // before checking if the turn is complete and updating lock state.\n                displayAIMessage(pageid, data.content, data.messageid, data.turn_id).then(() => {\n                    // Update current turn if a new turn was created.\n                    if (data.turn_id) {\n                        const currentTurn = getCurrentTurn(pageid);\n                        if (data.turn_id > currentTurn) {\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        } else if (data.turn_id === currentTurn + 1) {\n                            // Backend created next turn - update current turn.\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        }\n                    }\n\n                    // Update chat lock state after message is fully rendered in DOM.\n                    // Use a small delay to ensure DOM is completely updated and isTurnComplete can detect the new message.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                }).catch(() => {\n                    // If displayAIMessage fails, still try to update lock state.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                });\n            } else {\n                Notification.addNotification({\n                    message: 'Received response but missing message ID or content',\n                    type: 'error'\n                });\n                // Re-enable input on error.\n                input.prop('disabled', false);\n                button.prop('disabled', false);\n                input.focus();\n            }\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Error sending message',\n                type: 'error'\n            });\n            // Re-enable input on error.\n            input.prop('disabled', false);\n            button.prop('disabled', false);\n            input.focus();\n        }\n    })\n    .catch(error => {\n        loading.hide();\n        // eslint-disable-next-line no-console\n        console.error('Error sending message:', error);\n        Notification.addNotification({\n            message: 'Error sending message: ' + error.message,\n            type: 'error'\n        });\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    });\n};\n\n/**\n * Display user message in the chat.\n *\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {string} messageid Temp/real message ID\n */\nconst displayUserMessage = (pageid, message, messageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n    messagesContainer.find('.text-center.text-muted').remove();\n    Templates.render('mod_harpiasurvey/chat_user_message', {\n        id: messageid,\n        content: message,\n        timecreated: Math.floor(Date.now() / 1000)\n    }).then((html) => {\n        messagesContainer.append(html);\n        scrollToBottom(pageid);\n    }).catch(Notification.exception);\n};\n\n/**\n * Display AI message in the chat.\n *\n * @param {number} pageid Page ID\n * @param {string} content Message content\n * @param {string} messageid Message ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when rendered\n */\nconst displayAIMessage = (pageid, content, messageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return Promise.resolve();\n    }\n    return Templates.render('mod_harpiasurvey/chat_ai_message', {\n        id: messageid,\n        content: content,\n        timecreated: Math.floor(Date.now() / 1000),\n        turn_id: turnId\n    }).then((html) => {\n        messagesContainer.append(html);\n        scrollToBottom(pageid);\n        return html;\n    }).catch(Notification.exception);\n};\n\n/**\n * Scroll chat to bottom.\n *\n * @param {number} pageid Page ID\n */\nconst scrollToBottomLocal = (pageid) => scrollToBottom(pageid);\n\n/**\n * Ensure turn evaluation questions are rendered for a specific turn.\n * This will render them if they don't exist, or do nothing if they already exist.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst ensureTurnEvaluationQuestionsRendered = (pageid, turnId) => {\n    // Check if questions are already rendered for this turn.\n    // Look in the container below the chat, not inside messages.\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        // Container wrapper doesn't exist - not in turns mode or page not loaded yet.\n        return Promise.resolve();\n    }\n\n    const existingContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (existingContainer.length > 0 && existingContainer.find('.question-item').length > 0) {\n        // Questions already rendered, return resolved promise.\n        return Promise.resolve();\n    }\n\n    // Render questions for this turn.\n    return getString('loading', 'moodle').then((loadingStr) => {\n        // Show loading indicator.\n        containerWrapper.html('<div class=\"text-center py-3 text-muted\"><i class=\"fa fa-spinner fa-spin\"></i> ' +\n            loadingStr + '</div>');\n\n        const params = new URLSearchParams({\n            action: 'get_turn_questions',\n            pageid: pageid,\n            turn_id: turnId,\n            cmid: $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container').data('cmid'),\n            sesskey: Config.sesskey\n        });\n\n        return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        })\n        .then(response => {\n            if (!response.ok) {\n                throw new Error('HTTP error! status: ' + response.status);\n            }\n            return response.json();\n        })\n        .then(data => {\n            if (data.success && data.html) {\n                containerWrapper.html(data.html);\n            } else {\n                containerWrapper.html('<div class=\"text-center text-muted py-3\">' +\n                    (data.message || 'No questions available for this turn.') + '</div>');\n            }\n        })\n        .catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error('Error loading turn evaluation questions:', error);\n            containerWrapper.html('<div class=\"text-danger text-center py-3\">' +\n                'Error loading questions: ' + error.message + '</div>');\n        });\n    });\n};\n\n/**\n * Load saved responses for a turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst loadTurnEvaluationResponses = (pageid, turnId) => {\n    const cmid = getCmid(pageid);\n    if (!cmid) {\n        return;\n    }\n\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return;\n    }\n    let container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        container = containerWrapper;\n    }\n    container.find('.question-item').each(function() {\n        resetQuestionItemToNeutral($(this));\n    });\n\n    const params = new URLSearchParams({\n        action: 'get_turn_responses',\n        cmid: cmid,\n        pageid: pageid,\n        turn_id: turnId,\n        sesskey: Config.sesskey\n    });\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        if (!data.success || !data.responses || Object.keys(data.responses).length === 0) {\n            return;\n        }\n        Object.keys(data.responses).forEach((questionId) => {\n            const responseData = data.responses[questionId];\n            const questionItem = container.find(`.question-item[data-questionid=\"${questionId}\"]`);\n            if (questionItem.length === 0) {\n                return;\n            }\n            const questionType = questionItem.data('questiontype');\n            const value = responseData.response;\n\n            if (questionType === 'singlechoice' || questionType === 'likert') {\n                questionItem.find('input[type=\"radio\"]').prop('checked', false);\n                questionItem.find(`input[type=\"radio\"][value=\"${value}\"]`).prop('checked', true);\n            } else if (questionType === 'multiplechoice') {\n                questionItem.find('input[type=\"checkbox\"]').prop('checked', false);\n                try {\n                    const values = JSON.parse(value);\n                    if (Array.isArray(values)) {\n                        values.forEach((val) => {\n                            questionItem.find(`input[type=\"checkbox\"][value=\"${val}\"]`).prop('checked', true);\n                        });\n                    }\n                } catch (e) {\n                    // ignore invalid JSON\n                }\n            } else if (questionType === 'select') {\n                questionItem.find('select').val(value);\n            } else if (questionType === 'number') {\n                questionItem.find('input[type=\"number\"]').val(value);\n            } else if (questionType === 'shorttext') {\n                questionItem.find('input[type=\"text\"]').val(value);\n            } else if (questionType === 'longtext') {\n                questionItem.find('textarea').val(value);\n            }\n\n            if (responseData.saved_datetime) {\n                getString('saved', 'mod_harpiasurvey').then((savedText) => {\n                    getString('on', 'mod_harpiasurvey').then((onText) => {\n                        const icon = '<i class=\"fa fa-check-circle\" aria-hidden=\"true\"></i>';\n                        let savedMessage = questionItem.find('.saved-response-message');\n                        if (savedMessage.length === 0) {\n                            const messageHtml = '<div class=\"mt-2 small text-muted saved-response-message\">' +\n                                `${icon} ${savedText} ${onText} ${responseData.saved_datetime}</div>`;\n                            questionItem.append(messageHtml);\n                        } else {\n                            savedMessage.html(`${icon} ${savedText} ${onText} ${responseData.saved_datetime}`);\n                        }\n                    });\n                });\n            }\n\n            lockQuestionItem(questionItem);\n            ensureEditButton(questionItem);\n\n            getString('answerhistory', 'mod_harpiasurvey').then((historyText) => {\n                let history = questionItem.find('.answer-history');\n                if (!history.length && responseData.history_count > 1) {\n                    const details = $('<details class=\"answer-history mt-1\"></details>');\n                    details.append(`<summary>${historyText} (${responseData.history_count})</summary>`);\n                    details.append('<ul class=\"list-unstyled mt-2 mb-0\"></ul>');\n                    questionItem.append(details);\n                    history = details;\n                }\n                if (history.length) {\n                    const list = history.find('ul');\n                    list.empty();\n                    (responseData.history_items || []).forEach((item) => {\n                        list.append(`<li class=\"mb-1\"><span class=\"text-muted\">${item.time}</span>  ${item.response}</li>`);\n                    });\n                    history.find('summary').text(`${historyText} (${responseData.history_count || 0})`);\n                    if ((responseData.history_count || 0) > 1) {\n                        history.show();\n                    } else {\n                        history.hide();\n                    }\n                }\n            });\n        });\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading turn responses:', error);\n    });\n};\n\n/**\n * Clear turn evaluation form (placeholder).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst clearTurnEvaluationForm = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return;\n    }\n    let container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        container = containerWrapper;\n    }\n    container.find('.question-item').each(function() {\n        resetQuestionItemToNeutral($(this));\n    });\n};\n\nconst hasUnsavedTurnEvaluation = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return false;\n    }\n    const container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        return false;\n    }\n    const requiredQuestions = container.find('.question-item[data-required=\"1\"]');\n    if (requiredQuestions.length === 0) {\n        return false;\n    }\n    const savedRequired = requiredQuestions.filter(function() {\n        return $(this).find('.saved-response-message').length > 0;\n    }).length;\n    return savedRequired !== requiredQuestions.length;\n};\n\n/**\n * Filter messages by conversation ID (no-op in turns).\n */\nconst filterMessagesByConversation = () => {};\n\n/**\n * Navigate to a specific turn in the conversation.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to navigate to\n * @param {boolean} setAsCurrent Whether to set this turn as the current turn (for new branches)\n */\nconst navigateToTurn = (pageid, turnId, setAsCurrent = false) => {\n    // If this is a new turn (like a branch), set it as current FIRST so chat is unlocked.\n    if (setAsCurrent) {\n        currentTurns[pageid] = turnId;\n    }\n    // Then set viewing turn.\n    setViewingTurn(pageid, turnId);\n    // Update display and lock state.\n    updateTurnDisplay(pageid);\n    updateChatLockState(pageid);\n\n    // Collapse previous separators when navigating forward.\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.turn-separator').each(function() {\n        const separatorTurnId = $(this).data('turn-separator');\n        if (separatorTurnId) {\n            if (parseInt(separatorTurnId, 10) < turnId) {\n                $(this).data('collapsed', true);\n                const toggleIcon = $(this).find('.toggle-turn-btn').find('.toggle-turn-icon');\n                if (toggleIcon.length > 0) {\n                    toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');\n                }\n            }\n        }\n    });\n\n    filterMessagesByTurn(pageid, turnId);\n    updateSubpageVisibility(pageid);\n    ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n        clearTurnEvaluationForm(pageid, turnId);\n        loadTurnEvaluationResponses(pageid, turnId);\n    });\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    if (sidebar.length) {\n        sidebar.data('sidebar-view', 'detail');\n        loadConversationTree(pageid);\n    }\n};\n\n/**\n * Update subpage visibility for turns mode.\n *\n * @param {number} pageid Page ID\n */\nconst updateSubpageVisibility = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const subpagesContainer = $(`#subpages-container-${pageid}`);\n\n    if (subpagesContainer.length === 0) {\n        return; // No subpages container found.\n    }\n\n    // Update subpage visibility.\n    subpagesContainer.find('.subpage-item').each(function() {\n        const $subpage = $(this);\n        const visibilityType = $subpage.data('visibility-type');\n        const turnNumber = $subpage.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = false;\n        }\n\n        if (shouldShow) {\n            $subpage.slideDown(200);\n            // Update question visibility within this subpage.\n            updateSubpageQuestionVisibility($subpage, viewingTurn);\n        } else {\n            $subpage.slideUp(200);\n        }\n    });\n};\n\n/**\n * Update question visibility within a subpage based on current turn.\n *\n * @param {jQuery} $subpage Subpage jQuery element\n * @param {number} viewingTurn Current viewing turn\n */\nconst updateSubpageQuestionVisibility = ($subpage, viewingTurn) => {\n    $subpage.find('.question-item').each(function() {\n        const $question = $(this);\n        const visibilityType = $question.data('visibility-type') || 'all_turns';\n        const turnNumber = $question.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = true; // Default to showing if not set.\n        }\n\n        if (shouldShow) {\n            $question.slideDown(200);\n        } else {\n            $question.slideUp(200);\n        }\n    });\n};\n\n/**\n * Load conversation tree from server and render it.\n *\n * @param {number} pageid Page ID\n * @return {Promise} Promise that resolves when tree is loaded\n */\nconst loadConversationTree = (pageid) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n    if (treeContainer.length === 0) {\n        // eslint-disable-next-line no-console\n        console.warn('Tree container not found for pageid:', pageid);\n        return Promise.resolve(null);\n    }\n\n    // Get cmid from the container.\n    const cmid = getCmid(pageid);\n    if (!cmid) {\n        // eslint-disable-next-line no-console\n        console.error('cmid not found for pageid:', pageid);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error: Course module ID not found. Please refresh the page.</div>');\n        return Promise.resolve(null);\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'get_conversation_tree');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n    return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        // eslint-disable-next-line no-console\n        console.log('Conversation tree response:', data);\n\n        if (data.success && data.tree) {\n            // Annotate roots with sequential conversation numbers for consistent labels.\n            data.tree.roots = (data.tree.roots || []).map((root, idx) => ({\n                ...root,\n                conversation_number: idx + 1\n            }));\n            // Store tree for message filtering.\n            conversationTrees[pageid] = data.tree;\n\n            const viewingTurn = getViewingTurn(pageid);\n            const viewMode = sidebar.data('sidebar-view');\n            const branchRootId = sidebar.data('branch-root');\n            if (!viewMode || viewMode === 'list') {\n                renderConversationList(pageid, data.tree.roots);\n            } else {\n                const root = branchRootId ? findNodeByTurnId(data.tree.roots || [], branchRootId) :\n                    findRootForTurn(data.tree.roots || [], viewingTurn);\n                if (root) {\n                    renderConversationDetail(pageid, root);\n                } else {\n                    renderConversationList(pageid, data.tree.roots);\n                }\n            }\n            syncTurnsUrlState(pageid, viewingTurn);\n\n            // Re-filter messages now that we have the tree, so previous-turn messages are correctly\n            // marked and hidden by default, with the toggle controlling them.\n            filterMessagesByTurn(pageid, viewingTurn);\n\n            // Show create-root button only when in list view (outside a conversation).\n            const rootBtn = sidebar.find('.create-root-btn');\n            if (rootBtn.length) {\n                const viewMode = sidebar.data('sidebar-view');\n                if (!viewMode || viewMode === 'list') {\n                    rootBtn.show();\n                } else {\n                    rootBtn.hide();\n                }\n            }\n\n            return data.tree;\n        } else {\n            // Show message in tree container instead of notification.\n            treeContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                (data.message || 'No conversation tree available yet.') + '</div>');\n            return null;\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading conversation tree:', error);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error loading conversation tree: ' + error.message + '<br>' +\n            'Please check the browser console for details and refresh the page.</div>');\n        return null;\n    });\n};\n\n/**\n * Find the root node that contains the given turn ID.\n */\nconst getTurnNumberForId = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return null;\n    }\n\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n\n    const findAndNumber = (node, targetId, parentNumber, turnIndex) => {\n        const nodeNumber = calculateTurnNumber(node, turnIndex, parentNumber);\n\n        if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n            return nodeNumber;\n        }\n\n        // Check direct branches if this is a root.\n        if (node.direct_branches && node.direct_branches.length > 0) {\n            // Sort direct branches by turn_id for consistent ordering.\n            const sortedDB = [...node.direct_branches].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            let dbCounter = turnIndex + 1; // Continue sequential numbering\n            for (const db of sortedDB) {\n                const dbNumber = calculateTurnNumber(db, dbCounter, null);\n                if (parseInt(db.turn_id, 10) === parseInt(targetId, 10)) {\n                    return dbNumber;\n                }\n                // Check children of direct branch (derived branches).\n                if (db.children && db.children.length > 0) {\n                    const sortedChildren = [...db.children].sort((a, b) =>\n                        parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n                    );\n                    for (let i = 0; i < sortedChildren.length; i++) {\n                        const found = findAndNumber(sortedChildren[i], targetId, dbNumber, i);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n                dbCounter++;\n            }\n        }\n\n        // Check children (derived branches).\n        if (node.children && node.children.length > 0) {\n            const sortedChildren = [...node.children].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            for (let i = 0; i < sortedChildren.length; i++) {\n                const found = findAndNumber(sortedChildren[i], targetId, nodeNumber, i);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    // Start from root (turnIndex 0 = turn number 1).\n    return findAndNumber(root, turnId, null, 0);\n};\n\n/**\n * Prepare node data for recursive rendering.\n */\nconst prepareNodeData = (node, level, currentTurnId, pageid, cmid, turnIndex = 0, parentNumber = null,\n    includeChildren = true, forcedTurnNumber = null) => {\n    const isCurrent = parseInt(node.turn_id, 10) === parseInt(currentTurnId, 10);\n    const hasChildren = node.children && node.children.length > 0;\n    const isDirectBranch = node.is_direct_branch || false;\n    const isRoot = node.is_root || false;\n    const turnNumber = forcedTurnNumber !== null ? String(forcedTurnNumber) : calculateTurnNumber(node, turnIndex, parentNumber);\n\n    return {\n        turn_id: node.turn_id,\n        conversation_id: node.conversation_id || node.turn_id, // Use conversation_id if available, fallback to turn_id\n        turn_number: turnNumber,\n        is_root: isRoot,\n        is_direct_branch: isDirectBranch,\n        is_current: isCurrent,\n        has_children: hasChildren,\n        branch_label: node.branch_label || null,\n        level: level,\n        expanded: true,\n        pageid: pageid,\n        cmid: cmid,\n        can_create_branch: true, // Turns-only module\n        children: (includeChildren && hasChildren) ? node.children.map((child, index) =>\n            // Keep descendants at the same visual level as their branch root; only the bifurcation is indented.\n            prepareNodeData(child, isDirectBranch ? level : level + 1, currentTurnId, pageid, cmid, index, turnNumber, includeChildren)) : []\n    };\n};\n\n/**\n * Render conversation detail view (single root tree).\n */\nconst renderConversationDetail = (pageid, root) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n    const viewingTurn = getViewingTurn(pageid);\n    const branchStack = sidebar.data('branch-stack');\n    const showBranchBack = Array.isArray(branchStack) && branchStack.length > 0;\n    const isBranchRoot = !root.is_root;\n\n    sidebar.data('branch-root', root.turn_id);\n\n    // Calculate turn numbers: root is 1, then direct branches are 2, 3, 4...\n    // All turns at root level (root + direct branches) are numbered sequentially.\n    let turnCounter = 0; // Will be incremented to 1 for root, 2 for first direct branch, etc.\n    const rootTurnNumber = getTurnNumberForId(pageid, root.turn_id) || '1';\n    const rootNodeData = prepareNodeData(root, 0, viewingTurn, pageid, cmid, turnCounter, null, false, rootTurnNumber);\n    turnCounter++;\n\n    // Find direct branches of this root (branches where parent is this root).\n    // Direct branches are stored in the root's direct_branches array.\n    const directBranches = [];\n    const childBranches = root.is_root ? (root.direct_branches || []) : (root.children || []);\n    if (childBranches.length > 0) {\n        const sortedDirectBranches = [...childBranches].sort((a, b) =>\n            parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n        );\n        sortedDirectBranches.forEach((node) => {\n            const childTurnNumber = getTurnNumberForId(pageid, node.turn_id) ||\n                calculateTurnNumber(node, turnCounter, null);\n            // Direct branches continue sequential numbering: 2, 3, 4...\n            // Level 1 so they render visually indented under the root they forked from.\n            directBranches.push(prepareNodeData(\n                node,\n                0,\n                viewingTurn,\n                pageid,\n                cmid,\n                turnCounter,\n                null,\n                false,\n                childTurnNumber\n            ));\n            turnCounter++;\n        });\n    }\n\n    Templates.render('mod_harpiasurvey/conversation_detail', {\n        root_node: rootNodeData,\n        root_turn_id: root.turn_id,\n        direct_branches: directBranches,\n        pageid: pageid,\n        cmid: cmid,\n        conversation_number: root.conversation_number || 1,\n        show_branch_back: showBranchBack,\n        branch_root_turn: isBranchRoot ? root.turn_id : null\n    }).then((html) => {\n        treeContainer.html(html);\n        treeContainer.find('[data-toggle=\"popover\"]').popover({\n            trigger: 'hover',\n            placement: 'top',\n            container: 'body'\n        });\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error rendering conversation detail:', error);\n    });\n};\n\nconst findNodeByTurnId = (roots, turnId) => {\n    if (!roots || !turnId) {\n        return null;\n    }\n    const target = parseInt(turnId, 10);\n    const queue = [...roots];\n    while (queue.length) {\n        const node = queue.shift();\n        if (!node) {\n            continue;\n        }\n        if (parseInt(node.turn_id, 10) === target) {\n            return node;\n        }\n        if (node.direct_branches && node.direct_branches.length) {\n            queue.push(...node.direct_branches);\n        }\n        if (node.children && node.children.length) {\n            queue.push(...node.children);\n        }\n    }\n    return null;\n};\n\n/**\n * Update turn labels in existing messages (after tree is loaded).\n */\nconst updateMessageTurnLabels = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const turnId = parseInt($msg.data('turn-id'), 10);\n        if (turnId) {\n            // Use hierarchical turn number.\n            const turnNumber = getTurnNumberForId(pageid, turnId) || turnId;\n            const turnLabel = 'Turno ' + turnNumber;\n            // Update badge in message - find the badge that contains turn label.\n            const $badge = $msg.find('.badge').filter(function() {\n                // Find badge that's in the position-absolute div (turn label badge).\n                return $(this).closest('.position-absolute').length > 0;\n            });\n            if ($badge.length > 0) {\n                $badge.text(turnLabel);\n            } else {\n                // Fallback: update first badge if position-absolute not found.\n                const $firstBadge = $msg.find('.badge').first();\n                if ($firstBadge.length > 0) {\n                    $firstBadge.text(turnLabel);\n                }\n            }\n        }\n    });\n};\n\n/**\n * Create a branch from a specific turn.\n */\nconst createBranchFromTurn = (cmid, pageid, parentTurnId, buttonEl = null) => {\n    const btn = buttonEl ? $(buttonEl) : null;\n    let originalHtml = null;\n    if (btn && btn.length) {\n        originalHtml = btn.html();\n        btn.prop('disabled', true).addClass('branch-btn-loading');\n        btn.html('<i class=\"fa fa-spinner fa-spin fa-xs\" aria-hidden=\"true\"></i>');\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_branch');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('parent_turn_id', parentTurnId);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        if (data.success) {\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            if (sidebar.length) {\n                let stack = sidebar.data('branch-stack');\n                if (!Array.isArray(stack)) {\n                    stack = [];\n                }\n                const currentRoot = sidebar.data('branch-root');\n                if (currentRoot) {\n                    stack.push(currentRoot);\n                }\n                sidebar.data('branch-stack', stack);\n                sidebar.data('branch-root', parentTurnId);\n                sidebar.data('sidebar-view', 'detail');\n            }\n\n            // Navigate to the new turn and set it as current (this will unlock the chat).\n            navigateToTurn(pageid, data.new_turn_id, true);\n\n            // Optimistically update local tree for immediate visual feedback.\n            addLocalBranchNode(pageid, parentTurnId, data.new_turn_id);\n\n            // Reload conversation tree to show the new branch.\n            loadConversationTree(pageid);\n\n            getString('branchcreated', 'mod_harpiasurvey')\n                .then((msg) => {\n                    Notification.addNotification({\n                        message: msg,\n                        type: 'success'\n                    });\n                })\n                .catch(() => {\n                    Notification.addNotification({\n                        message: 'Branch created successfully',\n                        type: 'success'\n                    });\n                });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create turn',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error creating turn:', error);\n        Notification.addNotification({\n            message: 'Error creating turn: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\n/**\n * Add a branch node locally so the tree shows immediate indentation before reload.\n */\nconst addLocalBranchNode = (pageid, parentTurnId, newTurnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return;\n    }\n    const root = findRootForTurn(tree.roots, parentTurnId);\n    if (!root) {\n        return;\n    }\n\n    const newNode = {\n        turn_id: newTurnId,\n        is_root: false,\n        is_direct_branch: false,\n        parent_turn_id: parentTurnId,\n        branch_label: String(newTurnId),\n        children: [],\n        timecreated: Math.floor(Date.now() / 1000),\n        timecreated_str: new Date().toLocaleString()\n    };\n\n    const attach = (node) => {\n        if (parseInt(node.turn_id, 10) === parseInt(parentTurnId, 10)) {\n            if (node.is_root || node.is_direct_branch) {\n                newNode.is_direct_branch = true;\n                if (!node.direct_branches) {\n                    node.direct_branches = [];\n                }\n                node.direct_branches.push(newNode);\n            } else {\n                if (!node.children) {\n                    node.children = [];\n                }\n                node.children.push(newNode);\n            }\n            return true;\n        }\n        if (node.direct_branches) {\n            for (const db of node.direct_branches) {\n                if (attach(db)) {\n                    return true;\n                }\n            }\n        }\n        if (node.children) {\n            for (const child of node.children) {\n                if (attach(child)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    attach(root);\n};\n\n/**\n * Create a new root conversation.\n */\nconst createNewRoot = (cmid, pageid) => {\n    const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_root');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (data.success) {\n            currentTurns[pageid] = data.new_turn_id;\n            setViewingTurn(pageid, data.new_turn_id);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            messagesContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                'New conversation started. Send a message to begin.</div>');\n            $(`#turn-evaluation-questions-container-${pageid}`).empty();\n\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            sidebar.data('sidebar-view', 'detail');\n            setTimeout(() => {\n                loadConversationTree(pageid);\n            }, 100);\n\n            Notification.addNotification({\n                message: data.message || 'New conversation created successfully',\n                type: 'success'\n            });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create new root',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error creating new root:', error);\n        Notification.addNotification({\n            message: 'Error creating new root: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\nconst setPreviousMessagesVisibility = (pageid, visible) => {\n    const container = $(`#chat-messages-page-${pageid}`);\n    container.data('show-previous', visible === true);\n    const prevMessages = container.find('.previous-turn-message');\n    if (visible) {\n        prevMessages.show();\n    } else {\n        prevMessages.hide();\n    }\n    const toggleBtn = $(`.toggle-previous-messages-btn[data-pageid=\"${pageid}\"]`);\n    if (toggleBtn.length) {\n        updatePreviousToggleLabel(toggleBtn, visible);\n    }\n};\n\nconst updatePreviousToggleLabel = (btn, isVisible) => {\n    if (isVisible) {\n        btn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Ocultar anteriores');\n        btn.attr('title', 'Ocultar conversas anteriores');\n    } else {\n        btn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Mostrar anteriores');\n        btn.attr('title', 'Mostrar conversas anteriores');\n    }\n};\n\nexport {\n    updateTurnDisplay,\n    getViewingTurn,\n    getCurrentTurn,\n    setViewingTurn,\n    isTurnComplete,\n    loadConversationTree,\n    navigateToTurn,\n    renderConversationDetail,\n    prepareNodeData,\n    updateMessageTurnLabels,\n    setPreviousMessagesVisibility,\n    scrollToBottom,\n    createBranchFromTurn,\n    createNewRoot\n};\n\nexport default {\n    init,\n    initTurns\n};\n"],"names":["initializedTurns","commonHandlersRegistered","turnHandlersRegistered","treeHandlersRegistered","editLabel","resetQuestionItemToNeutral","questionItem","length","removeAttr","find","remove","prop","each","this","Boolean","defaultChecked","select","defaultOption","filter","defaultSelected","first","val","defaultValue","initialize","then","str","catch","containers","pageid","parseInt","data","messagesContainer","maxTurn","turnId","calculatedCurrentTurn","currentTurns","urlParams","URLSearchParams","window","location","search","urlTurn","get","urlBranch","initialViewingTurn","parsedTurn","isNaN","sidebar","parsedBranchRoot","setViewingTurn","updateTurnDisplay","updateChatLockState","show","addClass","loadConversationTree","filterMessagesByTurn","updateSubpageVisibility","setTimeout","ensureTurnEvaluationQuestionsRendered","loadTurnEvaluationResponses","error","console","document","on","e","preventDefault","button","cmid","container","closest","addNotification","message","type","input","inputValue","trim","viewingTurn","getViewingTurn","currentTurn","getCurrentTurn","viewingTurnNum","maxTurns","maxTurnsNum","turnCount","getTurnCountForConversation","isTurnComplete","modelsdata","modelid","modelids","split","tempId","Date","now","Math","random","toString","substr","displayUserMessage","loading","sendMessage","key","shiftKey","click","btn","currentlyVisible","setPreviousMessagesVisibility","registerCommonHandlers","node","attr","replace","navigateToTurn","item","rootTurnId","syncTurnsUrlState","tree","conversationTrees","roots","stack","Array","isArray","previousRoot","pop","stopPropagation","targetNode","findNodeByTurnId","children","currentRoot","push","branchMode","hasUnsavedTurnEvaluation","createBranchFromTurn","trigger","parentTurnId","createNewRoot","behavior","params","append","Config","sesskey","conversationId","open","wwwroot","registerTreeHandlers","evaluationContainer","responses","collectTurnEvaluationResponses","Object","keys","originalText","text","saveTurnEvaluationResponses","registerTurnHandlers","init","initTurns","isLocked","String","isEditing","questionId","questionType","responseValue","checked","values","JSON","stringify","selected","textarea","entries","failedCount","promiseChain","Promise","resolve","forEach","_ref","response","action","questionid","turn_id","fetch","method","headers","res","json","success","turnOverride","turn","branchRoot","viewMode","set","delete","newUrl","pathname","history","replaceState","label","turnHasMessages","turnMessages","role","last","root","shouldShowPrevious","allowedTurnIds","Set","add","addPath","targetId","path","id","direct_branches","db","child","$msg","messageTurnId","removeClass","hide","isCurrentTurn","has","$separator","separatorTurnId","toggleBtn","isVisible","is","updatePreviousToggleLabel","currentTurnNum","sendBtn","lockMessage","conversationTurnCount","hasReachedTurnLimit","directBranchContainer","ok","Error","status","messageid","content","displayAIMessage","focus","render","timecreated","floor","html","Notification","exception","Templates","containerWrapper","existingContainer","loadingStr","responseData","value","parse","saved_datetime","savedText","onText","icon","savedMessage","messageHtml","lockQuestionItem","controls","ensureEditButton","historyText","history_count","details","list","empty","history_items","time","clearTurnEvaluationForm","requiredQuestions","setAsCurrent","toggleIcon","subpagesContainer","$subpage","visibilityType","turnNumber","shouldShow","slideDown","updateSubpageQuestionVisibility","slideUp","$question","treeContainer","warn","body","log","map","idx","conversation_number","branchRootId","renderConversationDetail","rootBtn","getTurnNumberForId","findAndNumber","parentNumber","turnIndex","nodeNumber","sortedDB","sort","a","b","dbCounter","dbNumber","sortedChildren","i","found","prepareNodeData","level","currentTurnId","includeChildren","forcedTurnNumber","isCurrent","hasChildren","isDirectBranch","is_direct_branch","isRoot","is_root","conversation_id","turn_number","is_current","has_children","branch_label","expanded","can_create_branch","index","branchStack","showBranchBack","isBranchRoot","turnCounter","rootTurnNumber","rootNodeData","directBranches","childBranches","childTurnNumber","root_node","root_turn_id","show_branch_back","branch_root_turn","popover","placement","target","queue","shift","turnLabel","$badge","$firstBadge","buttonEl","originalHtml","new_turn_id","addLocalBranchNode","msg","newTurnId","newNode","parent_turn_id","timecreated_str","toLocaleString","attach","visible","prevMessages"],"mappings":"srBAsBIA,kBAAmB,EACnBC,0BAA2B,EAC3BC,wBAAyB,EACzBC,wBAAyB,EACzBC,UAAY,aAuBVC,2BAA8BC,eAC3BA,cAAwC,IAAxBA,aAAaC,SAIlCD,aAAaE,WAAW,wBACxBF,aAAaE,WAAW,yBACxBF,aAAaG,KAAK,2BAA2BC,SAC7CJ,aAAaG,KAAK,mBAAmBC,SACrCJ,aAAaG,KAAK,2BAA2BC,SAE7CJ,aAAaG,KAAK,2BAA2BE,KAAK,YAAY,GAE9DL,aAAaG,KAAK,+CAA+CG,MAAK,8BAChEC,MAAMF,KAAK,UAAWG,QAAQD,KAAKE,oBAGzCT,aAAaG,KAAK,UAAUG,MAAK,iBACvBI,QAAS,kBAAEH,MACXI,cAAgBD,OAAOP,KAAK,UAAUS,QAAO,kBACxCL,KAAKM,mBACbC,QACCH,cAAcV,OAAS,EACvBS,OAAOK,IAAIJ,cAAcI,OAEzBL,OAAOL,KAAK,gBAAiB,MAIrCL,aAAaG,KAAK,sDAAsDG,MAAK,8BACvEC,MAAMQ,IAAIR,KAAKS,cAAgB,SAOnCC,WAAa,QACXvB,mDAIM,OAAQ,UAAUwB,MAAMC,MAC9BrB,UAAYqB,OACbC,OAAM,KACLtB,UAAY,gBAGVuB,YAAa,kBAAE,qDACK,IAAtBA,WAAWpB,SAIfoB,WAAWf,MAAK,iBACNgB,OAASC,UAAS,kBAAEhB,MAAMiB,KAAK,UAAW,QAE3CF,oBAICG,mBAAoB,kBAAG,uBAAsBH,cAC/CI,QAAU,EACdD,kBAAkBtB,KAAK,kBAAkBG,MAAK,iBACpCqB,OAASJ,UAAS,kBAAEhB,MAAMiB,KAAK,WAAY,IAC7CG,QAAUA,OAASD,UACnBA,QAAUC,iBAGZC,sBAAwBF,QAAU,EAAIA,QAAU,EACjDG,0BAAaP,oCACDA,QAAUM,6BAGrBE,UAAY,IAAIC,gBAAgBC,OAAOC,SAASC,QAChDC,QAAUL,UAAUM,IAAI,QACxBC,UAAYP,UAAUM,IAAI,cAE5BE,mBAAqBT,0BAAaP,WACtB,OAAZa,SAAgC,KAAZA,QAAgB,OAC9BI,WAAahB,SAASY,QAAS,KAChCK,MAAMD,aAAeA,WAAa,IACnCD,mBAAqBC,kBAIvBE,SAAU,kBAAG,8BAA6BnB,aAC5CmB,QAAQxC,OAAS,GAAmB,OAAdoC,WAAoC,KAAdA,UAAkB,OACxDK,iBAAmBnB,SAASc,UAAW,KACxCG,MAAME,mBAAqBA,iBAAmB,IAC/CD,QAAQjB,KAAK,eAAgB,UAC7BiB,QAAQjB,KAAK,cAAekB,mBAIpCC,eAAerB,OAAQgB,oBACvBM,kBAAkBtB,QAClBuB,oBAAoBvB,QAGhBmB,QAAQxC,OAAS,GACjBwC,QAAQK,0BACL,iCAAgCxB,YAAYyB,SAAS,UAExDC,qBAAqB1B,QAAQJ,MAAK,KAE9B+B,qBAAqB3B,OAAQgB,uBAC9BlB,OAAM,KAEL6B,qBAAqB3B,OAAQgB,wBAIjCW,qBAAqB3B,OAAQgB,oBAGjCY,wBAAwB5B,QACxB6B,YAAW,KACPC,sCAAsC9B,OAAQgB,oBAAoBpB,MAAK,KACnEmC,4BAA4B/B,OAAQgB,uBACrClB,OAAOkC,QAENC,QAAQD,MAAM,mDAAoDA,YAEvE,sBAgBH3D,mDAKF6D,UAAUC,GAAG,QAAS,kBAAkB,SAASC,GAC/CA,EAAEC,uBACIC,QAAS,kBAAErD,MACXsD,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,IACrCF,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCsC,UAAYF,OAAOG,QAAQ,iCACE,UAA/BD,UAAUtC,KAAK,uBAIdqC,OAASvC,6CACG0C,gBAAgB,CACzBC,QAAS,yBACTC,KAAM,gBAKRC,OAAQ,kBAAG,oBAAmB7C,aACf,IAAjB6C,MAAMlE,6CACO+D,gBAAgB,CACzBC,QAAS,uBACTC,KAAM,gBAKRE,WAAaD,MAAMpD,UACpBqD,wBAICH,QAAUG,WAAWC,WAEtBJ,qBAKCK,YAAcC,eAAejD,QAC7BkD,YAAcC,eAAenD,QAE7BoD,eAAiBnD,SAAS+C,YAAa,OAMzCI,eALmBnD,SAASiD,YAAa,0CAO5BR,gBAAgB,CACzBC,QAAS,6EAETC,KAAM,gBAORS,SAAWb,UAAUtC,KAAK,gBAC5BmD,MAAAA,SAA6C,OACvCC,YAAcrD,SAASoD,SAAU,IACjCE,UAAYC,4BAA4BxD,OAAQoD,mBAGpC,OAAdG,WAAsBA,WAAaD,aACnCG,eAAezD,OAAQoD,sDACb,kBAAmB,oBAAoBxD,MAAMC,gCACtC6C,gBAAgB,CACzBC,QAAS9C,IACT+C,KAAM,mBAQhBc,WAAalB,UAAUtC,KAAK,cAC9ByD,QAAU,QAEVD,WAAY,OAENE,SAAWF,WAAWG,MAAM,KAC9BD,SAASjF,OAAS,IAClBgF,QAAU1D,SAAS2D,SAAS,GAAI,SAInCD,8CACYjB,gBAAgB,CACzBC,QAAS,qBACTC,KAAM,UAMdC,MAAM9D,KAAK,YAAY,GACvBuD,OAAOvD,KAAK,YAAY,GAGxB8D,MAAMpD,IAAI,UAGJqE,OAAS,aAAeC,KAAKC,MAAQ,IAAMC,KAAKC,SAASC,SAAS,IAAIC,OAAO,EAAG,GACtFC,mBAAmBrE,OAAQ2C,QAASmB,cAG9BQ,SAAU,kBAAG,sBAAqBtE,UACxCsE,QAAQ9C,OAGR+C,YAAYhC,KAAMvC,OAAQ2C,QAASgB,QAASrB,OAAQO,MAAOyB,+BAI7DpC,UAAUC,GAAG,UAAW,eAAe,SAASC,GAChC,UAAVA,EAAEoC,KAAoBpC,EAAEqC,WACxBrC,EAAEC,oCACApD,MAAMwD,QAAQ,8BAA8B5D,KAAK,kBAAkB6F,+BAK3ExC,UAAUC,GAAG,QAAS,iCAAiC,SAASC,GAC9DA,EAAEC,uBACIsC,KAAM,kBAAE1F,MACRe,OAASC,SAAS0E,IAAIzE,KAAK,UAAW,QACvCF,oBAGCwC,WAAY,kBAAG,uBAAsBxC,aAEf,IADPwC,UAAU3D,KAAK,0BACnBF,oBAGXiG,kBAAuD,IAApCpC,UAAUtC,KAAK,iBACxC2E,8BAA8B7E,QAAS4E,qBAG3CvG,0BAA2B,EAhK3ByG,iBAuKIvG,iDAKF2D,UAAUC,GAAG,QAAS,8CAA8C,SAASC,GAC3EA,EAAEC,uBACI0C,MAAO,kBAAE9F,MACToB,OAASJ,SAAS8E,KAAK7E,KAAK,WAAY,IACxCF,OAAS+E,KAAKtC,QAAQ,8BAA8BuC,KAAK,MAAMC,QAAQ,6BAA8B,IACtGjF,QAGDK,QACA6E,eAAejF,SAASD,OAAQ,IAAKK,8BAK3C6B,UAAUC,GAAG,QAAS,sBAAsB,SAASC,GACnDA,EAAEC,uBACI8C,MAAO,kBAAElG,MACTmG,WAAanF,SAASkF,KAAKjF,KAAK,gBAAiB,IACjDiB,QAAUgE,KAAK1C,QAAQ,8BACvBzC,OAASC,SAASkB,QAAQ6D,KAAK,MAAMC,QAAQ,6BAA8B,IAAK,IAEjFjF,QAIDoF,aACAjE,QAAQjB,KAAK,eAAgB,UAC7BgF,eAAelF,OAAQoF,mCAK7BlD,UAAUC,GAAG,QAAS,qBAAqB,SAASC,GAClDA,EAAEC,uBACIC,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,QAC1CF,oBAKCmB,SAAU,kBAAG,8BAA6BnB,UAChDmB,QAAQjB,KAAK,eAAgB,QAC7BiB,QAAQjB,KAAK,cAAe,MAC5BiB,QAAQjB,KAAK,eAAgB,IAC7BmF,kBAAkBrF,cAEZsF,KAAOC,+BAAkBvF,QAC3BsF,6CACuBtF,OAAQsF,KAAKE,OAEpC9D,qBAAqB1B,8BAK3BkC,UAAUC,GAAG,QAAS,8BAA8B,SAASC,GAC3DA,EAAEC,uBACIC,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,QAC1CF,oBAGCmB,SAAU,kBAAG,8BAA6BnB,cAC5CyF,MAAQtE,QAAQjB,KAAK,oBACpBwF,MAAMC,QAAQF,QAA2B,IAAjBA,MAAM9G,cAC/BwC,QAAQjB,KAAK,cAAe,MAC5BiB,QAAQjB,KAAK,eAAgB,SAC7BwB,qBAAqB1B,cAGnB4F,aAAeH,MAAMI,MAC3B1E,QAAQjB,KAAK,eAAgBuF,OAC7BtE,QAAQjB,KAAK,cAAe0F,cAAgB,MAC5CzE,QAAQjB,KAAK,eAAgB,UAC7BmF,kBAAkBrF,QAClB0B,qBAAqB1B,8BAIvBkC,UAAUC,GAAG,QAAS,qBAAqB,SAASC,GAClDA,EAAEC,iBACFD,EAAE0D,wBACIxD,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCG,OAASJ,SAASqC,OAAOpC,KAAK,WAAY,QAC3CF,SAAWK,oBAGViF,KAAOC,+BAAkBvF,YAC1BsF,OAASA,KAAKE,mBAGbO,WAAaC,iBAAiBV,KAAKE,MAAOnF,YAC3C0F,aAAeA,WAAWE,UAA2C,IAA/BF,WAAWE,SAAStH,oBAGzDwC,SAAU,kBAAG,8BAA6BnB,cAC5CyF,MAAQtE,QAAQjB,KAAK,gBACpBwF,MAAMC,QAAQF,SACfA,MAAQ,UAENS,YAAc/E,QAAQjB,KAAK,eAC7BgG,aACAT,MAAMU,KAAKD,aAEf/E,QAAQjB,KAAK,eAAgBuF,OAC7BtE,QAAQjB,KAAK,cAAeG,QAC5Bc,QAAQjB,KAAK,eAAgB,UAC7BgF,eAAelF,OAAQK,8BAIzB6B,UAAUC,GAAG,QAAS,gCAAgC,SAASC,GAC7DA,EAAEC,iBACFD,EAAE0D,wBACIxD,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCqC,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,IACrCG,OAASJ,SAASqC,OAAOpC,KAAK,WAAY,IAC1CkG,WAAa9D,OAAOpC,KAAK,kBAE1BF,QAAWK,UAOZgG,yBAAyBrG,OAAQK,mCACvB,kBAAmB,oBAAoBT,MAAM+C,oCACtCD,gBAAgB,CACzBC,QAASA,QACTC,KAAM,eAEX9C,OAAM,+BACQ4C,gBAAgB,CACzBC,QAAS,iEACTC,KAAM,uBAKC,UAAfwD,WAAwB,OAClBjF,SAAU,kBAAG,8BAA6BnB,cAC5CyF,MAAQtE,QAAQjB,KAAK,gBACpBwF,MAAMC,QAAQF,SACfA,MAAQ,UAENS,YAAc/E,QAAQjB,KAAK,sBAC7BgG,aACAT,MAAMU,KAAKD,aAEf/E,QAAQjB,KAAK,eAAgBuF,OAC7BtE,QAAQjB,KAAK,cAAeG,QAC5Bc,QAAQjB,KAAK,eAAgB,eAC7BgF,eAAelF,OAAQK,QAGtBkC,KAOL+D,qBAAqB/D,KAAMvC,OAAQK,OAAQiC,kCAN1BI,gBAAgB,CACzBC,QAAS,uCACTC,KAAM,yCAvCGF,gBAAgB,CACzBC,QAAS,uCACTC,KAAM,gCA6ChBV,UAAUC,GAAG,QAAS,8EAA8E,SAASC,GAC3GA,EAAEC,iBACFD,EAAE0D,wBACInB,KAAM,kBAAE1F,MAAMwD,QAAQ,gCACxBkC,IAAIhG,QACJgG,IAAI4B,QAAQ,+BAKlBrE,UAAUC,GAAG,QAAS,6BAA6B,SAASC,GAC1DA,EAAEC,uBACIC,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCqC,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,QAEvCsG,aAAevG,SAASqC,OAAOpC,KAAK,gBAAiB,IACpDsG,eAAgBtF,MAAMsF,gBAEvBA,aAAevD,eAAejD,SAG7BA,QAAWuC,MAASiE,aAOrBH,yBAAyBrG,OAAQwG,yCACvB,kBAAmB,oBAAoB5G,MAAM+C,oCACtCD,gBAAgB,CACzBC,QAASA,QACTC,KAAM,eAEX9C,OAAM,+BACQ4C,gBAAgB,CACzBC,QAAS,iEACTC,KAAM,eAMlB0D,qBAAqB/D,KAAMvC,OAAQwG,aAAclE,kCArBhCI,gBAAgB,CACzBC,QAAS,yCACTC,KAAM,gCAuBhBV,UAAUC,GAAG,QAAS,oBAAoB,SAASC,GACjDA,EAAEC,uBACIC,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCqC,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,IACtCF,QAAWuC,KAOhBkE,cAAclE,KAAMvC,kCANH0C,gBAAgB,CACzBC,QAAS,uCACTC,KAAM,gCAQhBV,UAAUC,GAAG,QAAS,4BAA4B,SAASC,GACzDA,EAAEC,uBACIC,QAAS,kBAAErD,MACXe,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCqC,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,QACtCF,SAAWuC,2CACCG,gBAAgB,CACzBC,QAAS,+CACTC,KAAM,gBAMRI,YAAcC,eAAejD,QAC7BwC,WAAY,kBAAG,2CAA0CxC,YACzD0G,SAAWlE,UAAUtC,KAAK,aAAe,aAGzCyG,OAAS,IAAIlG,mBACnBkG,OAAOC,OAAO,SAAU,uBACxBD,OAAOC,OAAO,OAAQrE,MACtBoE,OAAOC,OAAO,SAAU5G,QACxB2G,OAAOC,OAAO,UAAWC,oBAAOC,SAEf,UAAbJ,UAAwB1D,YACxB2D,OAAOC,OAAO,UAAW5D,kBACtB,GAAiB,eAAb0D,SAA2B,OAE5BK,eAAiBvE,UAAUtC,KAAK,wBAClC6G,gBACAJ,OAAOC,OAAO,kBAAmBG,gBAKzCrG,OAAOsG,KAAKH,oBAAOI,QAAU,8BAAgCN,OAAOxC,WAAY,aAGpF5F,wBAAyB,EA5bzB2I,iBAmcI5I,iDAIF4D,UAAUC,GACR,QACA,oHACA,SAASC,GACLA,EAAEC,iBACFD,EAAE0D,wBAEIxD,QAAS,kBAAErD,MACXoB,OAASJ,SAASqC,OAAOpC,KAAK,WAAY,IAC1CF,OAASC,SAASqC,OAAOpC,KAAK,UAAW,IACzCqC,KAAOtC,SAASqC,OAAOpC,KAAK,QAAS,QAEtCG,SAAWL,SAAWuC,2CACVG,gBAAgB,CACzBC,QAAS,2CACTC,KAAM,gBAKRuE,oBAAsB7E,OAAOG,QAAQ,iCACR,IAA/B0E,oBAAoBxI,oBAIlByI,UAAYC,+BAA+BF,wBACX,IAAlCG,OAAOC,KAAKH,WAAWzI,6CACV+D,gBAAgB,CACzBC,QAAS,iEACTC,KAAM,eAKR4E,aAAelF,OAAOmF,OAC5BnF,OAAOvD,KAAK,YAAY,GACxBuD,OAAOmF,KAAK,aACZC,4BAA4BnF,KAAMvC,OAAQK,OAAQ+G,UAAW9E,OAAQkF,iBAI7ElJ,wBAAyB,EA/ezBqJ,GACAvJ,kBAAmB,IAGVwJ,KAAO,IAAMjI,sCACbkI,UAAY,IAAMlI,gDA6ezB0H,+BAAkCF,4BAC9BC,UAAY,UAElBD,oBAAoBtI,KAAK,qBAAqBG,MAAK,iBACzCmG,MAAO,kBAAElG,MACT6I,SAAyD,MAA9CC,OAAO5C,KAAKH,KAAK,yBAC5BgD,UAA2D,MAA/CD,OAAO5C,KAAKH,KAAK,6BAC/B8C,WAAaE,uBAIXC,WAAa9C,KAAKjF,KAAK,cACvBgI,aAAe/C,KAAKjF,KAAK,oBAC3BiI,cAAgB,QAEC,mBAAjBD,aAAmC,OAC7BE,QAAUjD,KAAKtG,KAAM,wBAAuBoJ,+BAC5CI,OAAS,GACfD,QAAQpJ,MAAK,WACTqJ,OAAOlC,MAAK,kBAAElH,MAAMQ,UAExB0I,cAAgBE,OAAO1J,OAAS,EAAI2J,KAAKC,UAAUF,QAAU,UAC1D,GAAqB,WAAjBH,aAA2B,OAC5BM,SAAWrD,KAAKtG,KAAM,yBAAwBoJ,qBACpDE,cAAgBK,SAAS7J,OAAS,EAAI6J,SAAS/I,MAAQ,UACpD,GAAqB,iBAAjByI,cAAoD,WAAjBA,aAA2B,OAC/DM,SAAWrD,KAAKtG,KAAM,wBAAuBoJ,6BACnDE,cAAgBK,SAAS7J,OAAS,EAAI6J,SAAS/I,MAAQ,UACpD,GAAqB,WAAjByI,cAA8C,cAAjBA,aAA8B,OAC5DrF,MAAQsC,KAAKtG,KAAM,wBAAuBoJ,qBAChDE,cAAgBtF,MAAMlE,OAAS,EAAIkE,MAAMpD,MAAQ,UAC9C,GAAqB,aAAjByI,aAA6B,OAC9BO,SAAWtD,KAAKtG,KAAM,2BAA0BoJ,qBACtDE,cAAgBM,SAAS9J,OAAS,EAAI8J,SAAShJ,MAAQ,KAGrC,OAAlB0I,eAA4C,KAAlBA,gBAC1Bf,UAAUa,YAAcE,kBAIzBf,WAGLM,4BAA8B,CAACnF,KAAMvC,OAAQK,OAAQ+G,UAAW9E,OAAQkF,sBACpEkB,QAAUpB,OAAOoB,QAAQtB,eAC3BuB,YAAc,EAEdC,aAAeC,QAAQC,UAC3BJ,QAAQK,SAAQC,WAAEf,WAAYgB,eAC1BL,aAAeA,aAAahJ,MAAK,WACvB+G,OAAS,IAAIlG,gBAAgB,CAC/ByI,OAAQ,gBACR3G,KAAMA,KACNvC,OAAQA,OACRmJ,WAAYlB,WACZgB,SAAUA,SACVG,QAAS/I,OACTyG,QAASD,oBAAOC,iBAGbuC,MAAMxC,oBAAOI,QAAU,8BAAgCN,OAAOxC,WAAY,CAC7EmF,OAAQ,MACRC,QAAS,gBACW,sBAGvB3J,MAAM4J,KAAQA,IAAIC,SAClB7J,MAAMM,OACEA,KAAKwJ,SACNf,iBAGP7I,OAAM,KACH6I,uBAKZC,aAAahJ,MAAK,KACd0C,OAAOvD,KAAK,YAAY,GACxBuD,OAAOmF,KAAKD,cAEQ,IAAhBmB,sCACajG,gBAAgB,CACzBC,QAAS,mBACTC,KAAM,sCAGGF,gBAAgB,CACzBC,QAAS,iCACTC,KAAM,YAIdb,4BAA4B/B,OAAQK,YAUtC8C,eAAkBnD,QACbO,0BAAaP,SAAW,+CAS7BiD,eAAkBjD,eACdwC,WAAY,kBAAG,uBAAsBxC,UAAUyC,QAAQ,qCACtDxC,SAASuC,UAAUtC,KAAK,iBAAmBiD,eAAenD,QAAS,kDASxEqF,kBAAoB,SAACrF,YAAQ2J,oEAAe,WACxCC,KAAwB,OAAjBD,aAAwB1J,SAAS0J,aAAc,IAAM1G,eAAejD,YAC5E4J,MAAQ1I,MAAM0I,mBAIbzI,SAAU,kBAAG,8BAA6BnB,UAC1C6J,WAAa5J,SAASkB,QAAQjB,KAAK,eAAgB,IACnD4J,SAAW3I,QAAQjB,KAAK,gBAExBM,UAAY,IAAIC,gBAAgBC,OAAOC,SAASC,QACtDJ,UAAUuJ,IAAI,OAAQH,MAElBE,UAAyB,SAAbA,UAAuBD,aAAe3I,MAAM2I,YACxDrJ,UAAUuJ,IAAI,SAAUF,YAExBrJ,UAAUwJ,OAAO,gBAGfC,OAASvJ,OAAOC,SAASuJ,SAAW,IAAM1J,UAAU2D,WAC1DzD,OAAOyJ,QAAQC,aAAa,GAAI,GAAIH,SASlC5I,eAAiB,CAACrB,OAAQ4J,cACtBpH,WAAY,kBAAG,uBAAsBxC,UAAUyC,QAAQ,8BAC7DD,UAAUtC,KAAK,eAAgB0J,MAC/BpH,UAAUwC,KAAK,oBAAqB4E,MACpCvE,kBAAkBrF,OAAQ4J,oDAQxBtI,kBAAqBtB,eACjBgD,YAAcC,eAAejD,QAC7BqK,OAAQ,kBAAG,uBAAsBrK,UACnCqK,MAAM1L,OAAS,GACf0L,MAAM5C,KAAKzE,iEAWbsH,gBAAkB,CAACtK,OAAQK,UACH,kBAAG,uBAAsBL,UAC1BnB,KAAM,0BAAyBwB,YAAY1B,OAAS,EAU3E8E,eAAiB,CAACzD,OAAQK,gBAEtBkK,cADoB,kBAAG,uBAAsBvK,UACZnB,KAAM,0BAAyBwB,eAC1C,IAAxBkK,aAAa5L,cACN,QAGL6L,KADcD,aAAaE,OACRvK,KAAK,cACd,cAATsK,MAAiC,OAATA,mDAU7BhH,4BAA8B,CAACxD,OAAQK,gBACnCiF,KAAOC,+BAAkBvF,YAC1BsF,OAASA,KAAKE,QAAUnF,cAClB,WAELqK,MAAO,gCAAgBpF,KAAKE,MAAOnF,eACpCqK,MAGE,2BAAWA,MAFP,MAaT/I,qBAAuB,CAAC3B,OAAQK,gBAC5BF,mBAAoB,kBAAG,uBAAsBH,UAE7C2K,oBAAiE,IAA5CxK,kBAAkBD,KAAK,iBAG5CoF,KAAOC,+BAAkBvF,QACzB0K,KAAOpF,MAAO,gCAAgBA,KAAKE,OAAS,GAAInF,QAAU,KAC1DuK,eAAiB,IAAIC,OAC3BD,eAAeE,IAAIzK,QAEfqK,KAAM,OAEAK,QAAU,CAAChG,KAAMiG,SAAUC,WACzBhL,SAAS8E,KAAKqE,QAAS,MAAQnJ,SAAS+K,SAAU,WAElDC,KAAKlC,SAAQmC,IAAMN,eAAeE,IAAII,MACtCN,eAAeE,IAAI7K,SAAS8E,KAAKqE,QAAS,MACnC,KAGPrE,KAAKoG,oBACA,MAAMC,MAAMrG,KAAKoG,mBACdJ,QAAQK,GAAIJ,SAAU,IAAIC,KAAMhL,SAAS8E,KAAKqE,QAAS,aAChD,KAKfrE,KAAKkB,aACA,MAAMoF,SAAStG,KAAKkB,YACjB8E,QAAQM,MAAOL,SAAU,IAAIC,KAAMhL,SAAS8E,KAAKqE,QAAS,aACnD,SAIZ,GAEX2B,QAAQL,KAAMrK,OAAQ,SAItBuK,eAAeE,IAAIzK,QAMvBF,kBAAkBtB,KAAK,YAAYG,MAAK,iBAC9BsM,MAAO,kBAAErM,MACTsM,cAAgBtL,SAASqL,KAAKpL,KAAK,WAAY,QAEhDqL,eAAiBrK,MAAMqK,2BAExBD,KAAKE,YAAY,yBAAyBC,aAIxCC,cAAgBH,gBAAkBtL,SAASI,OAAQ,IACrCuK,eAAee,IAAIJ,eAI/BG,cAEAJ,KAAKE,YAAY,yBAAyBhK,QAG1C8J,KAAK7J,SAAS,yBACVkJ,mBACAW,KAAK9J,OAEL8J,KAAKG,QAKbH,KAAKE,YAAY,yBAAyBC,UAKlDtL,kBAAkBtB,KAAK,mBAAmBG,MAAK,iBACrC4M,YAAa,kBAAE3M,MACf4M,gBAAkB5L,SAAS2L,WAAW1L,KAAK,kBAAmB,QAE/D2L,iBAAmB3K,MAAM2K,6BAC1BD,WAAWH,OAIKb,eAAee,IAAIE,iBAEnCD,WAAWpK,OAEXoK,WAAWH,gBAKbK,WAAY,kBAAG,8CAA6C9L,eAC9D8L,UAAUnN,OAAS,EAAG,IACMwB,kBAAkBtB,KAAK,0BAA0BF,OAAS,EAC7D,CACrBmN,UAAUtK,OACVsK,UAAU/M,KAAK,YAAY,SAErBgN,UADgB5L,kBAAkBtB,KAAK,0BAA0BW,QACvCwM,GAAG,YACnCC,0BAA0BH,UAAWC,gBAGrCD,UAAUL,OAKlB5J,YAAW,qCACQ7B,UAChB,KAQDuB,oBAAuBvB,eACnBgD,YAAcC,eAAejD,QAC7BkD,YAAcC,eAAenD,QAE7BoD,eAAiBnD,SAAS+C,YAAa,IACvCkJ,eAAiBjM,SAASiD,YAAa,IACvCL,OAAQ,kBAAG,oBAAmB7C,UAC9BmM,SAAU,kBAAG,+BAA8BnM,YAC3CoM,aAAc,kBAAG,wBAAuBpM,UAExCqD,SADYR,MAAMJ,QAAQ,8BACLvC,KAAK,aAC1BoD,YAAeD,MAAAA,SAA+CpD,SAASoD,SAAU,IAAM,KACvFgJ,sBAAwB7I,4BAA4BxD,OAAQoD,gBAC5DkJ,oBAAsC,OAAhBhJ,aACE,OAA1B+I,uBACAA,uBAAyB/I,eAEzBF,eAAiB8I,eAAgB,CAEjCrJ,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,GACrBqN,YAAYzN,OAAS,GACrByN,YAAY5K,aAGV+K,uBAAwB,kBAAG,4BAA2BvM,UACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsBd,YAEvB,GAAIrI,iBAAmB8I,gBAAkBzI,eAAezD,OAAQoD,mBAG/DkJ,qBAAuBhC,gBAAgBtK,OAAQoD,gBAAiB,CAEhEP,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,GACzB8D,MAAMpD,IAAI,IACN2M,YAAYzN,OAAS,8BACX,kBAAmB,oBAAoBiB,MAAMC,MACnDuM,YAAY3E,KAAK5H,KAAK2B,gBAIxB+K,uBAAwB,kBAAG,4BAA2BvM,UACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsBd,WAEvB,CAEH5I,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,GACzB8D,MAAMpD,IAAI,IACN2M,YAAYzN,OAAS,GACrByN,YAAYX,aAGVc,uBAAwB,kBAAG,4BAA2BvM,UACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsB/K,YAG3B,GAAI4B,iBAAmB8I,gBAAmBzI,eAAezD,OAAQoD,gBAwCjE,CAEHP,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,SAEnBwN,uBAAwB,kBAAG,4BAA2BvM,UACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsBd,OAEtBW,YAAYzN,OAAS,GACrByN,YAAYX,WAlDqE,IAGjFa,qBAAuBhC,gBAAgBtK,OAAQoD,gBAAiB,CAEhEP,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,GACzB8D,MAAMpD,IAAI,IACN2M,YAAYzN,OAAS,8BACX,kBAAmB,oBAAoBiB,MAAMC,MACnDuM,YAAY3E,KAAK5H,KAAK2B,gBAIxB+K,uBAAwB,kBAAG,4BAA2BvM,sBACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsBd,SAMd,kBAAG,sBAAqBzL,UAC5BgM,GAAG,aAEXnJ,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,KAGzB8D,MAAM9D,KAAK,YAAY,GACvBoN,QAAQpN,KAAK,YAAY,UAGvBwN,uBAAwB,kBAAG,4BAA2BvM,UACxDuM,sBAAsB5N,OAAS,GAC/B4N,sBAAsBd,OAEtBW,YAAYzN,OAAS,GACrByN,YAAYX,SA4BlBlH,YAAc,CAAChC,KAAMvC,OAAQ2C,QAASgB,QAASrB,OAAQO,MAAOyB,iBAE1DtB,YAAcC,eAAejD,QAE7B2G,OAAS,IAAIlG,gBAAgB,CAC/ByI,OAAQ,kBACR3G,KAAMA,KACNvC,OAAQA,OACR2C,QAASA,QACTgB,QAASA,QACTmD,QAASD,oBAAOC,UAIhB9D,aACA2D,OAAOC,OAAO,UAAW5D,aAG7BqG,MAAMxC,oBAAOI,QAAU,8BAAgCN,OAAOxC,WAAY,CACtEmF,OAAQ,MACRC,QAAS,gBACW,sBAGvB3J,MAAKqJ,eACGA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAKM,OACFoE,QAAQmH,OAEJvL,KAAKwJ,QAEDxJ,KAAKyM,WAAazM,KAAK0M,QAGvBC,iBAAiB7M,OAAQE,KAAK0M,QAAS1M,KAAKyM,UAAWzM,KAAKkJ,SAASxJ,MAAK,QAElEM,KAAKkJ,QAAS,OACRlG,YAAcC,eAAenD,SAC/BE,KAAKkJ,QAAUlG,aAKRhD,KAAKkJ,UAAYlG,YAAc,+BAJzBlD,QAAUE,KAAKkJ,QAC5B9H,kBAAkBtB,QAElBqB,eAAerB,OAAQE,KAAKkJ,UAYpCvH,YAAW,KACPN,oBAAoBvB,UACrB,QACJF,OAAM,KAEL+B,YAAW,KACPN,oBAAoBvB,UACrB,mCAGM0C,gBAAgB,CACzBC,QAAS,sDACTC,KAAM,UAGVC,MAAM9D,KAAK,YAAY,GACvBuD,OAAOvD,KAAK,YAAY,GACxB8D,MAAMiK,oCAGGpK,gBAAgB,CACzBC,QAASzC,KAAKyC,SAAW,wBACzBC,KAAM,UAGVC,MAAM9D,KAAK,YAAY,GACvBuD,OAAOvD,KAAK,YAAY,GACxB8D,MAAMiK,YAGbhN,OAAMkC,QACHsC,QAAQmH,OAERxJ,QAAQD,MAAM,yBAA0BA,iCAC3BU,gBAAgB,CACzBC,QAAS,0BAA4BX,MAAMW,QAC3CC,KAAM,UAEVC,MAAM9D,KAAK,YAAY,GACvBuD,OAAOvD,KAAK,YAAY,GACxB8D,MAAMiK,YAWRzI,mBAAqB,CAACrE,OAAQ2C,QAASgK,mBACnCxM,mBAAoB,kBAAG,uBAAsBH,UAClB,IAA7BG,kBAAkBxB,SAGtBwB,kBAAkBtB,KAAK,2BAA2BC,gCACxCiO,OAAO,qCAAsC,CACnD7B,GAAIyB,UACJC,QAASjK,QACTqK,YAAa/I,KAAKgJ,MAAMlJ,KAAKC,MAAQ,OACtCpE,MAAMsN,OACL/M,kBAAkByG,OAAOsG,sCACVlN,WAChBF,MAAMqN,0BAAaC,aAYpBP,iBAAmB,CAAC7M,OAAQ4M,QAASD,UAAWtM,gBAC5CF,mBAAoB,kBAAG,uBAAsBH,iBAClB,IAA7BG,kBAAkBxB,OACXkK,QAAQC,UAEZuE,uBAAUN,OAAO,mCAAoC,CACxD7B,GAAIyB,UACJC,QAASA,QACTI,YAAa/I,KAAKgJ,MAAMlJ,KAAKC,MAAQ,KACrCoF,QAAS/I,SACVT,MAAMsN,OACL/M,kBAAkByG,OAAOsG,sCACVlN,QACRkN,QACRpN,MAAMqN,0BAAaC,YAkBpBtL,sCAAwC,CAAC9B,OAAQK,gBAG7CiN,kBAAmB,kBAAG,wCAAuCtN,aACnC,IAA5BsN,iBAAiB3O,cAEVkK,QAAQC,gBAGbyE,kBAAoBD,iBAAiBzO,KAAM,4CAA2CwB,mBACxFkN,kBAAkB5O,OAAS,GAAK4O,kBAAkB1O,KAAK,kBAAkBF,OAAS,EAE3EkK,QAAQC,WAIZ,0BAAU,UAAW,UAAUlJ,MAAM4N,aAExCF,iBAAiBJ,KAAK,kFAClBM,WAAa,gBAEX7G,OAAS,IAAIlG,gBAAgB,CAC/ByI,OAAQ,qBACRlJ,OAAQA,OACRoJ,QAAS/I,OACTkC,MAAM,kBAAG,uBAAsBvC,UAAUyC,QAAQ,8BAA8BvC,KAAK,QACpF4G,QAASD,oBAAOC,iBAGbuC,MAAMxC,oBAAOI,QAAU,8BAAgCN,OAAOxC,WAAY,CAC7EmF,OAAQ,MACRC,QAAS,gBACW,sBAGvB3J,MAAKqJ,eACGA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAKM,OACEA,KAAKwJ,SAAWxJ,KAAKgN,KACrBI,iBAAiBJ,KAAKhN,KAAKgN,MAE3BI,iBAAiBJ,KAAK,6CACjBhN,KAAKyC,SAAW,yCAA2C,aAGvE7C,OAAOkC,QAEJC,QAAQD,MAAM,2CAA4CA,OAC1DsL,iBAAiBJ,KAAK,sEACYlL,MAAMW,QAAU,iBAWxDZ,4BAA8B,CAAC/B,OAAQK,gBACnCkC,MAAO,wBAAQvC,YAChBuC,kBAIC+K,kBAAmB,kBAAG,wCAAuCtN,aACnC,IAA5BsN,iBAAiB3O,kBAGjB6D,UAAY8K,iBAAiBzO,KAAM,4CAA2CwB,YACzD,IAArBmC,UAAU7D,SACV6D,UAAY8K,kBAEhB9K,UAAU3D,KAAK,kBAAkBG,MAAK,WAClCP,4BAA2B,kBAAEQ,gBAG3B0H,OAAS,IAAIlG,gBAAgB,CAC/ByI,OAAQ,qBACR3G,KAAMA,KACNvC,OAAQA,OACRoJ,QAAS/I,OACTyG,QAASD,oBAAOC,UAGpBuC,MAAMxC,oBAAOI,QAAU,8BAAgCN,OAAOxC,WAAY,CACtEmF,OAAQ,MACRC,QAAS,gBACW,sBAGvB3J,MAAKqJ,eACGA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAKM,OACGA,KAAKwJ,SAAYxJ,KAAKkH,WAAoD,IAAvCE,OAAOC,KAAKrH,KAAKkH,WAAWzI,QAGpE2I,OAAOC,KAAKrH,KAAKkH,WAAW2B,SAASd,mBAC3BwF,aAAevN,KAAKkH,UAAUa,YAC9BvJ,aAAe8D,UAAU3D,KAAM,mCAAkCoJ,mBAC3C,IAAxBvJ,aAAaC,oBAGXuJ,aAAexJ,aAAawB,KAAK,gBACjCwN,MAAQD,aAAaxE,YAEN,iBAAjBf,cAAoD,WAAjBA,aACnCxJ,aAAaG,KAAK,uBAAuBE,KAAK,WAAW,GACzDL,aAAaG,KAAM,8BAA6B6O,WAAW3O,KAAK,WAAW,QACxE,GAAqB,mBAAjBmJ,aAAmC,CAC1CxJ,aAAaG,KAAK,0BAA0BE,KAAK,WAAW,aAElDsJ,OAASC,KAAKqF,MAAMD,OACtBhI,MAAMC,QAAQ0C,SACdA,OAAOU,SAAStJ,MACZf,aAAaG,KAAM,iCAAgCY,SAASV,KAAK,WAAW,MAGtF,MAAOqD,SAGe,WAAjB8F,aACPxJ,aAAaG,KAAK,UAAUY,IAAIiO,OACR,WAAjBxF,aACPxJ,aAAaG,KAAK,wBAAwBY,IAAIiO,OACtB,cAAjBxF,aACPxJ,aAAaG,KAAK,sBAAsBY,IAAIiO,OACpB,aAAjBxF,cACPxJ,aAAaG,KAAK,YAAYY,IAAIiO,OAGlCD,aAAaG,2CACH,QAAS,oBAAoBhO,MAAMiO,uCAC/B,KAAM,oBAAoBjO,MAAMkO,eAChCC,KAAO,4DACTC,aAAetP,aAAaG,KAAK,8BACT,IAAxBmP,aAAarP,OAAc,OACrBsP,YACD,6DAAEF,QAAQF,aAAaC,UAAUL,aAAaG,uBACnDlP,aAAakI,OAAOqH,kBAEpBD,aAAad,KAAM,GAAEa,QAAQF,aAAaC,UAAUL,aAAaG,wBAx6CnElP,CAAAA,eACtBA,aAAasG,KAAK,uBAAwB,KAC1CtG,aAAaE,WAAW,yBACxBF,aAAaG,KAAK,2BAA2BE,KAAK,YAAY,IA26CtDmP,CAAiBxP,cAx6CHA,CAAAA,mBAClByP,SAAWzP,aAAaG,KAAK,2BACT,IAApBsP,SAASxP,SACTwP,UAAW,kBAAE,mDACbzP,aAAakI,OAAOuH,eAEpB7L,OAAS6L,SAAStP,KAAK,sBACL,IAAlByD,OAAO3D,SACP2D,QAAS,kBAAE,8FACX6L,SAASvH,OAAOtE,SAEpBA,OAAOmF,KAAKjJ,WACZ8D,OAAOd,QA65CC4M,CAAiB1P,yCAEP,gBAAiB,oBAAoBkB,MAAMyO,kBAC7ClE,QAAUzL,aAAaG,KAAK,uBAC3BsL,QAAQxL,QAAU8O,aAAaa,cAAgB,EAAG,OAC7CC,SAAU,kBAAE,mDAClBA,QAAQ3H,OAAQ,YAAWyH,gBAAgBZ,aAAaa,4BACxDC,QAAQ3H,OAAO,6CACflI,aAAakI,OAAO2H,SACpBpE,QAAUoE,WAEVpE,QAAQxL,OAAQ,OACV6P,KAAOrE,QAAQtL,KAAK,MAC1B2P,KAAKC,SACJhB,aAAaiB,eAAiB,IAAI3F,SAAS5D,OACxCqJ,KAAK5H,OAAQ,6CAA4CzB,KAAKwJ,iBAAiBxJ,KAAK8D,oBAExFkB,QAAQtL,KAAK,WAAW4I,KAAM,GAAE4G,gBAAgBZ,aAAaa,eAAiB,OACzEb,aAAaa,eAAiB,GAAK,EACpCnE,QAAQ3I,OAER2I,QAAQsB,iBAM3B3L,OAAOkC,QAEJC,QAAQD,MAAM,gCAAiCA,WAUjD4M,wBAA0B,CAAC5O,OAAQK,gBAC/BiN,kBAAmB,kBAAG,wCAAuCtN,aACnC,IAA5BsN,iBAAiB3O,kBAGjB6D,UAAY8K,iBAAiBzO,KAAM,4CAA2CwB,YACzD,IAArBmC,UAAU7D,SACV6D,UAAY8K,kBAEhB9K,UAAU3D,KAAK,kBAAkBG,MAAK,WAClCP,4BAA2B,kBAAEQ,WAI/BoH,yBAA2B,CAACrG,OAAQK,gBAChCiN,kBAAmB,kBAAG,wCAAuCtN,aACnC,IAA5BsN,iBAAiB3O,cACV,QAEL6D,UAAY8K,iBAAiBzO,KAAM,4CAA2CwB,eAC3D,IAArBmC,UAAU7D,cACH,QAELkQ,kBAAoBrM,UAAU3D,KAAK,wCACR,IAA7BgQ,kBAAkBlQ,cACX,SAEWkQ,kBAAkBvP,QAAO,kBACpC,kBAAEL,MAAMJ,KAAK,2BAA2BF,OAAS,KACzDA,SACsBkQ,kBAAkBlQ,QAezCuG,eAAiB,SAAClF,OAAQK,YAAQyO,qEAEhCA,yCACa9O,QAAUK,QAG3BgB,eAAerB,OAAQK,QAEvBiB,kBAAkBtB,QAClBuB,oBAAoBvB,cAGdG,mBAAoB,kBAAG,uBAAsBH,UACnDG,kBAAkBtB,KAAK,mBAAmBG,MAAK,iBACrC6M,iBAAkB,kBAAE5M,MAAMiB,KAAK,qBACjC2L,iBACI5L,SAAS4L,gBAAiB,IAAMxL,OAAQ,oBACtCpB,MAAMiB,KAAK,aAAa,SACpB6O,YAAa,kBAAE9P,MAAMJ,KAAK,oBAAoBA,KAAK,qBACrDkQ,WAAWpQ,OAAS,GACpBoQ,WAAWvD,YAAY,iBAAiB/J,SAAS,uBAMjEE,qBAAqB3B,OAAQK,QAC7BuB,wBAAwB5B,QACxB8B,sCAAsC9B,OAAQK,QAAQT,MAAK,KACvDgP,wBAAwB5O,OAAQK,QAChC0B,4BAA4B/B,OAAQK,iBAElCc,SAAU,kBAAG,8BAA6BnB,UAC5CmB,QAAQxC,SACRwC,QAAQjB,KAAK,eAAgB,UAC7BwB,qBAAqB1B,uDASvB4B,wBAA2B5B,eACvBgD,YAAcC,eAAejD,QAC7BgP,mBAAoB,kBAAG,uBAAsBhP,UAElB,IAA7BgP,kBAAkBrQ,QAKtBqQ,kBAAkBnQ,KAAK,iBAAiBG,MAAK,iBACnCiQ,UAAW,kBAAEhQ,MACbiQ,eAAiBD,SAAS/O,KAAK,mBAC/BiP,WAAaF,SAAS/O,KAAK,mBAE7BkP,YAAa,SAETF,oBACC,YACDE,YAAa,YAEZ,aACDA,WAA8B,IAAhBpM,sBAEb,gBACDoM,WAAcpM,cAAgBmM,yBAG9BC,YAAa,EAGjBA,YACAH,SAASI,UAAU,KAEnBC,gCAAgCL,SAAUjM,cAE1CiM,SAASM,QAAQ,SAWvBD,gCAAkC,CAACL,SAAUjM,eAC/CiM,SAASpQ,KAAK,kBAAkBG,MAAK,iBAC3BwQ,WAAY,kBAAEvQ,MACdiQ,eAAiBM,UAAUtP,KAAK,oBAAsB,YACtDiP,WAAaK,UAAUtP,KAAK,mBAE9BkP,YAAa,SAETF,oBACC,oBAUDE,YAAa,YAPZ,aACDA,WAA8B,IAAhBpM,sBAEb,gBACDoM,WAAcpM,cAAgBmM,WAMlCC,WACAI,UAAUH,UAAU,KAEpBG,UAAUD,QAAQ,SAWxB7N,qBAAwB1B,eACpByP,eAAgB,kBAAG,sBAAqBzP,UACxCmB,SAAU,kBAAG,8BAA6BnB,aAEnB,IAAzByP,cAAc9Q,cAEdsD,QAAQyN,KAAK,uCAAwC1P,QAC9C6I,QAAQC,QAAQ,YAIrBvG,MAAO,wBAAQvC,YAChBuC,YAEDN,QAAQD,MAAM,6BAA8BhC,QAC5CyP,cAAcvC,KAAK,qHAEZrE,QAAQC,QAAQ,YAGrBnC,OAAS,IAAIlG,uBACnBkG,OAAOC,OAAO,SAAU,yBACxBD,OAAOC,OAAO,OAAQrE,MACtBoE,OAAOC,OAAO,SAAU5G,QACxB2G,OAAOC,OAAO,UAAWC,oBAAOC,SAEzBuC,MAAMxC,oBAAOI,QAAU,6BAA8B,CACxDqC,OAAQ,OACRC,QAAS,gBACW,qCAEpBoG,KAAMhJ,OAAOxC,aAEhBvE,MAAMqJ,eACEA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAMM,UAEH+B,QAAQ2N,IAAI,8BAA+B1P,MAEvCA,KAAKwJ,SAAWxJ,KAAKoF,KAAM,CAE3BpF,KAAKoF,KAAKE,OAAStF,KAAKoF,KAAKE,OAAS,IAAIqK,KAAI,CAACnF,KAAMoF,WAC9CpF,KACHqF,oBAAqBD,IAAM,qCAGb9P,QAAUE,KAAKoF,WAE3BtC,YAAcC,eAAejD,QAC7B8J,SAAW3I,QAAQjB,KAAK,gBACxB8P,aAAe7O,QAAQjB,KAAK,kBAC7B4J,UAAyB,SAAbA,SAEV,OACGY,KAAOsF,aAAehK,iBAAiB9F,KAAKoF,KAAKE,OAAS,GAAIwK,eAChE,gCAAgB9P,KAAKoF,KAAKE,OAAS,GAAIxC,aACvC0H,KACAuF,yBAAyBjQ,OAAQ0K,8CAEV1K,OAAQE,KAAKoF,KAAKE,mDAPtBxF,OAAQE,KAAKoF,KAAKE,OAU7CH,kBAAkBrF,OAAQgD,aAI1BrB,qBAAqB3B,OAAQgD,mBAGvBkN,QAAU/O,QAAQtC,KAAK,uBACzBqR,QAAQvR,OAAQ,OACVmL,SAAW3I,QAAQjB,KAAK,gBACzB4J,UAAyB,SAAbA,SAGboG,QAAQzE,OAFRyE,QAAQ1O,cAMTtB,KAAKoF,YAGZmK,cAAcvC,KAAK,mDACdhN,KAAKyC,SAAW,uCAAyC,UACvD,QAGd7C,OAAOkC,QAEJC,QAAQD,MAAM,mCAAoCA,OAClDyN,cAAcvC,KAAK,oFACuBlL,MAAMW,QAD7B,gFAGZ,kEAOTwN,mBAAqB,CAACnQ,OAAQK,gBAC1BiF,KAAOC,+BAAkBvF,YAC1BsF,OAASA,KAAKE,aACR,WAGLkF,MAAO,gCAAgBpF,KAAKE,MAAOnF,YACpCqK,YACM,WAGL0F,cAAgB,CAACrL,KAAMiG,SAAUqF,aAAcC,mBAC3CC,YAAa,oCAAoBxL,KAAMuL,UAAWD,iBAEpDpQ,SAAS8E,KAAKqE,QAAS,MAAQnJ,SAAS+K,SAAU,WAC3CuF,cAIPxL,KAAKoG,iBAAmBpG,KAAKoG,gBAAgBxM,OAAS,EAAG,OAEnD6R,SAAW,IAAIzL,KAAKoG,iBAAiBsF,MAAK,CAACC,EAAGC,IAChD1Q,SAASyQ,EAAEtH,QAAS,IAAMnJ,SAAS0Q,EAAEvH,QAAS,UAE9CwH,UAAYN,UAAY,MACvB,MAAMlF,MAAMoF,SAAU,OACjBK,UAAW,oCAAoBzF,GAAIwF,UAAW,SAChD3Q,SAASmL,GAAGhC,QAAS,MAAQnJ,SAAS+K,SAAU,WACzC6F,YAGPzF,GAAGnF,UAAYmF,GAAGnF,SAAStH,OAAS,EAAG,OACjCmS,eAAiB,IAAI1F,GAAGnF,UAAUwK,MAAK,CAACC,EAAGC,IAC7C1Q,SAASyQ,EAAEtH,QAAS,IAAMnJ,SAAS0Q,EAAEvH,QAAS,UAE7C,IAAI2H,EAAI,EAAGA,EAAID,eAAenS,OAAQoS,IAAK,OACtCC,MAAQZ,cAAcU,eAAeC,GAAI/F,SAAU6F,SAAUE,MAC/DC,aACOA,OAInBJ,gBAKJ7L,KAAKkB,UAAYlB,KAAKkB,SAAStH,OAAS,EAAG,OACrCmS,eAAiB,IAAI/L,KAAKkB,UAAUwK,MAAK,CAACC,EAAGC,IAC/C1Q,SAASyQ,EAAEtH,QAAS,IAAMnJ,SAAS0Q,EAAEvH,QAAS,UAE7C,IAAI2H,EAAI,EAAGA,EAAID,eAAenS,OAAQoS,IAAK,OACtCC,MAAQZ,cAAcU,eAAeC,GAAI/F,SAAUuF,WAAYQ,MACjEC,aACOA,cAKZ,aAIJZ,cAAc1F,KAAMrK,OAAQ,KAAM,IAMvC4Q,gBAAkB,SAAClM,KAAMmM,MAAOC,cAAenR,OAAQuC,UAAM+N,iEAAY,EAAGD,oEAAe,KAC7Fe,2EAAwBC,wEAAmB,WACrCC,UAAYrR,SAAS8E,KAAKqE,QAAS,MAAQnJ,SAASkR,cAAe,IACnEI,YAAcxM,KAAKkB,UAAYlB,KAAKkB,SAAStH,OAAS,EACtD6S,eAAiBzM,KAAK0M,mBAAoB,EAC1CC,OAAS3M,KAAK4M,UAAW,EACzBxC,WAAkC,OAArBkC,iBAA4BtJ,OAAOsJ,mBAAoB,oCAAoBtM,KAAMuL,UAAWD,oBAExG,CACHjH,QAASrE,KAAKqE,QACdwI,gBAAiB7M,KAAK6M,iBAAmB7M,KAAKqE,QAC9CyI,YAAa1C,WACbwC,QAASD,OACTD,iBAAkBD,eAClBM,WAAYR,UACZS,aAAcR,YACdS,aAAcjN,KAAKiN,cAAgB,KACnCd,MAAOA,MACPe,UAAU,EACVjS,OAAQA,OACRuC,KAAMA,KACN2P,mBAAmB,EACnBjM,SAAWmL,iBAAmBG,YAAexM,KAAKkB,SAAS4J,KAAI,CAACxE,MAAO8G,QAEnElB,gBAAgB5F,MAAOmG,eAAiBN,MAAQA,MAAQ,EAAGC,cAAenR,OAAQuC,KAAM4P,MAAOhD,WAAYiC,mBAAoB,oDAOrInB,yBAA2B,CAACjQ,OAAQ0K,cAChC+E,eAAgB,kBAAG,sBAAqBzP,UAExCuC,MADY,kBAAG,uBAAsBvC,UAAUyC,QAAQ,8BACtCvC,KAAK,QACtBiB,SAAU,kBAAG,8BAA6BnB,UAE1CgD,YAAcC,eAAejD,QAC7BoS,YAAcjR,QAAQjB,KAAK,gBAC3BmS,eAAiB3M,MAAMC,QAAQyM,cAAgBA,YAAYzT,OAAS,EACpE2T,cAAgB5H,KAAKiH,QAE3BxQ,QAAQjB,KAAK,cAAewK,KAAKtB,aAI7BmJ,YAAc,QACZC,eAAiBrC,mBAAmBnQ,OAAQ0K,KAAKtB,UAAY,IAC7DqJ,aAAexB,gBAAgBvG,KAAM,EAAG1H,YAAahD,OAAQuC,KAAMgQ,YAAa,MAAM,EAAOC,gBACnGD,oBAIMG,eAAiB,GACjBC,cAAgBjI,KAAKiH,QAAWjH,KAAKS,iBAAmB,GAAOT,KAAKzE,UAAY,MAClF0M,cAAchU,OAAS,EAAG,CACG,IAAIgU,eAAelC,MAAK,CAACC,EAAGC,IACrD1Q,SAASyQ,EAAEtH,QAAS,IAAMnJ,SAAS0Q,EAAEvH,QAAS,MAE7BL,SAAShE,aACpB6N,gBAAkBzC,mBAAmBnQ,OAAQ+E,KAAKqE,WACpD,oCAAoBrE,KAAMwN,YAAa,MAG3CG,eAAevM,KAAK8K,gBAChBlM,KACA,EACA/B,YACAhD,OACAuC,KACAgQ,YACA,MACA,EACAK,kBAEJL,wCAIExF,OAAO,uCAAwC,CACrD8F,UAAWJ,aACXK,aAAcpI,KAAKtB,QACnB+B,gBAAiBuH,eACjB1S,OAAQA,OACRuC,KAAMA,KACNwN,oBAAqBrF,KAAKqF,qBAAuB,EACjDgD,iBAAkBV,eAClBW,iBAAkBV,aAAe5H,KAAKtB,QAAU,OACjDxJ,MAAMsN,OACLuC,cAAcvC,KAAKA,MACnBuC,cAAc5Q,KAAK,2BAA2BoU,QAAQ,CAClD1M,QAAS,QACT2M,UAAW,MACX1Q,UAAW,YAEhB1C,OAAOkC,QAENC,QAAQD,MAAM,uCAAwCA,4EAIxDgE,iBAAmB,CAACR,MAAOnF,cACxBmF,QAAUnF,cACJ,WAEL8S,OAASlT,SAASI,OAAQ,IAC1B+S,MAAQ,IAAI5N,YACX4N,MAAMzU,QAAQ,OACXoG,KAAOqO,MAAMC,WACdtO,SAGD9E,SAAS8E,KAAKqE,QAAS,MAAQ+J,cACxBpO,KAEPA,KAAKoG,iBAAmBpG,KAAKoG,gBAAgBxM,QAC7CyU,MAAMjN,QAAQpB,KAAKoG,iBAEnBpG,KAAKkB,UAAYlB,KAAKkB,SAAStH,QAC/ByU,MAAMjN,QAAQpB,KAAKkB,kBAGpB,uCAMsBjG,UACH,kBAAG,uBAAsBA,UACjCnB,KAAK,YAAYG,MAAK,iBAC9BsM,MAAO,kBAAErM,MACToB,OAASJ,SAASqL,KAAKpL,KAAK,WAAY,OAC1CG,OAAQ,OAGFiT,UAAY,UADCnD,mBAAmBnQ,OAAQK,SAAWA,QAGnDkT,OAASjI,KAAKzM,KAAK,UAAUS,QAAO,kBAE/B,kBAAEL,MAAMwD,QAAQ,sBAAsB9D,OAAS,QAEtD4U,OAAO5U,OAAS,EAChB4U,OAAO9L,KAAK6L,eACT,OAEGE,YAAclI,KAAKzM,KAAK,UAAUW,QACpCgU,YAAY7U,OAAS,GACrB6U,YAAY/L,KAAK6L,uBAU/BhN,qBAAuB,SAAC/D,KAAMvC,OAAQwG,kBAAciN,gEAAW,WAC3D9O,IAAM8O,UAAW,kBAAEA,UAAY,SACjCC,aAAe,KACf/O,KAAOA,IAAIhG,SACX+U,aAAe/O,IAAIuI,OACnBvI,IAAI5F,KAAK,YAAY,GAAM0C,SAAS,sBACpCkD,IAAIuI,KAAK,yEAGPvG,OAAS,IAAIlG,gBACnBkG,OAAOC,OAAO,SAAU,iBACxBD,OAAOC,OAAO,OAAQrE,MACtBoE,OAAOC,OAAO,SAAU5G,QACxB2G,OAAOC,OAAO,iBAAkBJ,cAChCG,OAAOC,OAAO,UAAWC,oBAAOC,SAEhCuC,MAAMxC,oBAAOI,QAAU,6BAA8B,CACjDqC,OAAQ,OACRC,QAAS,gBACW,qCAEpBoG,KAAMhJ,OAAOxC,aAEhBvE,MAAMqJ,eACEA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAMM,UACCyE,KAAOA,IAAIhG,SACXgG,IAAI5F,KAAK,YAAY,GAAOyM,YAAY,sBACnB,OAAjBkI,cACA/O,IAAIuI,KAAKwG,eAIbxT,KAAKwJ,QAAS,OACRvI,SAAU,kBAAG,8BAA6BnB,aAC5CmB,QAAQxC,OAAQ,KACZ8G,MAAQtE,QAAQjB,KAAK,gBACpBwF,MAAMC,QAAQF,SACfA,MAAQ,UAENS,YAAc/E,QAAQjB,KAAK,eAC7BgG,aACAT,MAAMU,KAAKD,aAEf/E,QAAQjB,KAAK,eAAgBuF,OAC7BtE,QAAQjB,KAAK,cAAesG,cAC5BrF,QAAQjB,KAAK,eAAgB,UAIjCgF,eAAelF,OAAQE,KAAKyT,aAAa,GAGzCC,mBAAmB5T,OAAQwG,aAActG,KAAKyT,aAG9CjS,qBAAqB1B,mCAEX,gBAAiB,oBACtBJ,MAAMiU,gCACUnR,gBAAgB,CACzBC,QAASkR,IACTjR,KAAM,eAGb9C,OAAM,+BACU4C,gBAAgB,CACzBC,QAAS,8BACTC,KAAM,8CAILF,gBAAgB,CACzBC,QAASzC,KAAKyC,SAAW,wBACzBC,KAAM,aAIjB9C,OAAOkC,QACA2C,KAAOA,IAAIhG,SACXgG,IAAI5F,KAAK,YAAY,GAAOyM,YAAY,sBACnB,OAAjBkI,cACA/O,IAAIuI,KAAKwG,eAKjBzR,QAAQD,MAAM,uBAAwBA,iCACzBU,gBAAgB,CACzBC,QAAS,wBAA0BX,MAAMW,QACzCC,KAAM,uEAQZgR,mBAAqB,CAAC5T,OAAQwG,aAAcsN,mBACxCxO,KAAOC,+BAAkBvF,YAC1BsF,OAASA,KAAKE,mBAGbkF,MAAO,gCAAgBpF,KAAKE,MAAOgB,kBACpCkE,kBAICqJ,QAAU,CACZ3K,QAAS0K,UACTnC,SAAS,EACTF,kBAAkB,EAClBuC,eAAgBxN,aAChBwL,aAAcjK,OAAO+L,WACrB7N,SAAU,GACV+G,YAAa/I,KAAKgJ,MAAMlJ,KAAKC,MAAQ,KACrCiQ,iBAAiB,IAAIlQ,MAAOmQ,kBAG1BC,OAAUpP,UACR9E,SAAS8E,KAAKqE,QAAS,MAAQnJ,SAASuG,aAAc,WAClDzB,KAAK4M,SAAW5M,KAAK0M,kBACrBsC,QAAQtC,kBAAmB,EACtB1M,KAAKoG,kBACNpG,KAAKoG,gBAAkB,IAE3BpG,KAAKoG,gBAAgBhF,KAAK4N,WAErBhP,KAAKkB,WACNlB,KAAKkB,SAAW,IAEpBlB,KAAKkB,SAASE,KAAK4N,WAEhB,KAEPhP,KAAKoG,oBACA,MAAMC,MAAMrG,KAAKoG,mBACdgJ,OAAO/I,WACA,KAIfrG,KAAKkB,aACA,MAAMoF,SAAStG,KAAKkB,YACjBkO,OAAO9I,cACA,SAIZ,GAGX8I,OAAOzJ,OAMLjE,cAAgB,CAAClE,KAAMvC,WACP,kBAAG,2CAA0CA,kBACzDG,mBAAoB,kBAAG,uBAAsBH,UAE7C2G,OAAS,IAAIlG,gBACnBkG,OAAOC,OAAO,SAAU,eACxBD,OAAOC,OAAO,OAAQrE,MACtBoE,OAAOC,OAAO,SAAU5G,QACxB2G,OAAOC,OAAO,UAAWC,oBAAOC,SAEhCuC,MAAMxC,oBAAOI,QAAU,6BAA8B,CACjDqC,OAAQ,OACRC,QAAS,gBACW,qCAEpBoG,KAAMhJ,OAAOxC,aAEhBvE,MAAMqJ,eACEA,SAASuD,SACJ,IAAIC,MAAM,uBAAyBxD,SAASyD,eAE/CzD,SAASQ,UAEnB7J,MAAMM,UACCA,KAAKwJ,QAAS,2BACD1J,QAAUE,KAAKyT,YAC5BtS,eAAerB,OAAQE,KAAKyT,aAC5BrS,kBAAkBtB,QAClBuB,oBAAoBvB,QACpBG,kBAAkB+M,KAAK,8HAEpB,wCAAuClN,UAAUyO,SAEpC,kBAAG,8BAA6BzO,UACxCE,KAAK,eAAgB,UAC7B2B,YAAW,KACPH,qBAAqB1B,UACtB,+BAEU0C,gBAAgB,CACzBC,QAASzC,KAAKyC,SAAW,wCACzBC,KAAM,2CAGGF,gBAAgB,CACzBC,QAASzC,KAAKyC,SAAW,4BACzBC,KAAM,aAIjB9C,OAAOkC,QAEJC,QAAQD,MAAM,2BAA4BA,iCAC7BU,gBAAgB,CACzBC,QAAS,4BAA8BX,MAAMW,QAC7CC,KAAM,yDAKZiC,8BAAgC,CAAC7E,OAAQoU,iBACrC5R,WAAY,kBAAG,uBAAsBxC,UAC3CwC,UAAUtC,KAAK,iBAA6B,IAAZkU,eAC1BC,aAAe7R,UAAU3D,KAAK,0BAChCuV,QACAC,aAAa7S,OAEb6S,aAAa5I,aAEXK,WAAY,kBAAG,8CAA6C9L,YAC9D8L,UAAUnN,QACVsN,0BAA0BH,UAAWsI,qFAIvCnI,0BAA4B,CAACtH,IAAKoH,aAChCA,WACApH,IAAIuI,KAAK,uEACTvI,IAAIK,KAAK,QAAS,kCAElBL,IAAIuI,KAAK,uEACTvI,IAAIK,KAAK,QAAS,+CAqBX,CACX4C,KAAAA,KACAC,UAAAA"}