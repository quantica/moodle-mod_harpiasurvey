{"version":3,"file":"turns.min.js","sources":["../src/turns.js"],"sourcesContent":["// Turns-only logic for harpiasurvey chat interface.\n//\n// Extracted from the previous monolithic core_chat.js. Handles turn navigation,\n// branching, locking, tree rendering, and send pipeline for turns behavior.\n\nimport {\n    Templates,\n    Notification,\n    Config,\n    getString,\n    $,\n    currentTurns,\n    conversationTrees,\n    scrollToBottom,\n    addError,\n    getCmid,\n    findRootForTurn,\n    countNodes,\n    calculateTurnNumber,\n    renderConversationList\n} from './common_chat';\n\nlet initializedTurns = false;\nlet commonHandlersRegistered = false;\nlet turnHandlersRegistered = false;\nlet treeHandlersRegistered = false;\nlet editLabel = 'Edit';\n\nconst lockQuestionItem = (questionItem) => {\n    questionItem.attr('data-response-locked', '1');\n    questionItem.removeAttr('data-response-editing');\n    questionItem.find('input, select, textarea').prop('disabled', true);\n};\n\nconst ensureEditButton = (questionItem) => {\n    let controls = questionItem.find('.question-edit-controls');\n    if (controls.length === 0) {\n        controls = $('<div class=\"mt-2 question-edit-controls\"></div>');\n        questionItem.append(controls);\n    }\n    let button = controls.find('.question-edit-btn');\n    if (button.length === 0) {\n        button = $('<button type=\"button\" class=\"btn btn-sm btn-outline-secondary question-edit-btn\"></button>');\n        controls.append(button);\n    }\n    button.text(editLabel);\n    button.show();\n};\n\nconst resetQuestionItemToNeutral = (questionItem) => {\n    if (!questionItem || questionItem.length === 0) {\n        return;\n    }\n\n    questionItem.removeAttr('data-response-locked');\n    questionItem.removeAttr('data-response-editing');\n    questionItem.find('.saved-response-message').remove();\n    questionItem.find('.answer-history').remove();\n    questionItem.find('.question-edit-controls').remove();\n\n    questionItem.find('input, select, textarea').prop('disabled', false);\n\n    questionItem.find('input[type=\"radio\"], input[type=\"checkbox\"]').each(function() {\n        $(this).prop('checked', Boolean(this.defaultChecked));\n    });\n\n    questionItem.find('select').each(function() {\n        const select = $(this);\n        const defaultOption = select.find('option').filter(function() {\n            return this.defaultSelected;\n        }).first();\n        if (defaultOption.length > 0) {\n            select.val(defaultOption.val());\n        } else {\n            select.prop('selectedIndex', 0);\n        }\n    });\n\n    questionItem.find('input[type=\"number\"], input[type=\"text\"], textarea').each(function() {\n        $(this).val(this.defaultValue || '');\n    });\n};\n\n/**\n * Initialize turns-mode chat for all containers on the page.\n */\nconst initialize = () => {\n    if (initializedTurns) {\n        return;\n    }\n\n    getString('edit', 'moodle').then((str) => {\n        editLabel = str;\n    }).catch(() => {\n        editLabel = 'Edit';\n    });\n\n    const containers = $('.ai-conversation-container[data-behavior=\"turns\"]');\n    if (containers.length === 0) {\n        return;\n    }\n\n    containers.each(function() {\n        const pageid = parseInt($(this).data('pageid'), 10);\n\n        if (!pageid) {\n            return;\n        }\n\n        const messagesContainer = $(`#chat-messages-page-${pageid}`);\n        let maxTurn = 0;\n        messagesContainer.find('[data-turn-id]').each(function() {\n            const turnId = parseInt($(this).data('turn-id'), 10);\n            if (turnId && turnId > maxTurn) {\n                maxTurn = turnId;\n            }\n        });\n        const calculatedCurrentTurn = maxTurn > 0 ? maxTurn : 1;\n        if (!currentTurns[pageid]) {\n            currentTurns[pageid] = calculatedCurrentTurn;\n        }\n\n        const urlParams = new URLSearchParams(window.location.search);\n        const urlTurn = urlParams.get('turn');\n        const urlBranch = urlParams.get('branch');\n\n        let initialViewingTurn = currentTurns[pageid];\n        let hasExplicitInitialTurn = false;\n        if (urlTurn !== null && urlTurn !== '') {\n            const parsedTurn = parseInt(urlTurn, 10);\n            if (!isNaN(parsedTurn) && parsedTurn > 0) {\n                initialViewingTurn = parsedTurn;\n                hasExplicitInitialTurn = true;\n            }\n        }\n\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        if (sidebar.length > 0 && urlBranch !== null && urlBranch !== '') {\n            const parsedBranchRoot = parseInt(urlBranch, 10);\n            if (!isNaN(parsedBranchRoot) && parsedBranchRoot > 0) {\n                sidebar.data('sidebar-view', 'detail');\n                sidebar.data('branch-root', parsedBranchRoot);\n            }\n        }\n\n        const shouldAutoloadSelection = hasExplicitInitialTurn || maxTurn === 0;\n        if (shouldAutoloadSelection) {\n            setViewingTurn(pageid, initialViewingTurn);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n        } else {\n            setNoTurnSelectedState(pageid);\n        }\n        \n        // Load conversation tree first, then filter messages (tree is needed to determine pathway).\n        if (sidebar.length > 0) {\n            sidebar.show();\n            $(`.toggle-tree-btn[data-pageid=\"${pageid}\"]`).addClass('active');\n            // Load tree first, then filter messages once tree is loaded.\n            loadConversationTree(pageid).then(() => {\n                if (shouldAutoloadSelection) {\n                    // Tree loaded - now filter messages based on the pathway.\n                    filterMessagesByTurn(pageid, initialViewingTurn);\n                }\n            }).catch(() => {\n                if (shouldAutoloadSelection) {\n                    // If tree loading fails, still filter with just the current turn.\n                    filterMessagesByTurn(pageid, initialViewingTurn);\n                }\n            });\n        } else {\n            if (shouldAutoloadSelection) {\n                // No sidebar - filter immediately (will only show current turn if tree not available).\n                filterMessagesByTurn(pageid, initialViewingTurn);\n            }\n        }\n        \n        updateSubpageVisibility(pageid);\n        if (shouldAutoloadSelection) {\n            setTimeout(() => {\n                ensureTurnEvaluationQuestionsRendered(pageid, initialViewingTurn).then(() => {\n                    loadTurnEvaluationResponses(pageid, initialViewingTurn);\n                }).catch((error) => {\n                    // eslint-disable-next-line no-console\n                    console.error('Error loading turn evaluation questions on init:', error);\n                });\n            }, 100);\n        }\n    });\n\n    registerCommonHandlers();\n    registerTreeHandlers();\n    registerTurnHandlers();\n    initializedTurns = true;\n};\n\nexport const init = () => initialize();\nexport const initTurns = () => initialize();\n\n/**\n * Register common chat handlers (send/enter).\n */\nfunction registerCommonHandlers() {\n    if (commonHandlersRegistered) {\n        return;\n    }\n\n    // Handle send button clicks.\n    $(document).on('click', '.chat-send-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const container = button.closest('.ai-conversation-container');\n        if (container.data('behavior') !== 'turns') {\n            return;\n        }\n\n        if (!cmid || !pageid) {\n            Notification.addNotification({\n                message: 'Missing cmid or pageid',\n                type: 'error'\n            });\n            return;\n        }\n\n        const input = $(`#chat-input-page-${pageid}`);\n        if (input.length === 0) {\n            Notification.addNotification({\n                message: 'Chat input not found',\n                type: 'error'\n            });\n            return;\n        }\n\n        const inputValue = input.val();\n        if (!inputValue) {\n            return;\n        }\n\n        const message = inputValue.trim();\n\n        if (!message) {\n            return;\n        }\n\n        // Check if chat is locked (viewing a past turn).\n        const viewingTurn = getViewingTurn(pageid);\n        const currentTurn = getCurrentTurn(pageid);\n        // Ensure both are numbers for comparison.\n        const viewingTurnNum = parseInt(viewingTurn, 10);\n        const currentTurnNum = parseInt(currentTurn, 10);\n\n        // Allow sending if viewing turn >= current turn.\n        // If viewing turn > current turn, backend will create the next turn.\n        // Only block if viewing a past turn (viewingTurn < currentTurn).\n        if (viewingTurnNum < currentTurnNum) {\n            // Viewing a past turn - block it.\n            Notification.addNotification({\n                message: 'Cannot send messages in a locked turn. ' +\n                    'Navigate to the current turn first.',\n                type: 'error'\n            });\n            return;\n        }\n        // If viewingTurn >= currentTurn, allow it - backend will handle creating the right turn.\n\n        // Check max turns limit.\n        const maxTurns = container.data('max-turns');\n        if (maxTurns !== undefined && maxTurns !== null) {\n            const maxTurnsNum = parseInt(maxTurns, 10);\n            const turnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n            // Only block when the active conversation already reached the limit and the turn is complete\n            // (sending would create a new turn).\n            if (turnCount !== null && turnCount >= maxTurnsNum &&\n                isTurnComplete(pageid, viewingTurnNum)) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    Notification.addNotification({\n                        message: str,\n                        type: 'error'\n                    });\n                });\n                return;\n            }\n        }\n\n        // Get model from container data attribute (first available model).\n        const modelsdata = container.data('models');\n        let modelid = null;\n\n        if (modelsdata) {\n            // modelsdata is a comma-separated string, get first one.\n            const modelids = modelsdata.split(',');\n            if (modelids.length > 0) {\n                modelid = parseInt(modelids[0], 10);\n            }\n        }\n\n        if (!modelid) {\n            Notification.addNotification({\n                message: 'No model available',\n                type: 'error'\n            });\n            return;\n        }\n\n        // Disable input and button.\n        input.prop('disabled', true);\n        button.prop('disabled', true);\n\n        // Clear input.\n        input.val('');\n\n        // Display user message with temporary ID (will be updated with real ID from server).\n        const tempId = 'temp-user-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\n        displayUserMessage(pageid, message, tempId);\n\n        // Show loading indicator.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        loading.show();\n\n        // Send message to AI.\n        sendMessage(cmid, pageid, message, modelid, button, input, loading);\n    });\n\n    // Handle Enter key in textarea (Shift+Enter for new line, Enter to send).\n    $(document).on('keydown', '.chat-input', function(e) {\n        if (e.key === 'Enter' && !e.shiftKey) {\n            e.preventDefault();\n            $(this).closest('.ai-conversation-container').find('.chat-send-btn').click();\n        }\n    });\n\n    // Toggle visibility of previous turn messages in the current path.\n    $(document).on('click', '.toggle-previous-messages-btn', function(e) {\n        e.preventDefault();\n        const btn = $(this);\n        const pageid = parseInt(btn.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const container = $(`#chat-messages-page-${pageid}`);\n        const prevMessages = container.find('.previous-turn-message');\n        if (prevMessages.length === 0) {\n            return;\n        }\n        const currentlyVisible = container.data('show-previous') === true;\n        setPreviousMessagesVisibility(pageid, !currentlyVisible);\n    });\n\n    commonHandlersRegistered = true;\n}\n\n/**\n * Register handlers shared for turn tree/navigation.\n */\nfunction registerTreeHandlers() {\n    if (treeHandlersRegistered) {\n        return;\n    }\n\n    // Handle tree node navigation clicks.\n    $(document).on('click', '.tree-node-content[data-action=\"navigate\"]', function(e) {\n        e.preventDefault();\n        const node = $(this);\n        const turnId = parseInt(node.data('turn-id'), 10);\n        const pageid = node.closest('.conversation-tree-sidebar').attr('id').replace('conversation-tree-sidebar-', '');\n        if (!pageid) {\n            return;\n        }\n        if (turnId) {\n            navigateToTurn(parseInt(pageid, 10), turnId);\n        }\n    });\n\n    // Handle conversation item click (in list view).\n    $(document).on('click', '.conversation-item', function(e) {\n        e.preventDefault();\n        const item = $(this);\n        const rootTurnId = parseInt(item.data('root-turn-id'), 10);\n        const sidebar = item.closest('.conversation-tree-sidebar');\n        const pageid = parseInt(sidebar.attr('id').replace('conversation-tree-sidebar-', ''), 10);\n\n        if (!pageid) {\n            return;\n        }\n\n        if (rootTurnId) {\n            sidebar.data('sidebar-view', 'detail');\n            navigateToTurn(pageid, rootTurnId);\n        }\n    });\n\n    // Handle back to list button click.\n    $(document).on('click', '.back-to-list-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n\n        // Render the list view.\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        sidebar.data('sidebar-view', 'list'); // Set to list view\n        sidebar.data('branch-root', null);\n        sidebar.data('branch-stack', []);\n        syncTurnsUrlState(pageid);\n\n        const tree = conversationTrees[pageid];\n        if (tree) {\n            renderConversationList(pageid, tree.roots);\n        } else {\n            loadConversationTree(pageid);\n        }\n    });\n\n    // Handle back to parent branch button click.\n    $(document).on('click', '.back-to-parent-branch-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        if (!pageid) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        let stack = sidebar.data('branch-stack');\n        if (!Array.isArray(stack) || stack.length === 0) {\n            sidebar.data('branch-root', null);\n            sidebar.data('branch-stack', []);\n            loadConversationTree(pageid);\n            return;\n        }\n        const previousRoot = stack.pop();\n        sidebar.data('branch-stack', stack);\n        sidebar.data('branch-root', previousRoot || null);\n        sidebar.data('sidebar-view', 'detail');\n        syncTurnsUrlState(pageid);\n        loadConversationTree(pageid);\n    });\n\n    // Handle enter branch (subtree) button click.\n    $(document).on('click', '.enter-branch-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        if (!pageid || !turnId) {\n            return;\n        }\n        const tree = conversationTrees[pageid];\n        if (!tree || !tree.roots) {\n            return;\n        }\n        const targetNode = findNodeByTurnId(tree.roots, turnId);\n        if (!targetNode || !targetNode.children || targetNode.children.length === 0) {\n            return;\n        }\n        const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n        let stack = sidebar.data('branch-stack');\n        if (!Array.isArray(stack)) {\n            stack = [];\n        }\n        const currentRoot = sidebar.data('branch-root');\n        if (currentRoot) {\n            stack.push(currentRoot);\n        }\n        sidebar.data('branch-stack', stack);\n        sidebar.data('branch-root', turnId);\n        sidebar.data('sidebar-view', 'detail');\n        navigateToTurn(pageid, turnId);\n    });\n\n    // Handle create branch button clicks (from tree).\n    $(document).on('click', '.create-branch-from-tree-btn', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        const turnId = parseInt(button.data('turn-id'), 10);\n        const branchMode = button.data('branch-mode');\n\n        if (!pageid || !turnId) {\n            Notification.addNotification({\n                message: 'Missing required data to create turn',\n                type: 'error'\n            });\n            return;\n        }\n        const currentViewingTurn = getViewingTurn(pageid);\n        if (currentViewingTurn && hasUnsavedTurnEvaluation(pageid, currentViewingTurn)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n        if (hasUnsavedTurnEvaluation(pageid, turnId)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n        if (branchMode === 'enter') {\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            let stack = sidebar.data('branch-stack');\n            if (!Array.isArray(stack)) {\n                stack = [];\n            }\n            const currentRoot = sidebar.data('branch-root');\n            if (currentRoot) {\n                stack.push(currentRoot);\n            }\n            sidebar.data('branch-stack', stack);\n            sidebar.data('branch-root', turnId);\n            sidebar.data('sidebar-view', 'detail');\n            navigateToTurn(pageid, turnId);\n            return;\n        }\n        if (!cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create turn',\n                type: 'error'\n            });\n            return;\n        }\n        createBranchFromTurn(cmid, pageid, turnId, button);\n    });\n\n    // Ensure clicks on the label/icon also trigger branch creation.\n    $(document).on('click', '.create-branch-from-tree-btn .branch-label, .create-branch-from-tree-btn i', function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        const btn = $(this).closest('.create-branch-from-tree-btn');\n        if (btn.length) {\n            btn.trigger('click');\n        }\n    });\n\n    // Handle \"create direct branch\" button clicks (from sidebar footer or inline).\n    $(document).on('click', '.create-direct-branch-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        // Prefer explicit root-turn-id on the button (sidebar detail footer).\n        let parentTurnId = parseInt(button.data('root-turn-id'), 10);\n        if (!parentTurnId || isNaN(parentTurnId)) {\n            // Fallback to current viewing turn.\n            parentTurnId = getViewingTurn(pageid);\n        }\n\n        if (!pageid || !cmid || !parentTurnId) {\n            Notification.addNotification({\n                message: 'Missing required data to create branch',\n                type: 'error'\n            });\n            return;\n        }\n        const currentViewingTurn = getViewingTurn(pageid);\n        if (currentViewingTurn && hasUnsavedTurnEvaluation(pageid, currentViewingTurn)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n        if (hasUnsavedTurnEvaluation(pageid, parentTurnId)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n\n        createBranchFromTurn(cmid, pageid, parentTurnId, button);\n    });\n\n    // Handle create new root button clicks.\n    $(document).on('click', '.create-root-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to create root',\n                type: 'error'\n            });\n            return;\n        }\n        const viewingTurn = getViewingTurn(pageid);\n        if (viewingTurn && hasUnsavedTurnEvaluation(pageid, viewingTurn)) {\n            getString('turnrequiresave', 'mod_harpiasurvey').then((message) => {\n                Notification.addNotification({\n                    message: message,\n                    type: 'warning'\n                });\n            }).catch(() => {\n                Notification.addNotification({\n                    message: 'Please save the evaluation answers before creating a new turn.',\n                    type: 'warning'\n                });\n            });\n            return;\n        }\n        createNewRoot(cmid, pageid);\n    });\n    \n    // Handle export conversation button clicks.\n    $(document).on('click', '.export-conversation-btn', function(e) {\n        e.preventDefault();\n        const button = $(this);\n        const pageid = parseInt(button.data('pageid'), 10);\n        const cmid = parseInt(button.data('cmid'), 10);\n        if (!pageid || !cmid) {\n            Notification.addNotification({\n                message: 'Missing required data to export conversation',\n                type: 'error'\n            });\n            return;\n        }\n        \n        // Get current viewing turn (for turns mode)\n        const viewingTurn = getViewingTurn(pageid);\n        const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n        const behavior = container.data('behavior') || 'continuous';\n        \n        // Build export URL\n        const params = new URLSearchParams();\n        params.append('action', 'export_conversation');\n        params.append('cmid', cmid);\n        params.append('pageid', pageid);\n        params.append('sesskey', Config.sesskey);\n        \n        if (behavior === 'turns' && viewingTurn) {\n            params.append('turn_id', viewingTurn);\n        } else if (behavior === 'continuous') {\n            // For continuous mode, try to get conversation ID from container\n            const conversationId = container.data('viewing-conversation');\n            if (conversationId) {\n                params.append('conversation_id', conversationId);\n            }\n        }\n        \n        // Open export URL in new window/tab to trigger download\n        window.open(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), '_blank');\n    });\n\n    treeHandlersRegistered = true;\n}\n\n/**\n * Register any extra turns-specific handlers (placeholder).\n */\nfunction registerTurnHandlers() {\n    if (turnHandlersRegistered) {\n        return;\n    }\n\n    $(document).on(\n        'click',\n        '.ai-conversation-container[data-behavior=\"turns\"] .turn-evaluation-questions .save-turn-evaluation-questions-btn',\n        function(e) {\n            e.preventDefault();\n            e.stopPropagation();\n\n            const button = $(this);\n            const turnId = parseInt(button.data('turn-id'), 10);\n            const pageid = parseInt(button.data('pageid'), 10);\n            const cmid = parseInt(button.data('cmid'), 10);\n\n            if (!turnId || !pageid || !cmid) {\n                Notification.addNotification({\n                    message: 'Missing required data to save responses.',\n                    type: 'error'\n                });\n                return;\n            }\n\n            const evaluationContainer = button.closest('.turn-evaluation-questions');\n            if (evaluationContainer.length === 0) {\n                return;\n            }\n\n            const responses = collectTurnEvaluationResponses(evaluationContainer);\n            if (Object.keys(responses).length === 0) {\n                Notification.addNotification({\n                    message: 'No editable questions to save. Click Edit on a question first.',\n                    type: 'info'\n                });\n                return;\n            }\n\n            const originalText = button.text();\n            button.prop('disabled', true);\n            button.text('Saving...');\n            saveTurnEvaluationResponses(cmid, pageid, turnId, responses, button, originalText);\n        }\n    );\n\n    turnHandlersRegistered = true;\n}\n\nconst collectTurnEvaluationResponses = (evaluationContainer) => {\n    const responses = {};\n\n    evaluationContainer.find('[data-questionid]').each(function() {\n        const item = $(this);\n        const isLocked = String(item.attr('data-response-locked')) === '1';\n        const isEditing = String(item.attr('data-response-editing')) === '1';\n        if (isLocked && !isEditing) {\n            return;\n        }\n\n        const questionId = item.data('questionid');\n        const questionType = item.data('questiontype');\n        let responseValue = null;\n\n        if (questionType === 'multiplechoice') {\n            const checked = item.find(`input[name=\"question_${questionId}_turn[]\"]:checked`);\n            const values = [];\n            checked.each(function() {\n                values.push($(this).val());\n            });\n            responseValue = values.length > 0 ? JSON.stringify(values) : null;\n        } else if (questionType === 'select') {\n            const selected = item.find(`select[name=\"question_${questionId}_turn\"]`);\n            responseValue = selected.length > 0 ? selected.val() : null;\n        } else if (questionType === 'singlechoice' || questionType === 'likert') {\n            const selected = item.find(`input[name=\"question_${questionId}_turn\"]:checked`);\n            responseValue = selected.length > 0 ? selected.val() : null;\n        } else if (questionType === 'number' || questionType === 'shorttext') {\n            const input = item.find(`input[name=\"question_${questionId}_turn\"]`);\n            responseValue = input.length > 0 ? input.val() : null;\n        } else if (questionType === 'longtext') {\n            const textarea = item.find(`textarea[name=\"question_${questionId}_turn\"]`);\n            responseValue = textarea.length > 0 ? textarea.val() : null;\n        }\n\n        if (responseValue !== null && responseValue !== '') {\n            responses[questionId] = responseValue;\n        }\n    });\n\n    return responses;\n};\n\nconst saveTurnEvaluationResponses = (cmid, pageid, turnId, responses, button, originalText) => {\n    const entries = Object.entries(responses);\n    let failedCount = 0;\n\n    let promiseChain = Promise.resolve();\n    entries.forEach(([questionId, response]) => {\n        promiseChain = promiseChain.then(() => {\n            const params = new URLSearchParams({\n                action: 'save_response',\n                cmid: cmid,\n                pageid: pageid,\n                questionid: questionId,\n                response: response,\n                turn_id: turnId,\n                sesskey: Config.sesskey\n            });\n\n            return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            })\n            .then((res) => res.json())\n            .then((data) => {\n                if (!data.success) {\n                    failedCount++;\n                }\n            })\n            .catch(() => {\n                failedCount++;\n            });\n        });\n    });\n\n    promiseChain.then(() => {\n        button.prop('disabled', false);\n        button.text(originalText);\n\n        if (failedCount === 0) {\n            Notification.addNotification({\n                message: 'Responses saved.',\n                type: 'success'\n            });\n        } else {\n            Notification.addNotification({\n                message: 'Some responses failed to save.',\n                type: 'warning'\n            });\n        }\n\n        loadTurnEvaluationResponses(pageid, turnId);\n    });\n};\n\n/**\n * Get the current turn for a page (highest turn with messages).\n *\n * @param {number} pageid Page ID\n * @return {number} Current turn number\n */\nconst getCurrentTurn = (pageid) => {\n    return currentTurns[pageid] || 1;\n};\n\n/**\n * Get the viewing turn for a page (which turn is being displayed).\n *\n * @param {number} pageid Page ID\n * @return {number} Viewing turn number\n */\nconst getViewingTurn = (pageid) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    return parseInt(container.data('viewing-turn') || getCurrentTurn(pageid), 10);\n};\n\n/**\n * Sync turns URL state (turn + branch root when applicable).\n *\n * @param {number} pageid Page ID\n * @param {number|null} turnOverride Turn to persist (defaults to current viewing turn)\n */\nconst syncTurnsUrlState = (pageid, turnOverride = null) => {\n    const turn = turnOverride !== null ? parseInt(turnOverride, 10) : getViewingTurn(pageid);\n    if (!turn || isNaN(turn)) {\n        return;\n    }\n\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    const branchRoot = parseInt(sidebar.data('branch-root'), 10);\n    const viewMode = sidebar.data('sidebar-view');\n\n    const urlParams = new URLSearchParams(window.location.search);\n    urlParams.set('turn', turn);\n\n    if (viewMode && viewMode !== 'list' && branchRoot && !isNaN(branchRoot)) {\n        urlParams.set('branch', branchRoot);\n    } else {\n        urlParams.delete('branch');\n    }\n\n    const newUrl = window.location.pathname + '?' + urlParams.toString();\n    window.history.replaceState({}, '', newUrl);\n};\n\n/**\n * Set the viewing turn (and update URL param).\n *\n * @param {number} pageid Page ID\n * @param {number} turn Turn number\n */\nconst setViewingTurn = (pageid, turn) => {\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    container.data('viewing-turn', turn);\n    container.attr('data-viewing-turn', turn);\n    syncTurnsUrlState(pageid, turn);\n};\n\nconst setNoTurnSelectedState = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const container = messagesContainer.closest('.ai-conversation-container');\n    messagesContainer.find('.message').hide();\n\n    const evalContainer = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (evalContainer.length > 0) {\n        evalContainer.empty();\n    }\n\n    const badge = $(`#current-turn-badge-${pageid}`);\n    if (badge.length > 0) {\n        badge.hide();\n    }\n\n    // If there is existing history, require an explicit turn selection before sending.\n    if (messagesContainer.find('.message[data-turn-id]').length > 0) {\n        const input = $(`#chat-input-page-${pageid}`);\n        const sendButton = $(`.chat-send-btn[data-pageid=\"${pageid}\"]`).first();\n        input.prop('disabled', true);\n        sendButton.prop('disabled', true);\n        container.removeAttr('data-viewing-turn');\n    }\n};\n\n/**\n * Update current turn display in UI.\n *\n * @param {number} pageid Page ID\n */\nconst updateTurnDisplay = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const badge = $(`#current-turn-badge-${pageid}`);\n    const label = $(`#current-turn-number-${pageid}`);\n    if (badge.length > 0) {\n        badge.show();\n    }\n    if (label.length > 0) {\n        getString('turn', 'mod_harpiasurvey').then((turnStr) => {\n            label.text(`${turnStr} ${viewingTurn}`);\n        }).catch(() => {\n            label.text(`Turn ${viewingTurn}`);\n        });\n    }\n};\n\n/**\n * Check if a turn has any messages.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn has at least one message\n */\nconst turnHasMessages = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    return messagesContainer.find(`.message[data-turn-id=\"${turnId}\"]`).length > 0;\n};\n\n/**\n * Check if the current turn is complete (last message from AI).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {boolean} True if turn is complete\n */\nconst isTurnComplete = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    const turnMessages = messagesContainer.find(`.message[data-turn-id=\"${turnId}\"]`);\n    if (turnMessages.length === 0) {\n        return false;\n    }\n    const lastMessage = turnMessages.last();\n    const role = lastMessage.data('role');\n    return role === 'assistant' || role === 'ai';\n};\n\n/**\n * Get the number of turns in the conversation that contains the given turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID (or conversation root ID)\n * @return {number|null} Count of turns or null if unknown\n */\nconst getTurnCountForConversation = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots || !turnId) {\n        return null;\n    }\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n    return countNodes(root);\n};\n\n/**\n * Filter messages by turn - shows only messages from the current pathway.\n * All messages from the current pathway remain in the DOM, but only the current turn is visible by default.\n * Previous turns are hidden by default and can be shown via the \"Show previous\" button.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to show\n */\nconst filterMessagesByTurn = (pageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    // Default collapsed unless user toggled to show.\n    const shouldShowPrevious = messagesContainer.data('show-previous') === true;\n    \n    // Build set of allowed turn IDs (current pathway from root to current turn).\n    const tree = conversationTrees[pageid];\n    const root = tree ? findRootForTurn(tree.roots || [], turnId) : null;\n    const allowedTurnIds = new Set();\n    allowedTurnIds.add(turnId);\n    \n    if (root) {\n        // Recursively find the path from root to the target turn.\n        const addPath = (node, targetId, path) => {\n            if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n                // Found the target - add all turns in the path.\n                path.forEach(id => allowedTurnIds.add(id));\n                allowedTurnIds.add(parseInt(node.turn_id, 10));\n                return true;\n            }\n            // Check direct branches (same level as root).\n            if (node.direct_branches) {\n                for (const db of node.direct_branches) {\n                    if (addPath(db, targetId, [...path, parseInt(node.turn_id, 10)])) {\n                        return true;\n                    }\n                }\n            }\n            // Check children (nested branches).\n            if (node.children) {\n                for (const child of node.children) {\n                    if (addPath(child, targetId, [...path, parseInt(node.turn_id, 10)])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        addPath(root, turnId, []);\n    } else {\n        // If tree not loaded yet, just allow the current turn.\n        // The tree will be loaded and filtering will be re-applied.\n        allowedTurnIds.add(turnId);\n    }\n\n    // Process all messages in the container.\n    // Messages from the current pathway remain in DOM but are shown/hidden based on turn.\n    // Messages from other pathways are hidden.\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const messageTurnId = parseInt($msg.data('turn-id'), 10);\n        \n        if (!messageTurnId || isNaN(messageTurnId)) {\n            // Message without turn_id - hide it (shouldn't happen in turns mode).\n            $msg.removeClass('previous-turn-message').hide();\n            return;\n        }\n        \n        const isCurrentTurn = messageTurnId === parseInt(turnId, 10);\n        const isInPathway = allowedTurnIds.has(messageTurnId);\n        \n        if (isInPathway) {\n            // Message is in the current pathway - keep in DOM.\n            if (isCurrentTurn) {\n                // Current turn - always visible.\n                $msg.removeClass('previous-turn-message').show();\n            } else {\n                // Previous turn in pathway - hide by default, show if toggle is on.\n                $msg.addClass('previous-turn-message');\n                if (shouldShowPrevious) {\n                    $msg.show();\n                } else {\n                    $msg.hide();\n                }\n            }\n        } else {\n            // Message is from a different pathway - hide it.\n            $msg.removeClass('previous-turn-message').hide();\n        }\n    });\n    \n    // Also handle turn separators - show/hide them based on pathway.\n    messagesContainer.find('.turn-separator').each(function() {\n        const $separator = $(this);\n        const separatorTurnId = parseInt($separator.data('turn-separator'), 10);\n        \n        if (!separatorTurnId || isNaN(separatorTurnId)) {\n            $separator.hide();\n            return;\n        }\n        \n        const isInPathway = allowedTurnIds.has(separatorTurnId);\n        if (isInPathway) {\n            $separator.show();\n        } else {\n            $separator.hide();\n        }\n    });\n\n    // Update toggle button state based on whether there are previous messages.\n    const toggleBtn = $(`.toggle-previous-messages-btn[data-pageid=\"${pageid}\"]`);\n    if (toggleBtn.length > 0) {\n        const hasPreviousMessages = messagesContainer.find('.previous-turn-message').length > 0;\n        if (hasPreviousMessages) {\n            toggleBtn.show();\n            toggleBtn.prop('disabled', false);\n            const firstPrevious = messagesContainer.find('.previous-turn-message').first();\n            const isVisible = firstPrevious.is(':visible');\n            updatePreviousToggleLabel(toggleBtn, isVisible);\n        } else {\n            // No previous messages - hide the button.\n            toggleBtn.hide();\n        }\n    }\n\n    // Scroll to bottom after filtering.\n    setTimeout(() => {\n        scrollToBottom(pageid);\n    }, 50);\n};\n\n/**\n * Update chat lock state (disable input if viewing past turn).\n *\n * @param {number} pageid Page ID\n */\nconst updateChatLockState = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const currentTurn = getCurrentTurn(pageid);\n    // Ensure both are numbers for comparison.\n    const viewingTurnNum = parseInt(viewingTurn, 10);\n    const currentTurnNum = parseInt(currentTurn, 10);\n    const input = $(`#chat-input-page-${pageid}`);\n    const sendBtn = $(`.chat-send-btn[data-pageid=\"${pageid}\"]`);\n    const lockMessage = $(`#turn-locked-message-${pageid}`);\n    const container = input.closest('.ai-conversation-container');\n    const maxTurns = container.data('max-turns');\n    const maxTurnsNum = (maxTurns !== undefined && maxTurns !== null) ? parseInt(maxTurns, 10) : null;\n    const conversationTurnCount = getTurnCountForConversation(pageid, viewingTurnNum);\n    const hasReachedTurnLimit = maxTurnsNum !== null &&\n        conversationTurnCount !== null &&\n        conversationTurnCount >= maxTurnsNum;\n\n    if (viewingTurnNum < currentTurnNum) {\n        // Viewing a past turn - lock chat.\n        input.prop('disabled', true);\n        sendBtn.prop('disabled', true);\n        if (lockMessage.length > 0) {\n            lockMessage.show();\n        }\n        // Hide direct branch button when viewing past turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n    } else if (viewingTurnNum === currentTurnNum && isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's complete - check max turns limit.\n        // Only lock if turn has messages AND max turns is reached.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n        } else {\n            // Turn complete but not at max - lock chat (user must create next turn).\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input to focus on next turn.\n            if (lockMessage.length > 0) {\n                lockMessage.hide(); // Don't show \"locked\" message, just disable input.\n            }\n            // Show direct branch button.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.show();\n            }\n        }\n    } else if (viewingTurnNum === currentTurnNum && !isTurnComplete(pageid, viewingTurnNum)) {\n        // Viewing current turn and it's not complete - check max turns and if we're waiting for AI response.\n        // Check max turns limit first, but only if turn has messages.\n        if (hasReachedTurnLimit && turnHasMessages(pageid, viewingTurnNum)) {\n            // Max turns reached - lock chat permanently.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n            input.val(''); // Clear input.\n            if (lockMessage.length > 0) {\n                getString('maxturnsreached', 'mod_harpiasurvey').then((str) => {\n                    lockMessage.text(str).show();\n                });\n            }\n            // Hide direct branch button when max turns reached.\n            const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n            if (directBranchContainer.length > 0) {\n                directBranchContainer.hide();\n            }\n            return;\n        }\n        // If we just sent a message, input should stay disabled until AI responds.\n        // We'll check if there's a loading indicator to determine this.\n        const loading = $(`#chat-loading-page-${pageid}`);\n        if (loading.is(':visible')) {\n            // Waiting for AI response - keep input disabled.\n            input.prop('disabled', true);\n            sendBtn.prop('disabled', true);\n        } else {\n            // Not waiting for response - unlock chat.\n            input.prop('disabled', false);\n            sendBtn.prop('disabled', false);\n        }\n        // Hide direct branch button when turn is not complete.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    } else {\n        // Viewing future turn (shouldn't happen, but unlock just in case).\n        input.prop('disabled', false);\n        sendBtn.prop('disabled', false);\n        // Hide direct branch button when viewing future turns.\n        const directBranchContainer = $(`#direct-branch-container-${pageid}`);\n        if (directBranchContainer.length > 0) {\n            directBranchContainer.hide();\n        }\n        if (lockMessage.length > 0) {\n            lockMessage.hide();\n        }\n    }\n};\n\n/**\n * Send message to AI via AJAX (turns mode).\n *\n * @param {number} cmid Course module ID\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {number} modelid Model ID\n * @param {jQuery} button Send button element\n * @param {jQuery} input Input textarea element\n * @param {jQuery} loading Loading indicator element\n */\nconst sendMessage = (cmid, pageid, message, modelid, button, input, loading) => {\n    // Get current viewing turn (for turns mode).\n    const viewingTurn = getViewingTurn(pageid);\n\n    const params = new URLSearchParams({\n        action: 'send_ai_message',\n        cmid: cmid,\n        pageid: pageid,\n        message: message,\n        modelid: modelid,\n        sesskey: Config.sesskey\n    });\n\n    // For turns mode, send the viewing turn so backend can use it.\n    if (viewingTurn) {\n        params.append('turn_id', viewingTurn);\n    }\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        loading.hide();\n\n        if (data.success) {\n            // Display AI response (check for duplicates first).\n            if (data.messageid && data.content) {\n                // displayAIMessage is async, so we need to wait for it to complete\n                // before checking if the turn is complete and updating lock state.\n                displayAIMessage(pageid, data.content, data.messageid, data.turn_id).then(() => {\n                    // Update current turn if a new turn was created.\n                    if (data.turn_id) {\n                        const currentTurn = getCurrentTurn(pageid);\n                        if (data.turn_id > currentTurn) {\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        } else if (data.turn_id === currentTurn + 1) {\n                            // Backend created next turn - update current turn.\n                            currentTurns[pageid] = data.turn_id;\n                            updateTurnDisplay(pageid);\n                            // Update viewing turn to match the new current turn.\n                            setViewingTurn(pageid, data.turn_id);\n                        }\n                    }\n\n                    // Update chat lock state after message is fully rendered in DOM.\n                    // Use a small delay to ensure DOM is completely updated and isTurnComplete can detect the new message.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                }).catch(() => {\n                    // If displayAIMessage fails, still try to update lock state.\n                    setTimeout(() => {\n                        updateChatLockState(pageid);\n                    }, 100);\n                });\n            } else {\n                Notification.addNotification({\n                    message: 'Received response but missing message ID or content',\n                    type: 'error'\n                });\n                // Re-enable input on error.\n                input.prop('disabled', false);\n                button.prop('disabled', false);\n                input.focus();\n            }\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Error sending message',\n                type: 'error'\n            });\n            // Re-enable input on error.\n            input.prop('disabled', false);\n            button.prop('disabled', false);\n            input.focus();\n        }\n    })\n    .catch(error => {\n        loading.hide();\n        // eslint-disable-next-line no-console\n        console.error('Error sending message:', error);\n        Notification.addNotification({\n            message: 'Error sending message: ' + error.message,\n            type: 'error'\n        });\n        input.prop('disabled', false);\n        button.prop('disabled', false);\n        input.focus();\n    });\n};\n\n/**\n * Display user message in the chat.\n *\n * @param {number} pageid Page ID\n * @param {string} message Message content\n * @param {string} messageid Temp/real message ID\n */\nconst displayUserMessage = (pageid, message, messageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return;\n    }\n    messagesContainer.find('.text-center.text-muted').remove();\n    Templates.render('mod_harpiasurvey/chat_user_message', {\n        id: messageid,\n        content: message,\n        timecreated: Math.floor(Date.now() / 1000)\n    }).then((html) => {\n        messagesContainer.append(html);\n        scrollToBottom(pageid);\n    }).catch(Notification.exception);\n};\n\n/**\n * Display AI message in the chat.\n *\n * @param {number} pageid Page ID\n * @param {string} content Message content\n * @param {string} messageid Message ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when rendered\n */\nconst displayAIMessage = (pageid, content, messageid, turnId) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    if (messagesContainer.length === 0) {\n        return Promise.resolve();\n    }\n    return Templates.render('mod_harpiasurvey/chat_ai_message', {\n        id: messageid,\n        content: content,\n        timecreated: Math.floor(Date.now() / 1000),\n        turn_id: turnId\n    }).then((html) => {\n        messagesContainer.append(html);\n        scrollToBottom(pageid);\n        return html;\n    }).catch(Notification.exception);\n};\n\n/**\n * Scroll chat to bottom.\n *\n * @param {number} pageid Page ID\n */\nconst scrollToBottomLocal = (pageid) => scrollToBottom(pageid);\n\n/**\n * Ensure turn evaluation questions are rendered for a specific turn.\n * This will render them if they don't exist, or do nothing if they already exist.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n * @return {Promise} Promise that resolves when questions are rendered\n */\nconst ensureTurnEvaluationQuestionsRendered = (pageid, turnId) => {\n    // Check if questions are already rendered for this turn.\n    // Look in the container below the chat, not inside messages.\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        // Container wrapper doesn't exist - not in turns mode or page not loaded yet.\n        return Promise.resolve();\n    }\n\n    const existingContainer = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (existingContainer.length > 0 && existingContainer.find('.question-item').length > 0) {\n        // Questions already rendered, return resolved promise.\n        return Promise.resolve();\n    }\n\n    // Render questions for this turn.\n    return getString('loading', 'moodle').then((loadingStr) => {\n        // Show loading indicator.\n        containerWrapper.html('<div class=\"text-center py-3 text-muted\"><i class=\"fa fa-spinner fa-spin\"></i> ' +\n            loadingStr + '</div>');\n\n        const params = new URLSearchParams({\n            action: 'get_turn_questions',\n            pageid: pageid,\n            turn_id: turnId,\n            cmid: $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container').data('cmid'),\n            sesskey: Config.sesskey\n        });\n\n        return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        })\n        .then(response => {\n            if (!response.ok) {\n                throw new Error('HTTP error! status: ' + response.status);\n            }\n            return response.json();\n        })\n        .then(data => {\n            if (data.success && data.html) {\n                containerWrapper.html(data.html);\n            } else {\n                containerWrapper.html('<div class=\"text-center text-muted py-3\">' +\n                    (data.message || 'No questions available for this turn.') + '</div>');\n            }\n        })\n        .catch((error) => {\n            // eslint-disable-next-line no-console\n            console.error('Error loading turn evaluation questions:', error);\n            containerWrapper.html('<div class=\"text-danger text-center py-3\">' +\n                'Error loading questions: ' + error.message + '</div>');\n        });\n    });\n};\n\n/**\n * Load saved responses for a turn.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst loadTurnEvaluationResponses = (pageid, turnId) => {\n    const cmid = getCmid(pageid);\n    if (!cmid) {\n        return;\n    }\n\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return;\n    }\n    let container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        container = containerWrapper;\n    }\n    container.find('.question-item').each(function() {\n        resetQuestionItemToNeutral($(this));\n    });\n\n    const params = new URLSearchParams({\n        action: 'get_turn_responses',\n        cmid: cmid,\n        pageid: pageid,\n        turn_id: turnId,\n        sesskey: Config.sesskey\n    });\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php?' + params.toString(), {\n        method: 'GET',\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    })\n    .then(response => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then(data => {\n        if (!data.success || !data.responses || Object.keys(data.responses).length === 0) {\n            return;\n        }\n        Object.keys(data.responses).forEach((questionId) => {\n            const responseData = data.responses[questionId];\n            const questionItem = container.find(`.question-item[data-questionid=\"${questionId}\"]`);\n            if (questionItem.length === 0) {\n                return;\n            }\n            const questionType = questionItem.data('questiontype');\n            const value = responseData.response;\n\n            if (questionType === 'singlechoice' || questionType === 'likert') {\n                questionItem.find('input[type=\"radio\"]').prop('checked', false);\n                questionItem.find(`input[type=\"radio\"][value=\"${value}\"]`).prop('checked', true);\n            } else if (questionType === 'multiplechoice') {\n                questionItem.find('input[type=\"checkbox\"]').prop('checked', false);\n                try {\n                    const values = JSON.parse(value);\n                    if (Array.isArray(values)) {\n                        values.forEach((val) => {\n                            questionItem.find(`input[type=\"checkbox\"][value=\"${val}\"]`).prop('checked', true);\n                        });\n                    }\n                } catch (e) {\n                    // ignore invalid JSON\n                }\n            } else if (questionType === 'select') {\n                questionItem.find('select').val(value);\n            } else if (questionType === 'number') {\n                questionItem.find('input[type=\"number\"]').val(value);\n            } else if (questionType === 'shorttext') {\n                questionItem.find('input[type=\"text\"]').val(value);\n            } else if (questionType === 'longtext') {\n                questionItem.find('textarea').val(value);\n            }\n\n            if (responseData.saved_datetime) {\n                getString('saved', 'mod_harpiasurvey').then((savedText) => {\n                    getString('on', 'mod_harpiasurvey').then((onText) => {\n                        const icon = '<i class=\"fa fa-check-circle\" aria-hidden=\"true\"></i>';\n                        let savedMessage = questionItem.find('.saved-response-message');\n                        if (savedMessage.length === 0) {\n                            const messageHtml = '<div class=\"mt-2 small text-muted saved-response-message\">' +\n                                `${icon} ${savedText} ${onText} ${responseData.saved_datetime}</div>`;\n                            questionItem.append(messageHtml);\n                        } else {\n                            savedMessage.html(`${icon} ${savedText} ${onText} ${responseData.saved_datetime}`);\n                        }\n                    });\n                });\n            }\n\n            lockQuestionItem(questionItem);\n            ensureEditButton(questionItem);\n\n            getString('answerhistory', 'mod_harpiasurvey').then((historyText) => {\n                let history = questionItem.find('.answer-history');\n                if (!history.length && responseData.history_count > 1) {\n                    const details = $('<details class=\"answer-history mt-1\"></details>');\n                    details.append(`<summary>${historyText} (${responseData.history_count})</summary>`);\n                    details.append('<ul class=\"list-unstyled mt-2 mb-0\"></ul>');\n                    questionItem.append(details);\n                    history = details;\n                }\n                if (history.length) {\n                    const list = history.find('ul');\n                    list.empty();\n                    (responseData.history_items || []).forEach((item) => {\n                        list.append(`<li class=\"mb-1\"><span class=\"text-muted\">${item.time}</span>  ${item.response}</li>`);\n                    });\n                    history.find('summary').text(`${historyText} (${responseData.history_count || 0})`);\n                    if ((responseData.history_count || 0) > 1) {\n                        history.show();\n                    } else {\n                        history.hide();\n                    }\n                }\n            });\n        });\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading turn responses:', error);\n    });\n};\n\n/**\n * Clear turn evaluation form (placeholder).\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID\n */\nconst clearTurnEvaluationForm = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return;\n    }\n    let container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        container = containerWrapper;\n    }\n    container.find('.question-item').each(function() {\n        resetQuestionItemToNeutral($(this));\n    });\n};\n\nconst hasUnsavedTurnEvaluation = (pageid, turnId) => {\n    const containerWrapper = $(`#turn-evaluation-questions-container-${pageid}`);\n    if (containerWrapper.length === 0) {\n        return false;\n    }\n    const container = containerWrapper.find(`.turn-evaluation-questions[data-turn-id=\"${turnId}\"]`);\n    if (container.length === 0) {\n        return false;\n    }\n    const requiredQuestions = container.find('.question-item[data-required=\"1\"]');\n    if (requiredQuestions.length === 0) {\n        return false;\n    }\n    const savedRequired = requiredQuestions.filter(function() {\n        return $(this).find('.saved-response-message').length > 0;\n    }).length;\n    return savedRequired !== requiredQuestions.length;\n};\n\n/**\n * Filter messages by conversation ID (no-op in turns).\n */\nconst filterMessagesByConversation = () => {};\n\n/**\n * Navigate to a specific turn in the conversation.\n *\n * @param {number} pageid Page ID\n * @param {number} turnId Turn ID to navigate to\n * @param {boolean} setAsCurrent Whether to set this turn as the current turn (for new branches)\n */\nconst navigateToTurn = (pageid, turnId, setAsCurrent = false) => {\n    // If this is a new turn (like a branch), set it as current FIRST so chat is unlocked.\n    if (setAsCurrent) {\n        currentTurns[pageid] = turnId;\n    }\n    // Then set viewing turn.\n    setViewingTurn(pageid, turnId);\n    // Update display and lock state.\n    updateTurnDisplay(pageid);\n    updateChatLockState(pageid);\n\n    // Collapse previous separators when navigating forward.\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.turn-separator').each(function() {\n        const separatorTurnId = $(this).data('turn-separator');\n        if (separatorTurnId) {\n            if (parseInt(separatorTurnId, 10) < turnId) {\n                $(this).data('collapsed', true);\n                const toggleIcon = $(this).find('.toggle-turn-btn').find('.toggle-turn-icon');\n                if (toggleIcon.length > 0) {\n                    toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');\n                }\n            }\n        }\n    });\n\n    filterMessagesByTurn(pageid, turnId);\n    updateSubpageVisibility(pageid);\n    ensureTurnEvaluationQuestionsRendered(pageid, turnId).then(() => {\n        clearTurnEvaluationForm(pageid, turnId);\n        loadTurnEvaluationResponses(pageid, turnId);\n    });\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n    if (sidebar.length) {\n        sidebar.data('sidebar-view', 'detail');\n        loadConversationTree(pageid);\n    }\n};\n\n/**\n * Update subpage visibility for turns mode.\n *\n * @param {number} pageid Page ID\n */\nconst updateSubpageVisibility = (pageid) => {\n    const viewingTurn = getViewingTurn(pageid);\n    const subpagesContainer = $(`#subpages-container-${pageid}`);\n\n    if (subpagesContainer.length === 0) {\n        return; // No subpages container found.\n    }\n\n    // Update subpage visibility.\n    subpagesContainer.find('.subpage-item').each(function() {\n        const $subpage = $(this);\n        const visibilityType = $subpage.data('visibility-type');\n        const turnNumber = $subpage.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = false;\n        }\n\n        if (shouldShow) {\n            $subpage.slideDown(200);\n            // Update question visibility within this subpage.\n            updateSubpageQuestionVisibility($subpage, viewingTurn);\n        } else {\n            $subpage.slideUp(200);\n        }\n    });\n};\n\n/**\n * Update question visibility within a subpage based on current turn.\n *\n * @param {jQuery} $subpage Subpage jQuery element\n * @param {number} viewingTurn Current viewing turn\n */\nconst updateSubpageQuestionVisibility = ($subpage, viewingTurn) => {\n    $subpage.find('.question-item').each(function() {\n        const $question = $(this);\n        const visibilityType = $question.data('visibility-type') || 'all_turns';\n        const turnNumber = $question.data('turn-number');\n\n        let shouldShow = false;\n\n        switch (visibilityType) {\n            case 'all_turns':\n                shouldShow = true;\n                break;\n            case 'first_turn':\n                shouldShow = (viewingTurn === 1);\n                break;\n            case 'specific_turn':\n                shouldShow = (viewingTurn === turnNumber);\n                break;\n            default:\n                shouldShow = true; // Default to showing if not set.\n        }\n\n        if (shouldShow) {\n            $question.slideDown(200);\n        } else {\n            $question.slideUp(200);\n        }\n    });\n};\n\n/**\n * Load conversation tree from server and render it.\n *\n * @param {number} pageid Page ID\n * @return {Promise} Promise that resolves when tree is loaded\n */\nconst loadConversationTree = (pageid) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n    if (treeContainer.length === 0) {\n        // eslint-disable-next-line no-console\n        console.warn('Tree container not found for pageid:', pageid);\n        return Promise.resolve(null);\n    }\n\n    // Get cmid from the container.\n    const cmid = getCmid(pageid);\n    if (!cmid) {\n        // eslint-disable-next-line no-console\n        console.error('cmid not found for pageid:', pageid);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error: Course module ID not found. Please refresh the page.</div>');\n        return Promise.resolve(null);\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'get_conversation_tree');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n    return fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        // eslint-disable-next-line no-console\n        console.log('Conversation tree response:', data);\n\n        if (data.success && data.tree) {\n            // Annotate roots with sequential conversation numbers for consistent labels.\n            data.tree.roots = (data.tree.roots || []).map((root, idx) => ({\n                ...root,\n                conversation_number: idx + 1\n            }));\n            // Store tree for message filtering.\n            conversationTrees[pageid] = data.tree;\n\n            const chatContainer = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n            const hasExplicitViewingTurn = typeof chatContainer.attr('data-viewing-turn') !== 'undefined' &&\n                chatContainer.attr('data-viewing-turn') !== '';\n            const viewingTurn = hasExplicitViewingTurn ? getViewingTurn(pageid) : null;\n            const viewMode = sidebar.data('sidebar-view');\n            const branchRootId = sidebar.data('branch-root');\n            if (!viewMode || viewMode === 'list') {\n                renderConversationList(pageid, data.tree.roots);\n            } else {\n                const root = branchRootId ? findNodeByTurnId(data.tree.roots || [], branchRootId) :\n                    (viewingTurn ? findRootForTurn(data.tree.roots || [], viewingTurn) : null);\n                if (root) {\n                    renderConversationDetail(pageid, root);\n                } else {\n                    renderConversationList(pageid, data.tree.roots);\n                }\n            }\n            if (hasExplicitViewingTurn && viewingTurn) {\n                syncTurnsUrlState(pageid, viewingTurn);\n\n                // Re-filter messages now that we have the tree, so previous-turn messages are correctly\n                // marked and hidden by default, with the toggle controlling them.\n                filterMessagesByTurn(pageid, viewingTurn);\n            }\n\n            // Show create-root button only when in list view (outside a conversation).\n            const rootBtn = sidebar.find('.create-root-btn');\n            if (rootBtn.length) {\n                const viewMode = sidebar.data('sidebar-view');\n                if (!viewMode || viewMode === 'list') {\n                    rootBtn.show();\n                } else {\n                    rootBtn.hide();\n                }\n            }\n\n            return data.tree;\n        } else {\n            // Show message in tree container instead of notification.\n            treeContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                (data.message || 'No conversation tree available yet.') + '</div>');\n            return null;\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error loading conversation tree:', error);\n        treeContainer.html('<div class=\"text-danger text-center small py-3\">' +\n            'Error loading conversation tree: ' + error.message + '<br>' +\n            'Please check the browser console for details and refresh the page.</div>');\n        return null;\n    });\n};\n\n/**\n * Find the root node that contains the given turn ID.\n */\nconst getTurnNumberForId = (pageid, turnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return null;\n    }\n\n    const root = findRootForTurn(tree.roots, turnId);\n    if (!root) {\n        return null;\n    }\n\n    const findAndNumber = (node, targetId, parentNumber, turnIndex) => {\n        const nodeNumber = calculateTurnNumber(node, turnIndex, parentNumber);\n\n        if (parseInt(node.turn_id, 10) === parseInt(targetId, 10)) {\n            return nodeNumber;\n        }\n\n        // Check direct branches if this is a root.\n        if (node.direct_branches && node.direct_branches.length > 0) {\n            // Sort direct branches by turn_id for consistent ordering.\n            const sortedDB = [...node.direct_branches].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            for (let i = 0; i < sortedDB.length; i++) {\n                const db = sortedDB[i];\n                const dbNumber = calculateTurnNumber(db, i, nodeNumber);\n                if (parseInt(db.turn_id, 10) === parseInt(targetId, 10)) {\n                    return dbNumber;\n                }\n                // Check children of direct branch (derived branches).\n                if (db.children && db.children.length > 0) {\n                    const sortedChildren = [...db.children].sort((a, b) =>\n                        parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n                    );\n                    for (let i = 0; i < sortedChildren.length; i++) {\n                        const found = findAndNumber(sortedChildren[i], targetId, dbNumber, i);\n                        if (found) {\n                            return found;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Check children (derived branches).\n        if (node.children && node.children.length > 0) {\n            const sortedChildren = [...node.children].sort((a, b) =>\n                parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n            );\n            for (let i = 0; i < sortedChildren.length; i++) {\n                const found = findAndNumber(sortedChildren[i], targetId, nodeNumber, i);\n                if (found) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    };\n\n    // Start from root (turnIndex 0 = turn number 1).\n    return findAndNumber(root, turnId, null, 0);\n};\n\n/**\n * Prepare node data for recursive rendering.\n */\nconst prepareNodeData = (node, level, currentTurnId, pageid, cmid, turnIndex = 0, parentNumber = null,\n    includeChildren = true, forcedTurnNumber = null) => {\n    const isCurrent = parseInt(node.turn_id, 10) === parseInt(currentTurnId, 10);\n    const hasChildren = node.children && node.children.length > 0;\n    const isDirectBranch = node.is_direct_branch || false;\n    const isRoot = node.is_root || false;\n    const turnNumber = forcedTurnNumber !== null ? String(forcedTurnNumber) : calculateTurnNumber(node, turnIndex, parentNumber);\n\n    return {\n        turn_id: node.turn_id,\n        conversation_id: node.conversation_id || node.turn_id, // Use conversation_id if available, fallback to turn_id\n        turn_number: turnNumber,\n        is_root: isRoot,\n        is_direct_branch: isDirectBranch,\n        is_current: isCurrent,\n        has_children: hasChildren,\n        branch_label: node.branch_label || null,\n        level: level,\n        expanded: true,\n        pageid: pageid,\n        cmid: cmid,\n        can_create_branch: true, // Turns-only module\n        children: (includeChildren && hasChildren) ? node.children.map((child, index) =>\n            // Keep descendants at the same visual level as their branch root; only the bifurcation is indented.\n            prepareNodeData(child, isDirectBranch ? level : level + 1, currentTurnId, pageid, cmid, index, turnNumber, includeChildren)) : []\n    };\n};\n\n/**\n * Render conversation detail view (single root tree).\n */\nconst renderConversationDetail = (pageid, root) => {\n    const treeContainer = $(`#conversation-tree-${pageid}`);\n    const container = $(`#chat-messages-page-${pageid}`).closest('.ai-conversation-container');\n    const cmid = container.data('cmid');\n    const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n\n    const viewingTurn = getViewingTurn(pageid);\n    const branchStack = sidebar.data('branch-stack');\n    const showBranchBack = Array.isArray(branchStack) && branchStack.length > 0;\n    const isBranchRoot = !root.is_root;\n\n    sidebar.data('branch-root', root.turn_id);\n\n    // Calculate turn numbers: root is 1, direct siblings are 1.1, 1.2, 1.3...\n    let turnCounter = 0; // Will be incremented to 1 for root, 2 for first direct branch, etc.\n    const rootTurnNumber = getTurnNumberForId(pageid, root.turn_id) || '1';\n    const rootNodeData = prepareNodeData(root, 0, viewingTurn, pageid, cmid, turnCounter, null, false, rootTurnNumber);\n    rootNodeData.suppress_inline_branch_button = true; // First turn in conversation.\n    turnCounter++;\n\n    // Find direct branches of this root (branches where parent is this root).\n    // Direct branches are stored in the root's direct_branches array.\n    const directBranches = [];\n    const childBranches = root.is_root ? (root.direct_branches || []) : (root.children || []);\n    if (childBranches.length > 0) {\n        const sortedDirectBranches = [...childBranches].sort((a, b) =>\n            parseInt(a.turn_id, 10) - parseInt(b.turn_id, 10)\n        );\n        sortedDirectBranches.forEach((node, index) => {\n            const childTurnNumber = getTurnNumberForId(pageid, node.turn_id) ||\n                calculateTurnNumber(node, index, rootTurnNumber);\n            // Direct siblings are numbered relative to the original turn: 1.1, 1.2, ...\n            directBranches.push(prepareNodeData(\n                node,\n                0,\n                viewingTurn,\n                pageid,\n                cmid,\n                index,\n                rootTurnNumber,\n                false,\n                childTurnNumber\n            ));\n            turnCounter++;\n        });\n        if (directBranches.length > 0) {\n            directBranches[directBranches.length - 1].suppress_inline_branch_button = true; // Last turn in conversation.\n        }\n    }\n\n    Templates.render('mod_harpiasurvey/conversation_detail', {\n        root_node: rootNodeData,\n        root_turn_id: root.turn_id,\n        direct_branches: directBranches,\n        pageid: pageid,\n        cmid: cmid,\n        conversation_number: root.conversation_number || 1,\n        show_branch_back: showBranchBack,\n        branch_root_turn: isBranchRoot ? root.turn_id : null\n    }).then((html) => {\n        treeContainer.html(html);\n        treeContainer.find('[data-toggle=\"popover\"]').popover({\n            trigger: 'hover',\n            placement: 'top',\n            container: 'body'\n        });\n    }).catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error rendering conversation detail:', error);\n    });\n};\n\nconst findNodeByTurnId = (roots, turnId) => {\n    if (!roots || !turnId) {\n        return null;\n    }\n    const target = parseInt(turnId, 10);\n    const queue = [...roots];\n    while (queue.length) {\n        const node = queue.shift();\n        if (!node) {\n            continue;\n        }\n        if (parseInt(node.turn_id, 10) === target) {\n            return node;\n        }\n        if (node.direct_branches && node.direct_branches.length) {\n            queue.push(...node.direct_branches);\n        }\n        if (node.children && node.children.length) {\n            queue.push(...node.children);\n        }\n    }\n    return null;\n};\n\n/**\n * Update turn labels in existing messages (after tree is loaded).\n */\nconst updateMessageTurnLabels = (pageid) => {\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n    messagesContainer.find('.message').each(function() {\n        const $msg = $(this);\n        const turnId = parseInt($msg.data('turn-id'), 10);\n        if (turnId) {\n            // Use hierarchical turn number.\n            const turnNumber = getTurnNumberForId(pageid, turnId) || turnId;\n            const turnLabel = 'Turno ' + turnNumber;\n            // Update badge in message - find the badge that contains turn label.\n            const $badge = $msg.find('.badge').filter(function() {\n                // Find badge that's in the position-absolute div (turn label badge).\n                return $(this).closest('.position-absolute').length > 0;\n            });\n            if ($badge.length > 0) {\n                $badge.text(turnLabel);\n            } else {\n                // Fallback: update first badge if position-absolute not found.\n                const $firstBadge = $msg.find('.badge').first();\n                if ($firstBadge.length > 0) {\n                    $firstBadge.text(turnLabel);\n                }\n            }\n        }\n    });\n};\n\n/**\n * Create a branch from a specific turn.\n */\nconst createBranchFromTurn = (cmid, pageid, parentTurnId, buttonEl = null) => {\n    const btn = buttonEl ? $(buttonEl) : null;\n    let originalHtml = null;\n    if (btn && btn.length) {\n        originalHtml = btn.html();\n        btn.prop('disabled', true).addClass('branch-btn-loading');\n        btn.html('<i class=\"fa fa-spinner fa-spin fa-xs\" aria-hidden=\"true\"></i>');\n    }\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_branch');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('parent_turn_id', parentTurnId);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        if (data.success) {\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            if (sidebar.length) {\n                let stack = sidebar.data('branch-stack');\n                if (!Array.isArray(stack)) {\n                    stack = [];\n                }\n                const currentRoot = sidebar.data('branch-root');\n                if (currentRoot) {\n                    stack.push(currentRoot);\n                }\n                sidebar.data('branch-stack', stack);\n                sidebar.data('branch-root', parentTurnId);\n                sidebar.data('sidebar-view', 'detail');\n            }\n\n            // Navigate to the new turn and set it as current (this will unlock the chat).\n            navigateToTurn(pageid, data.new_turn_id, true);\n\n            // Optimistically update local tree for immediate visual feedback.\n            addLocalBranchNode(pageid, parentTurnId, data.new_turn_id);\n\n            // Reload conversation tree to show the new branch.\n            loadConversationTree(pageid);\n\n            getString('branchcreated', 'mod_harpiasurvey')\n                .then((msg) => {\n                    Notification.addNotification({\n                        message: msg,\n                        type: 'success'\n                    });\n                })\n                .catch(() => {\n                    Notification.addNotification({\n                        message: 'Branch created successfully',\n                        type: 'success'\n                    });\n                });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create turn',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        if (btn && btn.length) {\n            btn.prop('disabled', false).removeClass('branch-btn-loading');\n            if (originalHtml !== null) {\n                btn.html(originalHtml);\n            }\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error creating turn:', error);\n        Notification.addNotification({\n            message: 'Error creating turn: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\n/**\n * Add a branch node locally so the tree shows immediate indentation before reload.\n */\nconst addLocalBranchNode = (pageid, parentTurnId, newTurnId) => {\n    const tree = conversationTrees[pageid];\n    if (!tree || !tree.roots) {\n        return;\n    }\n    const root = findRootForTurn(tree.roots, parentTurnId);\n    if (!root) {\n        return;\n    }\n\n    const newNode = {\n        turn_id: newTurnId,\n        is_root: false,\n        is_direct_branch: false,\n        parent_turn_id: parentTurnId,\n        branch_label: String(newTurnId),\n        children: [],\n        timecreated: Math.floor(Date.now() / 1000),\n        timecreated_str: new Date().toLocaleString()\n    };\n\n    const attach = (node) => {\n        if (parseInt(node.turn_id, 10) === parseInt(parentTurnId, 10)) {\n            if (node.is_root || node.is_direct_branch) {\n                newNode.is_direct_branch = true;\n                if (!node.direct_branches) {\n                    node.direct_branches = [];\n                }\n                node.direct_branches.push(newNode);\n            } else {\n                if (!node.children) {\n                    node.children = [];\n                }\n                node.children.push(newNode);\n            }\n            return true;\n        }\n        if (node.direct_branches) {\n            for (const db of node.direct_branches) {\n                if (attach(db)) {\n                    return true;\n                }\n            }\n        }\n        if (node.children) {\n            for (const child of node.children) {\n                if (attach(child)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    };\n\n    attach(root);\n};\n\n/**\n * Create a new root conversation.\n */\nconst createNewRoot = (cmid, pageid) => {\n    const container = $(`.ai-conversation-container[data-pageid=\"${pageid}\"]`);\n    const messagesContainer = $(`#chat-messages-page-${pageid}`);\n\n    const params = new URLSearchParams();\n    params.append('action', 'create_root');\n    params.append('cmid', cmid);\n    params.append('pageid', pageid);\n    params.append('sesskey', Config.sesskey);\n\n    fetch(Config.wwwroot + '/mod/harpiasurvey/ajax.php', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/x-www-form-urlencoded'\n        },\n        body: params.toString()\n    })\n    .then((response) => {\n        if (!response.ok) {\n            throw new Error('HTTP error! status: ' + response.status);\n        }\n        return response.json();\n    })\n    .then((data) => {\n        if (data.success) {\n            currentTurns[pageid] = data.new_turn_id;\n            setViewingTurn(pageid, data.new_turn_id);\n            updateTurnDisplay(pageid);\n            updateChatLockState(pageid);\n            messagesContainer.html('<div class=\"text-muted text-center small py-3\">' +\n                'New conversation started. Send a message to begin.</div>');\n            $(`#turn-evaluation-questions-container-${pageid}`).empty();\n\n            const sidebar = $(`#conversation-tree-sidebar-${pageid}`);\n            sidebar.data('sidebar-view', 'detail');\n            setTimeout(() => {\n                loadConversationTree(pageid);\n            }, 100);\n\n            Notification.addNotification({\n                message: data.message || 'New conversation created successfully',\n                type: 'success'\n            });\n        } else {\n            Notification.addNotification({\n                message: data.message || 'Failed to create new root',\n                type: 'error'\n            });\n        }\n    })\n    .catch((error) => {\n        // eslint-disable-next-line no-console\n        console.error('Error creating new root:', error);\n        Notification.addNotification({\n            message: 'Error creating new root: ' + error.message,\n            type: 'error'\n        });\n    });\n};\n\nconst setPreviousMessagesVisibility = (pageid, visible) => {\n    const container = $(`#chat-messages-page-${pageid}`);\n    container.data('show-previous', visible === true);\n    const prevMessages = container.find('.previous-turn-message');\n    if (visible) {\n        prevMessages.show();\n    } else {\n        prevMessages.hide();\n    }\n    const toggleBtn = $(`.toggle-previous-messages-btn[data-pageid=\"${pageid}\"]`);\n    if (toggleBtn.length) {\n        updatePreviousToggleLabel(toggleBtn, visible);\n    }\n};\n\nconst updatePreviousToggleLabel = (btn, isVisible) => {\n    if (isVisible) {\n        btn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Ocultar anteriores');\n        btn.attr('title', 'Ocultar conversas anteriores');\n    } else {\n        btn.html('<i class=\"fa fa-history\" aria-hidden=\"true\"></i> Mostrar anteriores');\n        btn.attr('title', 'Mostrar conversas anteriores');\n    }\n};\n\nexport {\n    updateTurnDisplay,\n    getViewingTurn,\n    getCurrentTurn,\n    setViewingTurn,\n    isTurnComplete,\n    loadConversationTree,\n    navigateToTurn,\n    renderConversationDetail,\n    prepareNodeData,\n    updateMessageTurnLabels,\n    setPreviousMessagesVisibility,\n    scrollToBottom,\n    createBranchFromTurn,\n    createNewRoot\n};\n\nexport default {\n    init,\n    initTurns\n};\n"],"names":["initializedTurns","commonHandlersRegistered","turnHandlersRegistered","treeHandlersRegistered","editLabel","resetQuestionItemToNeutral","questionItem","length","removeAttr","find","remove","prop","each","this","Boolean","defaultChecked","select","defaultOption","filter","defaultSelected","first","val","defaultValue","initialize","then","str","catch","containers","pageid","parseInt","data","messagesContainer","maxTurn","turnId","calculatedCurrentTurn","currentTurns","urlParams","URLSearchParams","window","location","search","urlTurn","get","urlBranch","initialViewingTurn","hasExplicitInitialTurn","parsedTurn","isNaN","sidebar","parsedBranchRoot","shouldAutoloadSelection","setViewingTurn","updateTurnDisplay","updateChatLockState","setNoTurnSelectedState","show","addClass","loadConversationTree","filterMessagesByTurn","updateSubpageVisibility","setTimeout","ensureTurnEvaluationQuestionsRendered","loadTurnEvaluationResponses","error","console","document","on","e","preventDefault","button","cmid","container","closest","addNotification","message","type","input","inputValue","trim","viewingTurn","getViewingTurn","currentTurn","getCurrentTurn","viewingTurnNum","maxTurns","maxTurnsNum","turnCount","getTurnCountForConversation","isTurnComplete","modelsdata","modelid","modelids","split","tempId","Date","now","Math","random","toString","substr","displayUserMessage","loading","sendMessage","key","shiftKey","click","btn","currentlyVisible","setPreviousMessagesVisibility","registerCommonHandlers","node","attr","replace","navigateToTurn","item","rootTurnId","syncTurnsUrlState","tree","conversationTrees","roots","stack","Array","isArray","previousRoot","pop","stopPropagation","targetNode","findNodeByTurnId","children","currentRoot","push","branchMode","currentViewingTurn","hasUnsavedTurnEvaluation","createBranchFromTurn","trigger","parentTurnId","createNewRoot","behavior","params","append","Config","sesskey","conversationId","open","wwwroot","registerTreeHandlers","evaluationContainer","responses","collectTurnEvaluationResponses","Object","keys","originalText","text","saveTurnEvaluationResponses","registerTurnHandlers","init","initTurns","isLocked","String","isEditing","questionId","questionType","responseValue","checked","values","JSON","stringify","selected","textarea","entries","failedCount","promiseChain","Promise","resolve","forEach","_ref","response","action","questionid","turn_id","fetch","method","headers","res","json","success","turnOverride","turn","branchRoot","viewMode","set","delete","newUrl","pathname","history","replaceState","hide","evalContainer","empty","badge","sendButton","label","turnStr","turnHasMessages","turnMessages","role","last","root","shouldShowPrevious","allowedTurnIds","Set","add","addPath","targetId","path","id","direct_branches","db","child","$msg","messageTurnId","removeClass","isCurrentTurn","has","$separator","separatorTurnId","toggleBtn","isVisible","is","updatePreviousToggleLabel","currentTurnNum","sendBtn","lockMessage","conversationTurnCount","hasReachedTurnLimit","directBranchContainer","ok","Error","status","messageid","content","displayAIMessage","focus","render","timecreated","floor","html","Notification","exception","Templates","containerWrapper","existingContainer","loadingStr","responseData","value","parse","saved_datetime","savedText","onText","icon","savedMessage","messageHtml","lockQuestionItem","controls","ensureEditButton","historyText","history_count","details","list","history_items","time","clearTurnEvaluationForm","requiredQuestions","setAsCurrent","toggleIcon","subpagesContainer","$subpage","visibilityType","turnNumber","shouldShow","slideDown","updateSubpageQuestionVisibility","slideUp","$question","treeContainer","warn","body","log","map","idx","conversation_number","chatContainer","hasExplicitViewingTurn","branchRootId","renderConversationDetail","rootBtn","getTurnNumberForId","findAndNumber","parentNumber","turnIndex","nodeNumber","sortedDB","sort","a","b","i","dbNumber","sortedChildren","found","prepareNodeData","level","currentTurnId","includeChildren","forcedTurnNumber","isCurrent","hasChildren","isDirectBranch","is_direct_branch","isRoot","is_root","conversation_id","turn_number","is_current","has_children","branch_label","expanded","can_create_branch","index","branchStack","showBranchBack","isBranchRoot","turnCounter","rootTurnNumber","rootNodeData","suppress_inline_branch_button","directBranches","childBranches","childTurnNumber","root_node","root_turn_id","show_branch_back","branch_root_turn","popover","placement","target","queue","shift","turnLabel","$badge","$firstBadge","buttonEl","originalHtml","new_turn_id","addLocalBranchNode","msg","newTurnId","newNode","parent_turn_id","timecreated_str","toLocaleString","attach","visible","prevMessages"],"mappings":"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"}